// Generated from grammars-v4/cql3/CqlParser.g4 by ANTLR 4.8
#![allow(dead_code)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(nonstandard_style)]
#![allow(unused_imports)]
#![allow(unused_mut)]
use antlr_rust::PredictionContextCache;
use antlr_rust::parser::{Parser, BaseParser, ParserRecog, ParserNodeType};
use antlr_rust::token_stream::TokenStream;
use antlr_rust::TokenSource;
use antlr_rust::parser_atn_simulator::ParserATNSimulator;
use antlr_rust::errors::*;
use antlr_rust::rule_context::{BaseRuleContext, CustomRuleContext, RuleContext};
use antlr_rust::recognizer::{Recognizer,Actions};
use antlr_rust::atn_deserializer::ATNDeserializer;
use antlr_rust::dfa::DFA;
use antlr_rust::atn::{ATN, INVALID_ALT};
use antlr_rust::error_strategy::{ErrorStrategy, DefaultErrorStrategy};
use antlr_rust::parser_rule_context::{BaseParserRuleContext, ParserRuleContext,cast,cast_mut};
use antlr_rust::tree::*;
use antlr_rust::token::{TOKEN_EOF,OwningToken,Token};
use antlr_rust::int_stream::EOF;
use antlr_rust::vocabulary::{Vocabulary,VocabularyImpl};
use antlr_rust::token_factory::{CommonTokenFactory,TokenFactory, TokenAware};
use super::cqlparserlistener::*;
use super::cqlparservisitor::*;

use antlr_rust::lazy_static;
use antlr_rust::{TidAble,TidExt};

use std::marker::PhantomData;
use std::sync::Arc;
use std::rc::Rc;
use std::convert::TryFrom;
use std::cell::RefCell;
use std::ops::{DerefMut, Deref};
use std::borrow::{Borrow,BorrowMut};
use std::any::{Any,TypeId};

		pub const LR_BRACKET:isize=1; 
		pub const RR_BRACKET:isize=2; 
		pub const LC_BRACKET:isize=3; 
		pub const RC_BRACKET:isize=4; 
		pub const LS_BRACKET:isize=5; 
		pub const RS_BRACKET:isize=6; 
		pub const COMMA:isize=7; 
		pub const SEMI:isize=8; 
		pub const COLON:isize=9; 
		pub const SPACE:isize=10; 
		pub const SPEC_MYSQL_COMMENT:isize=11; 
		pub const COMMENT_INPUT:isize=12; 
		pub const LINE_COMMENT:isize=13; 
		pub const DOT:isize=14; 
		pub const STAR:isize=15; 
		pub const DIVIDE:isize=16; 
		pub const MODULE:isize=17; 
		pub const PLUS:isize=18; 
		pub const MINUSMINUS:isize=19; 
		pub const MINUS:isize=20; 
		pub const DQUOTE:isize=21; 
		pub const SQUOTE:isize=22; 
		pub const K_ADD:isize=23; 
		pub const K_AGGREGATE:isize=24; 
		pub const K_ALL:isize=25; 
		pub const K_ALLOW:isize=26; 
		pub const K_ALTER:isize=27; 
		pub const K_AND:isize=28; 
		pub const K_ANY:isize=29; 
		pub const K_APPLY:isize=30; 
		pub const K_AS:isize=31; 
		pub const K_ASC:isize=32; 
		pub const K_AUTHORIZE:isize=33; 
		pub const K_BATCH:isize=34; 
		pub const K_BEGIN:isize=35; 
		pub const K_BY:isize=36; 
		pub const K_CALLED:isize=37; 
		pub const K_CLUSTERING:isize=38; 
		pub const K_COLUMNFAMILY:isize=39; 
		pub const K_COMPACT:isize=40; 
		pub const K_CONSISTENCY:isize=41; 
		pub const K_CONTAINS:isize=42; 
		pub const K_CREATE:isize=43; 
		pub const K_CUSTOM:isize=44; 
		pub const K_DELETE:isize=45; 
		pub const K_DESC:isize=46; 
		pub const K_DESCRIBE:isize=47; 
		pub const K_DISTINCT:isize=48; 
		pub const K_DROP:isize=49; 
		pub const K_DURABLE_WRITES:isize=50; 
		pub const K_EACH_QUORUM:isize=51; 
		pub const K_ENTRIES:isize=52; 
		pub const K_EXECUTE:isize=53; 
		pub const K_EXISTS:isize=54; 
		pub const K_FALSE:isize=55; 
		pub const K_FILTERING:isize=56; 
		pub const K_FINALFUNC:isize=57; 
		pub const K_FROM:isize=58; 
		pub const K_FULL:isize=59; 
		pub const K_FUNCTION:isize=60; 
		pub const K_FUNCTIONS:isize=61; 
		pub const K_GRANT:isize=62; 
		pub const K_IF:isize=63; 
		pub const K_IN:isize=64; 
		pub const K_INDEX:isize=65; 
		pub const K_INFINITY:isize=66; 
		pub const K_INITCOND:isize=67; 
		pub const K_INPUT:isize=68; 
		pub const K_INSERT:isize=69; 
		pub const K_INTO:isize=70; 
		pub const K_IS:isize=71; 
		pub const K_JSON:isize=72; 
		pub const K_KEY:isize=73; 
		pub const K_KEYS:isize=74; 
		pub const K_KEYSPACE:isize=75; 
		pub const K_KEYSPACES:isize=76; 
		pub const K_LANGUAGE:isize=77; 
		pub const K_LEVEL:isize=78; 
		pub const K_LIMIT:isize=79; 
		pub const K_LOCAL_ONE:isize=80; 
		pub const K_LOCAL_QUORUM:isize=81; 
		pub const K_LOGGED:isize=82; 
		pub const K_LOGIN:isize=83; 
		pub const K_MATERIALIZED:isize=84; 
		pub const K_MODIFY:isize=85; 
		pub const K_NAN:isize=86; 
		pub const K_NORECURSIVE:isize=87; 
		pub const K_NOSUPERUSER:isize=88; 
		pub const K_NOT:isize=89; 
		pub const K_NULL:isize=90; 
		pub const K_OF:isize=91; 
		pub const K_ON:isize=92; 
		pub const K_ONE:isize=93; 
		pub const K_OPTIONS:isize=94; 
		pub const K_OR:isize=95; 
		pub const K_ORDER:isize=96; 
		pub const K_PARTITION:isize=97; 
		pub const K_PASSWORD:isize=98; 
		pub const K_PER:isize=99; 
		pub const K_PERMISSION:isize=100; 
		pub const K_PERMISSIONS:isize=101; 
		pub const K_PRIMARY:isize=102; 
		pub const K_QUORUM:isize=103; 
		pub const K_RENAME:isize=104; 
		pub const K_REPLACE:isize=105; 
		pub const K_REPLICATION:isize=106; 
		pub const K_RETURNS:isize=107; 
		pub const K_REVOKE:isize=108; 
		pub const K_ROLE:isize=109; 
		pub const K_ROLES:isize=110; 
		pub const K_SCHEMA:isize=111; 
		pub const K_SELECT:isize=112; 
		pub const K_SET:isize=113; 
		pub const K_SFUNC:isize=114; 
		pub const K_STATIC:isize=115; 
		pub const K_STORAGE:isize=116; 
		pub const K_STYPE:isize=117; 
		pub const K_SUPERUSER:isize=118; 
		pub const K_TABLE:isize=119; 
		pub const K_THREE:isize=120; 
		pub const K_TIMESTAMP:isize=121; 
		pub const K_TO:isize=122; 
		pub const K_TOKEN:isize=123; 
		pub const K_TRIGGER:isize=124; 
		pub const K_TRUE:isize=125; 
		pub const K_TRUNCATE:isize=126; 
		pub const K_TTL:isize=127; 
		pub const K_TWO:isize=128; 
		pub const K_TYPE:isize=129; 
		pub const K_UNLOGGED:isize=130; 
		pub const K_UPDATE:isize=131; 
		pub const K_USE:isize=132; 
		pub const K_USER:isize=133; 
		pub const K_USING:isize=134; 
		pub const K_UUID:isize=135; 
		pub const K_VALUES:isize=136; 
		pub const K_VIEW:isize=137; 
		pub const K_WHERE:isize=138; 
		pub const K_WITH:isize=139; 
		pub const K_WRITETIME:isize=140; 
		pub const K_ASCII:isize=141; 
		pub const K_BIGINT:isize=142; 
		pub const K_BLOB:isize=143; 
		pub const K_BOOLEAN:isize=144; 
		pub const K_COUNTER:isize=145; 
		pub const K_DATE:isize=146; 
		pub const K_DECIMAL:isize=147; 
		pub const K_DOUBLE:isize=148; 
		pub const K_FLOAT:isize=149; 
		pub const K_FROZEN:isize=150; 
		pub const K_INET:isize=151; 
		pub const K_INT:isize=152; 
		pub const K_LIST:isize=153; 
		pub const K_MAP:isize=154; 
		pub const K_SMALLINT:isize=155; 
		pub const K_TEXT:isize=156; 
		pub const K_TIMEUUID:isize=157; 
		pub const K_TIME:isize=158; 
		pub const K_TINYINT:isize=159; 
		pub const K_TUPLE:isize=160; 
		pub const K_VARCHAR:isize=161; 
		pub const K_VARINT:isize=162; 
		pub const CODE_BLOCK:isize=163; 
		pub const STRING_LITERAL:isize=164; 
		pub const DECIMAL_LITERAL:isize=165; 
		pub const FLOAT_LITERAL:isize=166; 
		pub const HEXADECIMAL_LITERAL:isize=167; 
		pub const REAL_LITERAL:isize=168; 
		pub const OBJECT_NAME:isize=169; 
		pub const UUID:isize=170; 
		pub const OPERATOR_EQ:isize=171; 
		pub const OPERATOR_LT:isize=172; 
		pub const OPERATOR_GT:isize=173; 
		pub const OPERATOR_LTE:isize=174; 
		pub const OPERATOR_GTE:isize=175; 
		pub const K_USERS:isize=176;
	pub const RULE_root:usize = 0; 
	pub const RULE_cqls:usize = 1; 
	pub const RULE_statementSeparator:usize = 2; 
	pub const RULE_empty_:usize = 3; 
	pub const RULE_cql:usize = 4; 
	pub const RULE_revoke:usize = 5; 
	pub const RULE_listUsers:usize = 6; 
	pub const RULE_listRoles:usize = 7; 
	pub const RULE_listPermissions:usize = 8; 
	pub const RULE_grant:usize = 9; 
	pub const RULE_priviledge:usize = 10; 
	pub const RULE_resource:usize = 11; 
	pub const RULE_createUser:usize = 12; 
	pub const RULE_createRole:usize = 13; 
	pub const RULE_createType:usize = 14; 
	pub const RULE_typeMemberColumnList:usize = 15; 
	pub const RULE_createTrigger:usize = 16; 
	pub const RULE_createMaterializedView:usize = 17; 
	pub const RULE_materializedViewWhere:usize = 18; 
	pub const RULE_columnNotNullList:usize = 19; 
	pub const RULE_columnNotNull:usize = 20; 
	pub const RULE_materializedViewOptions:usize = 21; 
	pub const RULE_createKeyspace:usize = 22; 
	pub const RULE_createFunction:usize = 23; 
	pub const RULE_codeBlock:usize = 24; 
	pub const RULE_paramList:usize = 25; 
	pub const RULE_returnMode:usize = 26; 
	pub const RULE_createAggregate:usize = 27; 
	pub const RULE_initCondDefinition:usize = 28; 
	pub const RULE_initCondHash:usize = 29; 
	pub const RULE_initCondHashItem:usize = 30; 
	pub const RULE_initCondListNested:usize = 31; 
	pub const RULE_initCondList:usize = 32; 
	pub const RULE_orReplace:usize = 33; 
	pub const RULE_alterUser:usize = 34; 
	pub const RULE_userPassword:usize = 35; 
	pub const RULE_userSuperUser:usize = 36; 
	pub const RULE_alterType:usize = 37; 
	pub const RULE_alterTypeOperation:usize = 38; 
	pub const RULE_alterTypeRename:usize = 39; 
	pub const RULE_alterTypeRenameList:usize = 40; 
	pub const RULE_alterTypeRenameItem:usize = 41; 
	pub const RULE_alterTypeAdd:usize = 42; 
	pub const RULE_alterTypeAlterType:usize = 43; 
	pub const RULE_alterTable:usize = 44; 
	pub const RULE_alterTableOperation:usize = 45; 
	pub const RULE_alterTableWith:usize = 46; 
	pub const RULE_alterTableRename:usize = 47; 
	pub const RULE_alterTableDropCompactStorage:usize = 48; 
	pub const RULE_alterTableDropColumns:usize = 49; 
	pub const RULE_alterTableDropColumnList:usize = 50; 
	pub const RULE_alterTableAdd:usize = 51; 
	pub const RULE_alterTableColumnDefinition:usize = 52; 
	pub const RULE_alterRole:usize = 53; 
	pub const RULE_roleWith:usize = 54; 
	pub const RULE_roleWithOptions:usize = 55; 
	pub const RULE_alterMaterializedView:usize = 56; 
	pub const RULE_dropUser:usize = 57; 
	pub const RULE_dropType:usize = 58; 
	pub const RULE_dropMaterializedView:usize = 59; 
	pub const RULE_dropAggregate:usize = 60; 
	pub const RULE_dropFunction:usize = 61; 
	pub const RULE_dropTrigger:usize = 62; 
	pub const RULE_dropRole:usize = 63; 
	pub const RULE_dropTable:usize = 64; 
	pub const RULE_dropKeyspace:usize = 65; 
	pub const RULE_dropIndex:usize = 66; 
	pub const RULE_createTable:usize = 67; 
	pub const RULE_withElement:usize = 68; 
	pub const RULE_clusteringOrder:usize = 69; 
	pub const RULE_tableOptions:usize = 70; 
	pub const RULE_tableOptionItem:usize = 71; 
	pub const RULE_tableOptionName:usize = 72; 
	pub const RULE_tableOptionValue:usize = 73; 
	pub const RULE_optionHash:usize = 74; 
	pub const RULE_optionHashItem:usize = 75; 
	pub const RULE_optionHashKey:usize = 76; 
	pub const RULE_optionHashValue:usize = 77; 
	pub const RULE_columnDefinitionList:usize = 78; 
	pub const RULE_columnDefinition:usize = 79; 
	pub const RULE_primaryKeyColumn:usize = 80; 
	pub const RULE_primaryKeyElement:usize = 81; 
	pub const RULE_primaryKeyDefinition:usize = 82; 
	pub const RULE_singlePrimaryKey:usize = 83; 
	pub const RULE_compoundKey:usize = 84; 
	pub const RULE_compositeKey:usize = 85; 
	pub const RULE_partitionKeyList:usize = 86; 
	pub const RULE_clusteringKeyList:usize = 87; 
	pub const RULE_partitionKey:usize = 88; 
	pub const RULE_clusteringKey:usize = 89; 
	pub const RULE_applyBatch:usize = 90; 
	pub const RULE_beginBatch:usize = 91; 
	pub const RULE_batchType:usize = 92; 
	pub const RULE_alterKeyspace:usize = 93; 
	pub const RULE_replicationList:usize = 94; 
	pub const RULE_replicationListItem:usize = 95; 
	pub const RULE_durableWrites:usize = 96; 
	pub const RULE_use_:usize = 97; 
	pub const RULE_truncate:usize = 98; 
	pub const RULE_createIndex:usize = 99; 
	pub const RULE_indexName:usize = 100; 
	pub const RULE_indexColumnSpec:usize = 101; 
	pub const RULE_indexKeysSpec:usize = 102; 
	pub const RULE_indexEntriesSSpec:usize = 103; 
	pub const RULE_indexFullSpec:usize = 104; 
	pub const RULE_delete_:usize = 105; 
	pub const RULE_deleteColumnList:usize = 106; 
	pub const RULE_deleteColumnItem:usize = 107; 
	pub const RULE_update:usize = 108; 
	pub const RULE_ifSpec:usize = 109; 
	pub const RULE_ifConditionList:usize = 110; 
	pub const RULE_ifCondition:usize = 111; 
	pub const RULE_assignments:usize = 112; 
	pub const RULE_assignmentElement:usize = 113; 
	pub const RULE_assignmentSet:usize = 114; 
	pub const RULE_assignmentMap:usize = 115; 
	pub const RULE_assignmentList:usize = 116; 
	pub const RULE_assignmentTuple:usize = 117; 
	pub const RULE_insert:usize = 118; 
	pub const RULE_usingTtlTimestamp:usize = 119; 
	pub const RULE_timestamp:usize = 120; 
	pub const RULE_ttl:usize = 121; 
	pub const RULE_usingTimestampSpec:usize = 122; 
	pub const RULE_ifNotExist:usize = 123; 
	pub const RULE_ifExist:usize = 124; 
	pub const RULE_insertValuesSpec:usize = 125; 
	pub const RULE_insertColumnSpec:usize = 126; 
	pub const RULE_columnList:usize = 127; 
	pub const RULE_expressionList:usize = 128; 
	pub const RULE_expression:usize = 129; 
	pub const RULE_select_:usize = 130; 
	pub const RULE_allowFilteringSpec:usize = 131; 
	pub const RULE_limitSpec:usize = 132; 
	pub const RULE_fromSpec:usize = 133; 
	pub const RULE_fromSpecElement:usize = 134; 
	pub const RULE_orderSpec:usize = 135; 
	pub const RULE_orderSpecElement:usize = 136; 
	pub const RULE_whereSpec:usize = 137; 
	pub const RULE_distinctSpec:usize = 138; 
	pub const RULE_selectElements:usize = 139; 
	pub const RULE_selectElement:usize = 140; 
	pub const RULE_relationElements:usize = 141; 
	pub const RULE_relationElement:usize = 142; 
	pub const RULE_relalationContains:usize = 143; 
	pub const RULE_relalationContainsKey:usize = 144; 
	pub const RULE_functionCall:usize = 145; 
	pub const RULE_functionArgs:usize = 146; 
	pub const RULE_constant:usize = 147; 
	pub const RULE_decimalLiteral:usize = 148; 
	pub const RULE_floatLiteral:usize = 149; 
	pub const RULE_stringLiteral:usize = 150; 
	pub const RULE_booleanLiteral:usize = 151; 
	pub const RULE_hexadecimalLiteral:usize = 152; 
	pub const RULE_keyspace:usize = 153; 
	pub const RULE_table:usize = 154; 
	pub const RULE_column:usize = 155; 
	pub const RULE_dataType:usize = 156; 
	pub const RULE_dataTypeName:usize = 157; 
	pub const RULE_dataTypeDefinition:usize = 158; 
	pub const RULE_orderDirection:usize = 159; 
	pub const RULE_role:usize = 160; 
	pub const RULE_trigger:usize = 161; 
	pub const RULE_triggerClass:usize = 162; 
	pub const RULE_materializedView:usize = 163; 
	pub const RULE_type_:usize = 164; 
	pub const RULE_aggregate:usize = 165; 
	pub const RULE_function_:usize = 166; 
	pub const RULE_language:usize = 167; 
	pub const RULE_user:usize = 168; 
	pub const RULE_password:usize = 169; 
	pub const RULE_hashKey:usize = 170; 
	pub const RULE_param:usize = 171; 
	pub const RULE_paramName:usize = 172; 
	pub const RULE_kwAdd:usize = 173; 
	pub const RULE_kwAggregate:usize = 174; 
	pub const RULE_kwAll:usize = 175; 
	pub const RULE_kwAllPermissions:usize = 176; 
	pub const RULE_kwAllow:usize = 177; 
	pub const RULE_kwAlter:usize = 178; 
	pub const RULE_kwAnd:usize = 179; 
	pub const RULE_kwApply:usize = 180; 
	pub const RULE_kwAs:usize = 181; 
	pub const RULE_kwAsc:usize = 182; 
	pub const RULE_kwAuthorize:usize = 183; 
	pub const RULE_kwBatch:usize = 184; 
	pub const RULE_kwBegin:usize = 185; 
	pub const RULE_kwBy:usize = 186; 
	pub const RULE_kwCalled:usize = 187; 
	pub const RULE_kwClustering:usize = 188; 
	pub const RULE_kwCompact:usize = 189; 
	pub const RULE_kwContains:usize = 190; 
	pub const RULE_kwCreate:usize = 191; 
	pub const RULE_kwDelete:usize = 192; 
	pub const RULE_kwDesc:usize = 193; 
	pub const RULE_kwDescibe:usize = 194; 
	pub const RULE_kwDistinct:usize = 195; 
	pub const RULE_kwDrop:usize = 196; 
	pub const RULE_kwDurableWrites:usize = 197; 
	pub const RULE_kwEntries:usize = 198; 
	pub const RULE_kwExecute:usize = 199; 
	pub const RULE_kwExists:usize = 200; 
	pub const RULE_kwFiltering:usize = 201; 
	pub const RULE_kwFinalfunc:usize = 202; 
	pub const RULE_kwFrom:usize = 203; 
	pub const RULE_kwFull:usize = 204; 
	pub const RULE_kwFunction:usize = 205; 
	pub const RULE_kwFunctions:usize = 206; 
	pub const RULE_kwGrant:usize = 207; 
	pub const RULE_kwIf:usize = 208; 
	pub const RULE_kwIn:usize = 209; 
	pub const RULE_kwIndex:usize = 210; 
	pub const RULE_kwInitcond:usize = 211; 
	pub const RULE_kwInput:usize = 212; 
	pub const RULE_kwInsert:usize = 213; 
	pub const RULE_kwInto:usize = 214; 
	pub const RULE_kwIs:usize = 215; 
	pub const RULE_kwJson:usize = 216; 
	pub const RULE_kwKey:usize = 217; 
	pub const RULE_kwKeys:usize = 218; 
	pub const RULE_kwKeyspace:usize = 219; 
	pub const RULE_kwKeyspaces:usize = 220; 
	pub const RULE_kwLanguage:usize = 221; 
	pub const RULE_kwLimit:usize = 222; 
	pub const RULE_kwList:usize = 223; 
	pub const RULE_kwLogged:usize = 224; 
	pub const RULE_kwLogin:usize = 225; 
	pub const RULE_kwMaterialized:usize = 226; 
	pub const RULE_kwModify:usize = 227; 
	pub const RULE_kwNosuperuser:usize = 228; 
	pub const RULE_kwNorecursive:usize = 229; 
	pub const RULE_kwNot:usize = 230; 
	pub const RULE_kwNull:usize = 231; 
	pub const RULE_kwOf:usize = 232; 
	pub const RULE_kwOn:usize = 233; 
	pub const RULE_kwOptions:usize = 234; 
	pub const RULE_kwOr:usize = 235; 
	pub const RULE_kwOrder:usize = 236; 
	pub const RULE_kwPassword:usize = 237; 
	pub const RULE_kwPrimary:usize = 238; 
	pub const RULE_kwRename:usize = 239; 
	pub const RULE_kwReplace:usize = 240; 
	pub const RULE_kwReplication:usize = 241; 
	pub const RULE_kwReturns:usize = 242; 
	pub const RULE_kwRole:usize = 243; 
	pub const RULE_kwRoles:usize = 244; 
	pub const RULE_kwSelect:usize = 245; 
	pub const RULE_kwSet:usize = 246; 
	pub const RULE_kwSfunc:usize = 247; 
	pub const RULE_kwStorage:usize = 248; 
	pub const RULE_kwStype:usize = 249; 
	pub const RULE_kwSuperuser:usize = 250; 
	pub const RULE_kwTable:usize = 251; 
	pub const RULE_kwTimestamp:usize = 252; 
	pub const RULE_kwTo:usize = 253; 
	pub const RULE_kwTrigger:usize = 254; 
	pub const RULE_kwTruncate:usize = 255; 
	pub const RULE_kwTtl:usize = 256; 
	pub const RULE_kwType:usize = 257; 
	pub const RULE_kwUnlogged:usize = 258; 
	pub const RULE_kwUpdate:usize = 259; 
	pub const RULE_kwUse:usize = 260; 
	pub const RULE_kwUser:usize = 261; 
	pub const RULE_kwUsers:usize = 262; 
	pub const RULE_kwUsing:usize = 263; 
	pub const RULE_kwValues:usize = 264; 
	pub const RULE_kwView:usize = 265; 
	pub const RULE_kwWhere:usize = 266; 
	pub const RULE_kwWith:usize = 267; 
	pub const RULE_kwRevoke:usize = 268; 
	pub const RULE_eof:usize = 269; 
	pub const RULE_syntaxBracketLr:usize = 270; 
	pub const RULE_syntaxBracketRr:usize = 271; 
	pub const RULE_syntaxBracketLc:usize = 272; 
	pub const RULE_syntaxBracketRc:usize = 273; 
	pub const RULE_syntaxBracketLa:usize = 274; 
	pub const RULE_syntaxBracketRa:usize = 275; 
	pub const RULE_syntaxBracketLs:usize = 276; 
	pub const RULE_syntaxBracketRs:usize = 277; 
	pub const RULE_syntaxComma:usize = 278; 
	pub const RULE_syntaxColon:usize = 279;
	pub const ruleNames: [&'static str; 280] =  [
		"root", "cqls", "statementSeparator", "empty_", "cql", "revoke", "listUsers", 
		"listRoles", "listPermissions", "grant", "priviledge", "resource", "createUser", 
		"createRole", "createType", "typeMemberColumnList", "createTrigger", "createMaterializedView", 
		"materializedViewWhere", "columnNotNullList", "columnNotNull", "materializedViewOptions", 
		"createKeyspace", "createFunction", "codeBlock", "paramList", "returnMode", 
		"createAggregate", "initCondDefinition", "initCondHash", "initCondHashItem", 
		"initCondListNested", "initCondList", "orReplace", "alterUser", "userPassword", 
		"userSuperUser", "alterType", "alterTypeOperation", "alterTypeRename", 
		"alterTypeRenameList", "alterTypeRenameItem", "alterTypeAdd", "alterTypeAlterType", 
		"alterTable", "alterTableOperation", "alterTableWith", "alterTableRename", 
		"alterTableDropCompactStorage", "alterTableDropColumns", "alterTableDropColumnList", 
		"alterTableAdd", "alterTableColumnDefinition", "alterRole", "roleWith", 
		"roleWithOptions", "alterMaterializedView", "dropUser", "dropType", "dropMaterializedView", 
		"dropAggregate", "dropFunction", "dropTrigger", "dropRole", "dropTable", 
		"dropKeyspace", "dropIndex", "createTable", "withElement", "clusteringOrder", 
		"tableOptions", "tableOptionItem", "tableOptionName", "tableOptionValue", 
		"optionHash", "optionHashItem", "optionHashKey", "optionHashValue", "columnDefinitionList", 
		"columnDefinition", "primaryKeyColumn", "primaryKeyElement", "primaryKeyDefinition", 
		"singlePrimaryKey", "compoundKey", "compositeKey", "partitionKeyList", 
		"clusteringKeyList", "partitionKey", "clusteringKey", "applyBatch", "beginBatch", 
		"batchType", "alterKeyspace", "replicationList", "replicationListItem", 
		"durableWrites", "use_", "truncate", "createIndex", "indexName", "indexColumnSpec", 
		"indexKeysSpec", "indexEntriesSSpec", "indexFullSpec", "delete_", "deleteColumnList", 
		"deleteColumnItem", "update", "ifSpec", "ifConditionList", "ifCondition", 
		"assignments", "assignmentElement", "assignmentSet", "assignmentMap", 
		"assignmentList", "assignmentTuple", "insert", "usingTtlTimestamp", "timestamp", 
		"ttl", "usingTimestampSpec", "ifNotExist", "ifExist", "insertValuesSpec", 
		"insertColumnSpec", "columnList", "expressionList", "expression", "select_", 
		"allowFilteringSpec", "limitSpec", "fromSpec", "fromSpecElement", "orderSpec", 
		"orderSpecElement", "whereSpec", "distinctSpec", "selectElements", "selectElement", 
		"relationElements", "relationElement", "relalationContains", "relalationContainsKey", 
		"functionCall", "functionArgs", "constant", "decimalLiteral", "floatLiteral", 
		"stringLiteral", "booleanLiteral", "hexadecimalLiteral", "keyspace", "table", 
		"column", "dataType", "dataTypeName", "dataTypeDefinition", "orderDirection", 
		"role", "trigger", "triggerClass", "materializedView", "type_", "aggregate", 
		"function_", "language", "user", "password", "hashKey", "param", "paramName", 
		"kwAdd", "kwAggregate", "kwAll", "kwAllPermissions", "kwAllow", "kwAlter", 
		"kwAnd", "kwApply", "kwAs", "kwAsc", "kwAuthorize", "kwBatch", "kwBegin", 
		"kwBy", "kwCalled", "kwClustering", "kwCompact", "kwContains", "kwCreate", 
		"kwDelete", "kwDesc", "kwDescibe", "kwDistinct", "kwDrop", "kwDurableWrites", 
		"kwEntries", "kwExecute", "kwExists", "kwFiltering", "kwFinalfunc", "kwFrom", 
		"kwFull", "kwFunction", "kwFunctions", "kwGrant", "kwIf", "kwIn", "kwIndex", 
		"kwInitcond", "kwInput", "kwInsert", "kwInto", "kwIs", "kwJson", "kwKey", 
		"kwKeys", "kwKeyspace", "kwKeyspaces", "kwLanguage", "kwLimit", "kwList", 
		"kwLogged", "kwLogin", "kwMaterialized", "kwModify", "kwNosuperuser", 
		"kwNorecursive", "kwNot", "kwNull", "kwOf", "kwOn", "kwOptions", "kwOr", 
		"kwOrder", "kwPassword", "kwPrimary", "kwRename", "kwReplace", "kwReplication", 
		"kwReturns", "kwRole", "kwRoles", "kwSelect", "kwSet", "kwSfunc", "kwStorage", 
		"kwStype", "kwSuperuser", "kwTable", "kwTimestamp", "kwTo", "kwTrigger", 
		"kwTruncate", "kwTtl", "kwType", "kwUnlogged", "kwUpdate", "kwUse", "kwUser", 
		"kwUsers", "kwUsing", "kwValues", "kwView", "kwWhere", "kwWith", "kwRevoke", 
		"eof", "syntaxBracketLr", "syntaxBracketRr", "syntaxBracketLc", "syntaxBracketRc", 
		"syntaxBracketLa", "syntaxBracketRa", "syntaxBracketLs", "syntaxBracketRs", 
		"syntaxComma", "syntaxColon"
	];


	pub const _LITERAL_NAMES: [Option<&'static str>;23] = [
		None, Some("'('"), Some("')'"), Some("'{'"), Some("'}'"), Some("'['"), 
		Some("']'"), Some("','"), Some("';'"), Some("':'"), None, None, None, 
		None, Some("'.'"), Some("'*'"), Some("'/'"), Some("'%'"), Some("'+'"), 
		Some("'--'"), Some("'-'"), Some("'\"'"), Some("'''")
	];
	pub const _SYMBOLIC_NAMES: [Option<&'static str>;177]  = [
		None, Some("LR_BRACKET"), Some("RR_BRACKET"), Some("LC_BRACKET"), Some("RC_BRACKET"), 
		Some("LS_BRACKET"), Some("RS_BRACKET"), Some("COMMA"), Some("SEMI"), Some("COLON"), 
		Some("SPACE"), Some("SPEC_MYSQL_COMMENT"), Some("COMMENT_INPUT"), Some("LINE_COMMENT"), 
		Some("DOT"), Some("STAR"), Some("DIVIDE"), Some("MODULE"), Some("PLUS"), 
		Some("MINUSMINUS"), Some("MINUS"), Some("DQUOTE"), Some("SQUOTE"), Some("K_ADD"), 
		Some("K_AGGREGATE"), Some("K_ALL"), Some("K_ALLOW"), Some("K_ALTER"), 
		Some("K_AND"), Some("K_ANY"), Some("K_APPLY"), Some("K_AS"), Some("K_ASC"), 
		Some("K_AUTHORIZE"), Some("K_BATCH"), Some("K_BEGIN"), Some("K_BY"), Some("K_CALLED"), 
		Some("K_CLUSTERING"), Some("K_COLUMNFAMILY"), Some("K_COMPACT"), Some("K_CONSISTENCY"), 
		Some("K_CONTAINS"), Some("K_CREATE"), Some("K_CUSTOM"), Some("K_DELETE"), 
		Some("K_DESC"), Some("K_DESCRIBE"), Some("K_DISTINCT"), Some("K_DROP"), 
		Some("K_DURABLE_WRITES"), Some("K_EACH_QUORUM"), Some("K_ENTRIES"), Some("K_EXECUTE"), 
		Some("K_EXISTS"), Some("K_FALSE"), Some("K_FILTERING"), Some("K_FINALFUNC"), 
		Some("K_FROM"), Some("K_FULL"), Some("K_FUNCTION"), Some("K_FUNCTIONS"), 
		Some("K_GRANT"), Some("K_IF"), Some("K_IN"), Some("K_INDEX"), Some("K_INFINITY"), 
		Some("K_INITCOND"), Some("K_INPUT"), Some("K_INSERT"), Some("K_INTO"), 
		Some("K_IS"), Some("K_JSON"), Some("K_KEY"), Some("K_KEYS"), Some("K_KEYSPACE"), 
		Some("K_KEYSPACES"), Some("K_LANGUAGE"), Some("K_LEVEL"), Some("K_LIMIT"), 
		Some("K_LOCAL_ONE"), Some("K_LOCAL_QUORUM"), Some("K_LOGGED"), Some("K_LOGIN"), 
		Some("K_MATERIALIZED"), Some("K_MODIFY"), Some("K_NAN"), Some("K_NORECURSIVE"), 
		Some("K_NOSUPERUSER"), Some("K_NOT"), Some("K_NULL"), Some("K_OF"), Some("K_ON"), 
		Some("K_ONE"), Some("K_OPTIONS"), Some("K_OR"), Some("K_ORDER"), Some("K_PARTITION"), 
		Some("K_PASSWORD"), Some("K_PER"), Some("K_PERMISSION"), Some("K_PERMISSIONS"), 
		Some("K_PRIMARY"), Some("K_QUORUM"), Some("K_RENAME"), Some("K_REPLACE"), 
		Some("K_REPLICATION"), Some("K_RETURNS"), Some("K_REVOKE"), Some("K_ROLE"), 
		Some("K_ROLES"), Some("K_SCHEMA"), Some("K_SELECT"), Some("K_SET"), Some("K_SFUNC"), 
		Some("K_STATIC"), Some("K_STORAGE"), Some("K_STYPE"), Some("K_SUPERUSER"), 
		Some("K_TABLE"), Some("K_THREE"), Some("K_TIMESTAMP"), Some("K_TO"), Some("K_TOKEN"), 
		Some("K_TRIGGER"), Some("K_TRUE"), Some("K_TRUNCATE"), Some("K_TTL"), 
		Some("K_TWO"), Some("K_TYPE"), Some("K_UNLOGGED"), Some("K_UPDATE"), Some("K_USE"), 
		Some("K_USER"), Some("K_USING"), Some("K_UUID"), Some("K_VALUES"), Some("K_VIEW"), 
		Some("K_WHERE"), Some("K_WITH"), Some("K_WRITETIME"), Some("K_ASCII"), 
		Some("K_BIGINT"), Some("K_BLOB"), Some("K_BOOLEAN"), Some("K_COUNTER"), 
		Some("K_DATE"), Some("K_DECIMAL"), Some("K_DOUBLE"), Some("K_FLOAT"), 
		Some("K_FROZEN"), Some("K_INET"), Some("K_INT"), Some("K_LIST"), Some("K_MAP"), 
		Some("K_SMALLINT"), Some("K_TEXT"), Some("K_TIMEUUID"), Some("K_TIME"), 
		Some("K_TINYINT"), Some("K_TUPLE"), Some("K_VARCHAR"), Some("K_VARINT"), 
		Some("CODE_BLOCK"), Some("STRING_LITERAL"), Some("DECIMAL_LITERAL"), Some("FLOAT_LITERAL"), 
		Some("HEXADECIMAL_LITERAL"), Some("REAL_LITERAL"), Some("OBJECT_NAME"), 
		Some("UUID"), Some("OPERATOR_EQ"), Some("OPERATOR_LT"), Some("OPERATOR_GT"), 
		Some("OPERATOR_LTE"), Some("OPERATOR_GTE"), Some("K_USERS")
	];
	lazy_static!{
	    static ref _shared_context_cache: Arc<PredictionContextCache> = Arc::new(PredictionContextCache::new());
		static ref VOCABULARY: Box<dyn Vocabulary> = Box::new(VocabularyImpl::new(_LITERAL_NAMES.iter(), _SYMBOLIC_NAMES.iter(), None));
	}


type BaseParserType<'input, I> =
	BaseParser<'input,CqlParserExt, I, CqlParserContextType , dyn CqlParserListener<'input> + 'input >;

type TokenType<'input> = <LocalTokenFactory<'input> as TokenFactory<'input>>::Tok;
pub type LocalTokenFactory<'input> = CommonTokenFactory;

pub type CqlParserTreeWalker<'input,'a> =
	ParseTreeWalker<'input, 'a, CqlParserContextType , dyn CqlParserListener<'input> + 'a>;

/// Parser for CqlParser grammar
pub struct CqlParser<'input,I,H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	base:BaseParserType<'input,I>,
	interpreter:Arc<ParserATNSimulator>,
	_shared_context_cache: Box<PredictionContextCache>,
    pub err_handler: H,
}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn get_serialized_atn() -> &'static str { _serializedATN }

    pub fn set_error_strategy(&mut self, strategy: H) {
        self.err_handler = strategy
    }

    pub fn with_strategy(input: I, strategy: H) -> Self {
		antlr_rust::recognizer::check_version("0","2");
		let interpreter = Arc::new(ParserATNSimulator::new(
			_ATN.clone(),
			_decision_to_DFA.clone(),
			_shared_context_cache.clone(),
		));
		Self {
			base: BaseParser::new_base_parser(
				input,
				Arc::clone(&interpreter),
				CqlParserExt{
				}
			),
			interpreter,
            _shared_context_cache: Box::new(PredictionContextCache::new()),
            err_handler: strategy,
        }
    }

}

type DynStrategy<'input,I> = Box<dyn ErrorStrategy<'input,BaseParserType<'input,I>> + 'input>;

impl<'input, I> CqlParser<'input, I, DynStrategy<'input,I>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
{
    pub fn with_dyn_strategy(input: I) -> Self{
    	Self::with_strategy(input,Box::new(DefaultErrorStrategy::new()))
    }
}

impl<'input, I> CqlParser<'input, I, DefaultErrorStrategy<'input,CqlParserContextType>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
{
    pub fn new(input: I) -> Self{
    	Self::with_strategy(input,DefaultErrorStrategy::new())
    }
}

/// Trait for monomorphized trait object that corresponds to the nodes of parse tree generated for CqlParser
pub trait CqlParserContext<'input>:
	for<'x> Listenable<dyn CqlParserListener<'input> + 'x > + 
	for<'x> Visitable<dyn CqlParserVisitor<'input> + 'x > + 
	ParserRuleContext<'input, TF=LocalTokenFactory<'input>, Ctx=CqlParserContextType>
{}

impl<'input, 'x, T> VisitableDyn<T> for dyn CqlParserContext<'input> + 'input
where
    T: CqlParserVisitor<'input> + 'x,
{
    fn accept_dyn(&self, visitor: &mut T) {
        self.accept(visitor as &mut (dyn CqlParserVisitor<'input> + 'x))
    }
}

impl<'input> CqlParserContext<'input> for TerminalNode<'input,CqlParserContextType> {}
impl<'input> CqlParserContext<'input> for ErrorNode<'input,CqlParserContextType> {}

#[antlr_rust::impl_tid]
impl<'input> antlr_rust::TidAble<'input> for dyn CqlParserContext<'input> + 'input{}

#[antlr_rust::impl_tid]
impl<'input> antlr_rust::TidAble<'input> for dyn CqlParserListener<'input> + 'input{}

pub struct CqlParserContextType;
antlr_rust::type_id!{CqlParserContextType}

impl<'input> ParserNodeType<'input> for CqlParserContextType{
	type TF = LocalTokenFactory<'input>;
	type Type = dyn CqlParserContext<'input> + 'input;
}

impl<'input, I, H> Deref for CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
    type Target = BaseParserType<'input,I>;

    fn deref(&self) -> &Self::Target {
        &self.base
    }
}

impl<'input, I, H> DerefMut for CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.base
    }
}

pub struct CqlParserExt{
}

impl CqlParserExt{
}


impl<'input> TokenAware<'input> for CqlParserExt{
	type TF = LocalTokenFactory<'input>;
}

impl<'input,I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>> ParserRecog<'input, BaseParserType<'input,I>> for CqlParserExt{}

impl<'input,I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>> Actions<'input, BaseParserType<'input,I>> for CqlParserExt{
	fn get_grammar_file_name(&self) -> & str{ "CqlParser.g4"}

   	fn get_rule_names(&self) -> &[& str] {&ruleNames}

   	fn get_vocabulary(&self) -> &dyn Vocabulary { &**VOCABULARY }
}
//------------------- root ----------------
pub type RootContextAll<'input> = RootContext<'input>;


pub type RootContext<'input> = BaseParserRuleContext<'input,RootContextExt<'input>>;

#[derive(Clone)]
pub struct RootContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for RootContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for RootContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_root(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_root(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for RootContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_root(self);
	}
}

impl<'input> CustomRuleContext<'input> for RootContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_root }
	//fn type_rule_index() -> usize where Self: Sized { RULE_root }
}
antlr_rust::type_id!{RootContextExt<'a>}

impl<'input> RootContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RootContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RootContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RootContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<RootContextExt<'input>>{

fn eof(&self) -> Option<Rc<EofContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn cqls(&self) -> Option<Rc<CqlsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token MINUSMINUS
/// Returns `None` if there is no child corresponding to token MINUSMINUS
fn MINUSMINUS(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(MINUSMINUS, 0)
}

}

impl<'input> RootContextAttrs<'input> for RootContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn root(&mut self,)
	-> Result<Rc<RootContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RootContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 0, RULE_root);
        let mut _localctx: Rc<RootContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(561);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if ((((_la - 8)) & !0x3f) == 0 && ((1usize << (_la - 8)) & ((1usize << (SEMI - 8)) | (1usize << (K_ALTER - 8)) | (1usize << (K_APPLY - 8)) | (1usize << (K_BEGIN - 8)) | (1usize << (K_CREATE - 8)) | (1usize << (K_DELETE - 8)) | (1usize << (K_DROP - 8)) | (1usize << (K_GRANT - 8)) | (1usize << (K_INSERT - 8)))) != 0) || ((((_la - 108)) & !0x3f) == 0 && ((1usize << (_la - 108)) & ((1usize << (K_REVOKE - 108)) | (1usize << (K_SELECT - 108)) | (1usize << (K_TRUNCATE - 108)) | (1usize << (K_UPDATE - 108)) | (1usize << (K_USE - 108)) | (1usize << (K_LIST - 108)))) != 0) {
				{
				/*InvokeRule cqls*/
				recog.base.set_state(560);
				recog.cqls()?;

				}
			}

			recog.base.set_state(564);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==MINUSMINUS {
				{
				recog.base.set_state(563);
				recog.base.match_token(MINUSMINUS,&mut recog.err_handler)?;

				}
			}

			/*InvokeRule eof*/
			recog.base.set_state(566);
			recog.eof()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- cqls ----------------
pub type CqlsContextAll<'input> = CqlsContext<'input>;


pub type CqlsContext<'input> = BaseParserRuleContext<'input,CqlsContextExt<'input>>;

#[derive(Clone)]
pub struct CqlsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for CqlsContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for CqlsContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_cqls(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_cqls(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for CqlsContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_cqls(self);
	}
}

impl<'input> CustomRuleContext<'input> for CqlsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_cqls }
	//fn type_rule_index() -> usize where Self: Sized { RULE_cqls }
}
antlr_rust::type_id!{CqlsContextExt<'a>}

impl<'input> CqlsContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CqlsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CqlsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CqlsContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<CqlsContextExt<'input>>{

fn cql_all(&self) ->  Vec<Rc<CqlContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn cql(&self, i: usize) -> Option<Rc<CqlContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn empty__all(&self) ->  Vec<Rc<Empty_ContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn empty_(&self, i: usize) -> Option<Rc<Empty_ContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn statementSeparator_all(&self) ->  Vec<Rc<StatementSeparatorContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn statementSeparator(&self, i: usize) -> Option<Rc<StatementSeparatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token MINUSMINUS in current rule
fn MINUSMINUS_all(&self) -> Vec<Rc<TerminalNode<'input,CqlParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token MINUSMINUS, starting from 0.
/// Returns `None` if number of children corresponding to token MINUSMINUS is less or equal than `i`.
fn MINUSMINUS(&self, i: usize) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(MINUSMINUS, i)
}

}

impl<'input> CqlsContextAttrs<'input> for CqlsContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn cqls(&mut self,)
	-> Result<Rc<CqlsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CqlsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 2, RULE_cqls);
        let mut _localctx: Rc<CqlsContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(577);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(4,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					recog.base.set_state(575);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 K_ALTER | K_APPLY | K_BEGIN | K_CREATE | K_DELETE | K_DROP | K_GRANT |
					 K_INSERT | K_REVOKE | K_SELECT | K_TRUNCATE | K_UPDATE | K_USE | K_LIST 
						=> {
							{
							/*InvokeRule cql*/
							recog.base.set_state(568);
							recog.cql()?;

							recog.base.set_state(570);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==MINUSMINUS {
								{
								recog.base.set_state(569);
								recog.base.match_token(MINUSMINUS,&mut recog.err_handler)?;

								}
							}

							/*InvokeRule statementSeparator*/
							recog.base.set_state(572);
							recog.statementSeparator()?;

							}
						}

					 SEMI 
						=> {
							{
							/*InvokeRule empty_*/
							recog.base.set_state(574);
							recog.empty_()?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					} 
				}
				recog.base.set_state(579);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(4,&mut recog.base)?;
			}
			recog.base.set_state(588);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 K_ALTER | K_APPLY | K_BEGIN | K_CREATE | K_DELETE | K_DROP | K_GRANT |
			 K_INSERT | K_REVOKE | K_SELECT | K_TRUNCATE | K_UPDATE | K_USE | K_LIST 
				=> {
					{
					/*InvokeRule cql*/
					recog.base.set_state(580);
					recog.cql()?;

					recog.base.set_state(585);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(6,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(582);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==MINUSMINUS {
								{
								recog.base.set_state(581);
								recog.base.match_token(MINUSMINUS,&mut recog.err_handler)?;

								}
							}

							/*InvokeRule statementSeparator*/
							recog.base.set_state(584);
							recog.statementSeparator()?;

							}
						}

						_ => {}
					}
					}
				}

			 SEMI 
				=> {
					{
					/*InvokeRule empty_*/
					recog.base.set_state(587);
					recog.empty_()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- statementSeparator ----------------
pub type StatementSeparatorContextAll<'input> = StatementSeparatorContext<'input>;


pub type StatementSeparatorContext<'input> = BaseParserRuleContext<'input,StatementSeparatorContextExt<'input>>;

#[derive(Clone)]
pub struct StatementSeparatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for StatementSeparatorContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for StatementSeparatorContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_statementSeparator(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_statementSeparator(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for StatementSeparatorContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_statementSeparator(self);
	}
}

impl<'input> CustomRuleContext<'input> for StatementSeparatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statementSeparator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statementSeparator }
}
antlr_rust::type_id!{StatementSeparatorContextExt<'a>}

impl<'input> StatementSeparatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StatementSeparatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StatementSeparatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StatementSeparatorContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<StatementSeparatorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}

}

impl<'input> StatementSeparatorContextAttrs<'input> for StatementSeparatorContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn statementSeparator(&mut self,)
	-> Result<Rc<StatementSeparatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StatementSeparatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 4, RULE_statementSeparator);
        let mut _localctx: Rc<StatementSeparatorContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(590);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- empty_ ----------------
pub type Empty_ContextAll<'input> = Empty_Context<'input>;


pub type Empty_Context<'input> = BaseParserRuleContext<'input,Empty_ContextExt<'input>>;

#[derive(Clone)]
pub struct Empty_ContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for Empty_Context<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for Empty_Context<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_empty_(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_empty_(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for Empty_Context<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_empty_(self);
	}
}

impl<'input> CustomRuleContext<'input> for Empty_ContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_empty_ }
	//fn type_rule_index() -> usize where Self: Sized { RULE_empty_ }
}
antlr_rust::type_id!{Empty_ContextExt<'a>}

impl<'input> Empty_ContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Empty_ContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Empty_ContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Empty_ContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<Empty_ContextExt<'input>>{

fn statementSeparator(&self) -> Option<Rc<StatementSeparatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> Empty_ContextAttrs<'input> for Empty_Context<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn empty_(&mut self,)
	-> Result<Rc<Empty_ContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Empty_ContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 6, RULE_empty_);
        let mut _localctx: Rc<Empty_ContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule statementSeparator*/
			recog.base.set_state(592);
			recog.statementSeparator()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- cql ----------------
pub type CqlContextAll<'input> = CqlContext<'input>;


pub type CqlContext<'input> = BaseParserRuleContext<'input,CqlContextExt<'input>>;

#[derive(Clone)]
pub struct CqlContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for CqlContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for CqlContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_cql(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_cql(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for CqlContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_cql(self);
	}
}

impl<'input> CustomRuleContext<'input> for CqlContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_cql }
	//fn type_rule_index() -> usize where Self: Sized { RULE_cql }
}
antlr_rust::type_id!{CqlContextExt<'a>}

impl<'input> CqlContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CqlContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CqlContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CqlContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<CqlContextExt<'input>>{

fn alterKeyspace(&self) -> Option<Rc<AlterKeyspaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn alterMaterializedView(&self) -> Option<Rc<AlterMaterializedViewContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn alterRole(&self) -> Option<Rc<AlterRoleContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn alterTable(&self) -> Option<Rc<AlterTableContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn alterType(&self) -> Option<Rc<AlterTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn alterUser(&self) -> Option<Rc<AlterUserContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn applyBatch(&self) -> Option<Rc<ApplyBatchContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn createAggregate(&self) -> Option<Rc<CreateAggregateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn createFunction(&self) -> Option<Rc<CreateFunctionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn createIndex(&self) -> Option<Rc<CreateIndexContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn createKeyspace(&self) -> Option<Rc<CreateKeyspaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn createMaterializedView(&self) -> Option<Rc<CreateMaterializedViewContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn createRole(&self) -> Option<Rc<CreateRoleContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn createTable(&self) -> Option<Rc<CreateTableContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn createTrigger(&self) -> Option<Rc<CreateTriggerContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn createType(&self) -> Option<Rc<CreateTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn createUser(&self) -> Option<Rc<CreateUserContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn delete_(&self) -> Option<Rc<Delete_ContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn dropAggregate(&self) -> Option<Rc<DropAggregateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn dropFunction(&self) -> Option<Rc<DropFunctionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn dropIndex(&self) -> Option<Rc<DropIndexContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn dropKeyspace(&self) -> Option<Rc<DropKeyspaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn dropMaterializedView(&self) -> Option<Rc<DropMaterializedViewContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn dropRole(&self) -> Option<Rc<DropRoleContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn dropTable(&self) -> Option<Rc<DropTableContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn dropTrigger(&self) -> Option<Rc<DropTriggerContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn dropType(&self) -> Option<Rc<DropTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn dropUser(&self) -> Option<Rc<DropUserContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn grant(&self) -> Option<Rc<GrantContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn insert(&self) -> Option<Rc<InsertContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn listPermissions(&self) -> Option<Rc<ListPermissionsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn listRoles(&self) -> Option<Rc<ListRolesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn revoke(&self) -> Option<Rc<RevokeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn select_(&self) -> Option<Rc<Select_ContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn truncate(&self) -> Option<Rc<TruncateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn update(&self) -> Option<Rc<UpdateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn use_(&self) -> Option<Rc<Use_ContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CqlContextAttrs<'input> for CqlContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn cql(&mut self,)
	-> Result<Rc<CqlContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CqlContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 8, RULE_cql);
        let mut _localctx: Rc<CqlContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(631);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(8,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule alterKeyspace*/
					recog.base.set_state(594);
					recog.alterKeyspace()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule alterMaterializedView*/
					recog.base.set_state(595);
					recog.alterMaterializedView()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule alterRole*/
					recog.base.set_state(596);
					recog.alterRole()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule alterTable*/
					recog.base.set_state(597);
					recog.alterTable()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule alterType*/
					recog.base.set_state(598);
					recog.alterType()?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule alterUser*/
					recog.base.set_state(599);
					recog.alterUser()?;

					}
				}
			,
				7 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					/*InvokeRule applyBatch*/
					recog.base.set_state(600);
					recog.applyBatch()?;

					}
				}
			,
				8 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					/*InvokeRule createAggregate*/
					recog.base.set_state(601);
					recog.createAggregate()?;

					}
				}
			,
				9 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 9);
					recog.base.enter_outer_alt(None, 9);
					{
					/*InvokeRule createFunction*/
					recog.base.set_state(602);
					recog.createFunction()?;

					}
				}
			,
				10 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 10);
					recog.base.enter_outer_alt(None, 10);
					{
					/*InvokeRule createIndex*/
					recog.base.set_state(603);
					recog.createIndex()?;

					}
				}
			,
				11 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 11);
					recog.base.enter_outer_alt(None, 11);
					{
					/*InvokeRule createKeyspace*/
					recog.base.set_state(604);
					recog.createKeyspace()?;

					}
				}
			,
				12 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 12);
					recog.base.enter_outer_alt(None, 12);
					{
					/*InvokeRule createMaterializedView*/
					recog.base.set_state(605);
					recog.createMaterializedView()?;

					}
				}
			,
				13 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 13);
					recog.base.enter_outer_alt(None, 13);
					{
					/*InvokeRule createRole*/
					recog.base.set_state(606);
					recog.createRole()?;

					}
				}
			,
				14 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 14);
					recog.base.enter_outer_alt(None, 14);
					{
					/*InvokeRule createTable*/
					recog.base.set_state(607);
					recog.createTable()?;

					}
				}
			,
				15 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 15);
					recog.base.enter_outer_alt(None, 15);
					{
					/*InvokeRule createTrigger*/
					recog.base.set_state(608);
					recog.createTrigger()?;

					}
				}
			,
				16 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 16);
					recog.base.enter_outer_alt(None, 16);
					{
					/*InvokeRule createType*/
					recog.base.set_state(609);
					recog.createType()?;

					}
				}
			,
				17 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 17);
					recog.base.enter_outer_alt(None, 17);
					{
					/*InvokeRule createUser*/
					recog.base.set_state(610);
					recog.createUser()?;

					}
				}
			,
				18 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 18);
					recog.base.enter_outer_alt(None, 18);
					{
					/*InvokeRule delete_*/
					recog.base.set_state(611);
					recog.delete_()?;

					}
				}
			,
				19 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 19);
					recog.base.enter_outer_alt(None, 19);
					{
					/*InvokeRule dropAggregate*/
					recog.base.set_state(612);
					recog.dropAggregate()?;

					}
				}
			,
				20 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 20);
					recog.base.enter_outer_alt(None, 20);
					{
					/*InvokeRule dropFunction*/
					recog.base.set_state(613);
					recog.dropFunction()?;

					}
				}
			,
				21 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 21);
					recog.base.enter_outer_alt(None, 21);
					{
					/*InvokeRule dropIndex*/
					recog.base.set_state(614);
					recog.dropIndex()?;

					}
				}
			,
				22 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 22);
					recog.base.enter_outer_alt(None, 22);
					{
					/*InvokeRule dropKeyspace*/
					recog.base.set_state(615);
					recog.dropKeyspace()?;

					}
				}
			,
				23 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 23);
					recog.base.enter_outer_alt(None, 23);
					{
					/*InvokeRule dropMaterializedView*/
					recog.base.set_state(616);
					recog.dropMaterializedView()?;

					}
				}
			,
				24 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 24);
					recog.base.enter_outer_alt(None, 24);
					{
					/*InvokeRule dropRole*/
					recog.base.set_state(617);
					recog.dropRole()?;

					}
				}
			,
				25 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 25);
					recog.base.enter_outer_alt(None, 25);
					{
					/*InvokeRule dropTable*/
					recog.base.set_state(618);
					recog.dropTable()?;

					}
				}
			,
				26 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 26);
					recog.base.enter_outer_alt(None, 26);
					{
					/*InvokeRule dropTrigger*/
					recog.base.set_state(619);
					recog.dropTrigger()?;

					}
				}
			,
				27 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 27);
					recog.base.enter_outer_alt(None, 27);
					{
					/*InvokeRule dropType*/
					recog.base.set_state(620);
					recog.dropType()?;

					}
				}
			,
				28 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 28);
					recog.base.enter_outer_alt(None, 28);
					{
					/*InvokeRule dropUser*/
					recog.base.set_state(621);
					recog.dropUser()?;

					}
				}
			,
				29 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 29);
					recog.base.enter_outer_alt(None, 29);
					{
					/*InvokeRule grant*/
					recog.base.set_state(622);
					recog.grant()?;

					}
				}
			,
				30 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 30);
					recog.base.enter_outer_alt(None, 30);
					{
					/*InvokeRule insert*/
					recog.base.set_state(623);
					recog.insert()?;

					}
				}
			,
				31 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 31);
					recog.base.enter_outer_alt(None, 31);
					{
					/*InvokeRule listPermissions*/
					recog.base.set_state(624);
					recog.listPermissions()?;

					}
				}
			,
				32 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 32);
					recog.base.enter_outer_alt(None, 32);
					{
					/*InvokeRule listRoles*/
					recog.base.set_state(625);
					recog.listRoles()?;

					}
				}
			,
				33 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 33);
					recog.base.enter_outer_alt(None, 33);
					{
					/*InvokeRule revoke*/
					recog.base.set_state(626);
					recog.revoke()?;

					}
				}
			,
				34 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 34);
					recog.base.enter_outer_alt(None, 34);
					{
					/*InvokeRule select_*/
					recog.base.set_state(627);
					recog.select_()?;

					}
				}
			,
				35 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 35);
					recog.base.enter_outer_alt(None, 35);
					{
					/*InvokeRule truncate*/
					recog.base.set_state(628);
					recog.truncate()?;

					}
				}
			,
				36 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 36);
					recog.base.enter_outer_alt(None, 36);
					{
					/*InvokeRule update*/
					recog.base.set_state(629);
					recog.update()?;

					}
				}
			,
				37 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 37);
					recog.base.enter_outer_alt(None, 37);
					{
					/*InvokeRule use_*/
					recog.base.set_state(630);
					recog.use_()?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- revoke ----------------
pub type RevokeContextAll<'input> = RevokeContext<'input>;


pub type RevokeContext<'input> = BaseParserRuleContext<'input,RevokeContextExt<'input>>;

#[derive(Clone)]
pub struct RevokeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for RevokeContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for RevokeContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_revoke(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_revoke(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for RevokeContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_revoke(self);
	}
}

impl<'input> CustomRuleContext<'input> for RevokeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_revoke }
	//fn type_rule_index() -> usize where Self: Sized { RULE_revoke }
}
antlr_rust::type_id!{RevokeContextExt<'a>}

impl<'input> RevokeContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RevokeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RevokeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RevokeContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<RevokeContextExt<'input>>{

fn kwRevoke(&self) -> Option<Rc<KwRevokeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn priviledge(&self) -> Option<Rc<PriviledgeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwOn(&self) -> Option<Rc<KwOnContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn resource(&self) -> Option<Rc<ResourceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwFrom(&self) -> Option<Rc<KwFromContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn role(&self) -> Option<Rc<RoleContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RevokeContextAttrs<'input> for RevokeContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn revoke(&mut self,)
	-> Result<Rc<RevokeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RevokeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 10, RULE_revoke);
        let mut _localctx: Rc<RevokeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwRevoke*/
			recog.base.set_state(633);
			recog.kwRevoke()?;

			/*InvokeRule priviledge*/
			recog.base.set_state(634);
			recog.priviledge()?;

			/*InvokeRule kwOn*/
			recog.base.set_state(635);
			recog.kwOn()?;

			/*InvokeRule resource*/
			recog.base.set_state(636);
			recog.resource()?;

			/*InvokeRule kwFrom*/
			recog.base.set_state(637);
			recog.kwFrom()?;

			/*InvokeRule role*/
			recog.base.set_state(638);
			recog.role()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- listUsers ----------------
pub type ListUsersContextAll<'input> = ListUsersContext<'input>;


pub type ListUsersContext<'input> = BaseParserRuleContext<'input,ListUsersContextExt<'input>>;

#[derive(Clone)]
pub struct ListUsersContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for ListUsersContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for ListUsersContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_listUsers(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_listUsers(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for ListUsersContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_listUsers(self);
	}
}

impl<'input> CustomRuleContext<'input> for ListUsersContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_listUsers }
	//fn type_rule_index() -> usize where Self: Sized { RULE_listUsers }
}
antlr_rust::type_id!{ListUsersContextExt<'a>}

impl<'input> ListUsersContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ListUsersContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ListUsersContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ListUsersContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<ListUsersContextExt<'input>>{

fn kwList(&self) -> Option<Rc<KwListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwUsers(&self) -> Option<Rc<KwUsersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ListUsersContextAttrs<'input> for ListUsersContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn listUsers(&mut self,)
	-> Result<Rc<ListUsersContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ListUsersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 12, RULE_listUsers);
        let mut _localctx: Rc<ListUsersContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwList*/
			recog.base.set_state(640);
			recog.kwList()?;

			/*InvokeRule kwUsers*/
			recog.base.set_state(641);
			recog.kwUsers()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- listRoles ----------------
pub type ListRolesContextAll<'input> = ListRolesContext<'input>;


pub type ListRolesContext<'input> = BaseParserRuleContext<'input,ListRolesContextExt<'input>>;

#[derive(Clone)]
pub struct ListRolesContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for ListRolesContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for ListRolesContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_listRoles(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_listRoles(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for ListRolesContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_listRoles(self);
	}
}

impl<'input> CustomRuleContext<'input> for ListRolesContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_listRoles }
	//fn type_rule_index() -> usize where Self: Sized { RULE_listRoles }
}
antlr_rust::type_id!{ListRolesContextExt<'a>}

impl<'input> ListRolesContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ListRolesContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ListRolesContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ListRolesContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<ListRolesContextExt<'input>>{

fn kwList(&self) -> Option<Rc<KwListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwRoles(&self) -> Option<Rc<KwRolesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwOf(&self) -> Option<Rc<KwOfContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn role(&self) -> Option<Rc<RoleContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwNorecursive(&self) -> Option<Rc<KwNorecursiveContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ListRolesContextAttrs<'input> for ListRolesContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn listRoles(&mut self,)
	-> Result<Rc<ListRolesContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ListRolesContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 14, RULE_listRoles);
        let mut _localctx: Rc<ListRolesContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwList*/
			recog.base.set_state(643);
			recog.kwList()?;

			/*InvokeRule kwRoles*/
			recog.base.set_state(644);
			recog.kwRoles()?;

			recog.base.set_state(648);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_OF {
				{
				/*InvokeRule kwOf*/
				recog.base.set_state(645);
				recog.kwOf()?;

				/*InvokeRule role*/
				recog.base.set_state(646);
				recog.role()?;

				}
			}

			recog.base.set_state(651);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_NORECURSIVE {
				{
				/*InvokeRule kwNorecursive*/
				recog.base.set_state(650);
				recog.kwNorecursive()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- listPermissions ----------------
pub type ListPermissionsContextAll<'input> = ListPermissionsContext<'input>;


pub type ListPermissionsContext<'input> = BaseParserRuleContext<'input,ListPermissionsContextExt<'input>>;

#[derive(Clone)]
pub struct ListPermissionsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for ListPermissionsContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for ListPermissionsContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_listPermissions(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_listPermissions(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for ListPermissionsContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_listPermissions(self);
	}
}

impl<'input> CustomRuleContext<'input> for ListPermissionsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_listPermissions }
	//fn type_rule_index() -> usize where Self: Sized { RULE_listPermissions }
}
antlr_rust::type_id!{ListPermissionsContextExt<'a>}

impl<'input> ListPermissionsContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ListPermissionsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ListPermissionsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ListPermissionsContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<ListPermissionsContextExt<'input>>{

fn kwList(&self) -> Option<Rc<KwListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn priviledge(&self) -> Option<Rc<PriviledgeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwOn(&self) -> Option<Rc<KwOnContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn resource(&self) -> Option<Rc<ResourceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwOf(&self) -> Option<Rc<KwOfContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn role(&self) -> Option<Rc<RoleContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ListPermissionsContextAttrs<'input> for ListPermissionsContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn listPermissions(&mut self,)
	-> Result<Rc<ListPermissionsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ListPermissionsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 16, RULE_listPermissions);
        let mut _localctx: Rc<ListPermissionsContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwList*/
			recog.base.set_state(653);
			recog.kwList()?;

			/*InvokeRule priviledge*/
			recog.base.set_state(654);
			recog.priviledge()?;

			recog.base.set_state(658);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_ON {
				{
				/*InvokeRule kwOn*/
				recog.base.set_state(655);
				recog.kwOn()?;

				/*InvokeRule resource*/
				recog.base.set_state(656);
				recog.resource()?;

				}
			}

			recog.base.set_state(663);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_OF {
				{
				/*InvokeRule kwOf*/
				recog.base.set_state(660);
				recog.kwOf()?;

				/*InvokeRule role*/
				recog.base.set_state(661);
				recog.role()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- grant ----------------
pub type GrantContextAll<'input> = GrantContext<'input>;


pub type GrantContext<'input> = BaseParserRuleContext<'input,GrantContextExt<'input>>;

#[derive(Clone)]
pub struct GrantContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for GrantContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for GrantContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_grant(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_grant(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for GrantContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_grant(self);
	}
}

impl<'input> CustomRuleContext<'input> for GrantContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_grant }
	//fn type_rule_index() -> usize where Self: Sized { RULE_grant }
}
antlr_rust::type_id!{GrantContextExt<'a>}

impl<'input> GrantContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<GrantContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,GrantContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait GrantContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<GrantContextExt<'input>>{

fn kwGrant(&self) -> Option<Rc<KwGrantContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn priviledge(&self) -> Option<Rc<PriviledgeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwOn(&self) -> Option<Rc<KwOnContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn resource(&self) -> Option<Rc<ResourceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwTo(&self) -> Option<Rc<KwToContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn role(&self) -> Option<Rc<RoleContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> GrantContextAttrs<'input> for GrantContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn grant(&mut self,)
	-> Result<Rc<GrantContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = GrantContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 18, RULE_grant);
        let mut _localctx: Rc<GrantContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwGrant*/
			recog.base.set_state(665);
			recog.kwGrant()?;

			/*InvokeRule priviledge*/
			recog.base.set_state(666);
			recog.priviledge()?;

			/*InvokeRule kwOn*/
			recog.base.set_state(667);
			recog.kwOn()?;

			/*InvokeRule resource*/
			recog.base.set_state(668);
			recog.resource()?;

			/*InvokeRule kwTo*/
			recog.base.set_state(669);
			recog.kwTo()?;

			/*InvokeRule role*/
			recog.base.set_state(670);
			recog.role()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- priviledge ----------------
pub type PriviledgeContextAll<'input> = PriviledgeContext<'input>;


pub type PriviledgeContext<'input> = BaseParserRuleContext<'input,PriviledgeContextExt<'input>>;

#[derive(Clone)]
pub struct PriviledgeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for PriviledgeContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for PriviledgeContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_priviledge(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_priviledge(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for PriviledgeContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_priviledge(self);
	}
}

impl<'input> CustomRuleContext<'input> for PriviledgeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_priviledge }
	//fn type_rule_index() -> usize where Self: Sized { RULE_priviledge }
}
antlr_rust::type_id!{PriviledgeContextExt<'a>}

impl<'input> PriviledgeContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PriviledgeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PriviledgeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PriviledgeContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<PriviledgeContextExt<'input>>{

fn kwAll(&self) -> Option<Rc<KwAllContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwAllPermissions(&self) -> Option<Rc<KwAllPermissionsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwAlter(&self) -> Option<Rc<KwAlterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwAuthorize(&self) -> Option<Rc<KwAuthorizeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwDescibe(&self) -> Option<Rc<KwDescibeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwExecute(&self) -> Option<Rc<KwExecuteContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwCreate(&self) -> Option<Rc<KwCreateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwDrop(&self) -> Option<Rc<KwDropContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwModify(&self) -> Option<Rc<KwModifyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwSelect(&self) -> Option<Rc<KwSelectContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PriviledgeContextAttrs<'input> for PriviledgeContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn priviledge(&mut self,)
	-> Result<Rc<PriviledgeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PriviledgeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 20, RULE_priviledge);
        let mut _localctx: Rc<PriviledgeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(684);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 K_ALL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(674);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(13,&mut recog.base)? {
						1 =>{
							{
							/*InvokeRule kwAll*/
							recog.base.set_state(672);
							recog.kwAll()?;

							}
						}
					,
						2 =>{
							{
							/*InvokeRule kwAllPermissions*/
							recog.base.set_state(673);
							recog.kwAllPermissions()?;

							}
						}

						_ => {}
					}
					}
				}

			 K_ALTER 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule kwAlter*/
					recog.base.set_state(676);
					recog.kwAlter()?;

					}
				}

			 K_AUTHORIZE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule kwAuthorize*/
					recog.base.set_state(677);
					recog.kwAuthorize()?;

					}
				}

			 K_DESCRIBE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule kwDescibe*/
					recog.base.set_state(678);
					recog.kwDescibe()?;

					}
				}

			 K_EXECUTE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule kwExecute*/
					recog.base.set_state(679);
					recog.kwExecute()?;

					}
				}

			 K_CREATE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule kwCreate*/
					recog.base.set_state(680);
					recog.kwCreate()?;

					}
				}

			 K_DROP 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					/*InvokeRule kwDrop*/
					recog.base.set_state(681);
					recog.kwDrop()?;

					}
				}

			 K_MODIFY 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					/*InvokeRule kwModify*/
					recog.base.set_state(682);
					recog.kwModify()?;

					}
				}

			 K_SELECT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 9);
					recog.base.enter_outer_alt(None, 9);
					{
					/*InvokeRule kwSelect*/
					recog.base.set_state(683);
					recog.kwSelect()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- resource ----------------
pub type ResourceContextAll<'input> = ResourceContext<'input>;


pub type ResourceContext<'input> = BaseParserRuleContext<'input,ResourceContextExt<'input>>;

#[derive(Clone)]
pub struct ResourceContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for ResourceContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for ResourceContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_resource(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_resource(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for ResourceContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_resource(self);
	}
}

impl<'input> CustomRuleContext<'input> for ResourceContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_resource }
	//fn type_rule_index() -> usize where Self: Sized { RULE_resource }
}
antlr_rust::type_id!{ResourceContextExt<'a>}

impl<'input> ResourceContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ResourceContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ResourceContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ResourceContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<ResourceContextExt<'input>>{

fn kwAll(&self) -> Option<Rc<KwAllContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwFunctions(&self) -> Option<Rc<KwFunctionsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwIn(&self) -> Option<Rc<KwInContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwKeyspace(&self) -> Option<Rc<KwKeyspaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn keyspace(&self) -> Option<Rc<KeyspaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwFunction(&self) -> Option<Rc<KwFunctionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn function_(&self) -> Option<Rc<Function_ContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
fn kwKeyspaces(&self) -> Option<Rc<KwKeyspacesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn table(&self) -> Option<Rc<TableContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwTable(&self) -> Option<Rc<KwTableContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwRoles(&self) -> Option<Rc<KwRolesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwRole(&self) -> Option<Rc<KwRoleContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn role(&self) -> Option<Rc<RoleContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ResourceContextAttrs<'input> for ResourceContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn resource(&mut self,)
	-> Result<Rc<ResourceContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ResourceContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 22, RULE_resource);
        let mut _localctx: Rc<ResourceContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(724);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(18,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule kwAll*/
					recog.base.set_state(686);
					recog.kwAll()?;

					/*InvokeRule kwFunctions*/
					recog.base.set_state(687);
					recog.kwFunctions()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule kwAll*/
					recog.base.set_state(689);
					recog.kwAll()?;

					/*InvokeRule kwFunctions*/
					recog.base.set_state(690);
					recog.kwFunctions()?;

					/*InvokeRule kwIn*/
					recog.base.set_state(691);
					recog.kwIn()?;

					/*InvokeRule kwKeyspace*/
					recog.base.set_state(692);
					recog.kwKeyspace()?;

					/*InvokeRule keyspace*/
					recog.base.set_state(693);
					recog.keyspace()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule kwFunction*/
					recog.base.set_state(695);
					recog.kwFunction()?;

					recog.base.set_state(699);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(15,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule keyspace*/
							recog.base.set_state(696);
							recog.keyspace()?;

							recog.base.set_state(697);
							recog.base.match_token(DOT,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					/*InvokeRule function_*/
					recog.base.set_state(701);
					recog.function_()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule kwAll*/
					recog.base.set_state(703);
					recog.kwAll()?;

					/*InvokeRule kwKeyspaces*/
					recog.base.set_state(704);
					recog.kwKeyspaces()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule kwKeyspace*/
					recog.base.set_state(706);
					recog.kwKeyspace()?;

					/*InvokeRule keyspace*/
					recog.base.set_state(707);
					recog.keyspace()?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					recog.base.set_state(710);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==K_TABLE {
						{
						/*InvokeRule kwTable*/
						recog.base.set_state(709);
						recog.kwTable()?;

						}
					}

					recog.base.set_state(715);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(17,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule keyspace*/
							recog.base.set_state(712);
							recog.keyspace()?;

							recog.base.set_state(713);
							recog.base.match_token(DOT,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					/*InvokeRule table*/
					recog.base.set_state(717);
					recog.table()?;

					}
				}
			,
				7 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					/*InvokeRule kwAll*/
					recog.base.set_state(718);
					recog.kwAll()?;

					/*InvokeRule kwRoles*/
					recog.base.set_state(719);
					recog.kwRoles()?;

					}
				}
			,
				8 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					/*InvokeRule kwRole*/
					recog.base.set_state(721);
					recog.kwRole()?;

					/*InvokeRule role*/
					recog.base.set_state(722);
					recog.role()?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- createUser ----------------
pub type CreateUserContextAll<'input> = CreateUserContext<'input>;


pub type CreateUserContext<'input> = BaseParserRuleContext<'input,CreateUserContextExt<'input>>;

#[derive(Clone)]
pub struct CreateUserContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for CreateUserContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for CreateUserContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_createUser(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_createUser(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for CreateUserContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_createUser(self);
	}
}

impl<'input> CustomRuleContext<'input> for CreateUserContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_createUser }
	//fn type_rule_index() -> usize where Self: Sized { RULE_createUser }
}
antlr_rust::type_id!{CreateUserContextExt<'a>}

impl<'input> CreateUserContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CreateUserContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CreateUserContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CreateUserContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<CreateUserContextExt<'input>>{

fn kwCreate(&self) -> Option<Rc<KwCreateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwUser(&self) -> Option<Rc<KwUserContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn user(&self) -> Option<Rc<UserContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwWith(&self) -> Option<Rc<KwWithContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwPassword(&self) -> Option<Rc<KwPasswordContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn stringLiteral(&self) -> Option<Rc<StringLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifNotExist(&self) -> Option<Rc<IfNotExistContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwSuperuser(&self) -> Option<Rc<KwSuperuserContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwNosuperuser(&self) -> Option<Rc<KwNosuperuserContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CreateUserContextAttrs<'input> for CreateUserContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn createUser(&mut self,)
	-> Result<Rc<CreateUserContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CreateUserContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 24, RULE_createUser);
        let mut _localctx: Rc<CreateUserContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwCreate*/
			recog.base.set_state(726);
			recog.kwCreate()?;

			/*InvokeRule kwUser*/
			recog.base.set_state(727);
			recog.kwUser()?;

			recog.base.set_state(729);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_IF {
				{
				/*InvokeRule ifNotExist*/
				recog.base.set_state(728);
				recog.ifNotExist()?;

				}
			}

			/*InvokeRule user*/
			recog.base.set_state(731);
			recog.user()?;

			/*InvokeRule kwWith*/
			recog.base.set_state(732);
			recog.kwWith()?;

			/*InvokeRule kwPassword*/
			recog.base.set_state(733);
			recog.kwPassword()?;

			/*InvokeRule stringLiteral*/
			recog.base.set_state(734);
			recog.stringLiteral()?;

			recog.base.set_state(737);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 K_SUPERUSER 
				=> {
			    	{
			    	/*InvokeRule kwSuperuser*/
			    	recog.base.set_state(735);
			    	recog.kwSuperuser()?;

			    	}
			    }

			 K_NOSUPERUSER 
				=> {
			    	{
			    	/*InvokeRule kwNosuperuser*/
			    	recog.base.set_state(736);
			    	recog.kwNosuperuser()?;

			    	}
			    }

			 EOF | SEMI | MINUSMINUS 
				=> {
			    }

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- createRole ----------------
pub type CreateRoleContextAll<'input> = CreateRoleContext<'input>;


pub type CreateRoleContext<'input> = BaseParserRuleContext<'input,CreateRoleContextExt<'input>>;

#[derive(Clone)]
pub struct CreateRoleContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for CreateRoleContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for CreateRoleContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_createRole(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_createRole(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for CreateRoleContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_createRole(self);
	}
}

impl<'input> CustomRuleContext<'input> for CreateRoleContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_createRole }
	//fn type_rule_index() -> usize where Self: Sized { RULE_createRole }
}
antlr_rust::type_id!{CreateRoleContextExt<'a>}

impl<'input> CreateRoleContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CreateRoleContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CreateRoleContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CreateRoleContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<CreateRoleContextExt<'input>>{

fn kwCreate(&self) -> Option<Rc<KwCreateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwRole(&self) -> Option<Rc<KwRoleContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn role(&self) -> Option<Rc<RoleContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifNotExist(&self) -> Option<Rc<IfNotExistContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn roleWith(&self) -> Option<Rc<RoleWithContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CreateRoleContextAttrs<'input> for CreateRoleContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn createRole(&mut self,)
	-> Result<Rc<CreateRoleContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CreateRoleContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 26, RULE_createRole);
        let mut _localctx: Rc<CreateRoleContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwCreate*/
			recog.base.set_state(739);
			recog.kwCreate()?;

			/*InvokeRule kwRole*/
			recog.base.set_state(740);
			recog.kwRole()?;

			recog.base.set_state(742);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_IF {
				{
				/*InvokeRule ifNotExist*/
				recog.base.set_state(741);
				recog.ifNotExist()?;

				}
			}

			/*InvokeRule role*/
			recog.base.set_state(744);
			recog.role()?;

			recog.base.set_state(746);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_WITH {
				{
				/*InvokeRule roleWith*/
				recog.base.set_state(745);
				recog.roleWith()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- createType ----------------
pub type CreateTypeContextAll<'input> = CreateTypeContext<'input>;


pub type CreateTypeContext<'input> = BaseParserRuleContext<'input,CreateTypeContextExt<'input>>;

#[derive(Clone)]
pub struct CreateTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for CreateTypeContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for CreateTypeContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_createType(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_createType(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for CreateTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_createType(self);
	}
}

impl<'input> CustomRuleContext<'input> for CreateTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_createType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_createType }
}
antlr_rust::type_id!{CreateTypeContextExt<'a>}

impl<'input> CreateTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CreateTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CreateTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CreateTypeContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<CreateTypeContextExt<'input>>{

fn kwCreate(&self) -> Option<Rc<KwCreateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwType(&self) -> Option<Rc<KwTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn type_(&self) -> Option<Rc<Type_ContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn syntaxBracketLr(&self) -> Option<Rc<SyntaxBracketLrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeMemberColumnList(&self) -> Option<Rc<TypeMemberColumnListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn syntaxBracketRr(&self) -> Option<Rc<SyntaxBracketRrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifNotExist(&self) -> Option<Rc<IfNotExistContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn keyspace(&self) -> Option<Rc<KeyspaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}

}

impl<'input> CreateTypeContextAttrs<'input> for CreateTypeContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn createType(&mut self,)
	-> Result<Rc<CreateTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CreateTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 28, RULE_createType);
        let mut _localctx: Rc<CreateTypeContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwCreate*/
			recog.base.set_state(748);
			recog.kwCreate()?;

			/*InvokeRule kwType*/
			recog.base.set_state(749);
			recog.kwType()?;

			recog.base.set_state(751);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_IF {
				{
				/*InvokeRule ifNotExist*/
				recog.base.set_state(750);
				recog.ifNotExist()?;

				}
			}

			recog.base.set_state(756);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(24,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule keyspace*/
					recog.base.set_state(753);
					recog.keyspace()?;

					recog.base.set_state(754);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			/*InvokeRule type_*/
			recog.base.set_state(758);
			recog.type_()?;

			/*InvokeRule syntaxBracketLr*/
			recog.base.set_state(759);
			recog.syntaxBracketLr()?;

			/*InvokeRule typeMemberColumnList*/
			recog.base.set_state(760);
			recog.typeMemberColumnList()?;

			/*InvokeRule syntaxBracketRr*/
			recog.base.set_state(761);
			recog.syntaxBracketRr()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeMemberColumnList ----------------
pub type TypeMemberColumnListContextAll<'input> = TypeMemberColumnListContext<'input>;


pub type TypeMemberColumnListContext<'input> = BaseParserRuleContext<'input,TypeMemberColumnListContextExt<'input>>;

#[derive(Clone)]
pub struct TypeMemberColumnListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for TypeMemberColumnListContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for TypeMemberColumnListContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typeMemberColumnList(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_typeMemberColumnList(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for TypeMemberColumnListContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_typeMemberColumnList(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeMemberColumnListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeMemberColumnList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeMemberColumnList }
}
antlr_rust::type_id!{TypeMemberColumnListContextExt<'a>}

impl<'input> TypeMemberColumnListContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeMemberColumnListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeMemberColumnListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeMemberColumnListContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<TypeMemberColumnListContextExt<'input>>{

fn column_all(&self) ->  Vec<Rc<ColumnContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn column(&self, i: usize) -> Option<Rc<ColumnContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn dataType_all(&self) ->  Vec<Rc<DataTypeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn dataType(&self, i: usize) -> Option<Rc<DataTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn syntaxComma_all(&self) ->  Vec<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn syntaxComma(&self, i: usize) -> Option<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> TypeMemberColumnListContextAttrs<'input> for TypeMemberColumnListContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeMemberColumnList(&mut self,)
	-> Result<Rc<TypeMemberColumnListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeMemberColumnListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 30, RULE_typeMemberColumnList);
        let mut _localctx: Rc<TypeMemberColumnListContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule column*/
			recog.base.set_state(763);
			recog.column()?;

			/*InvokeRule dataType*/
			recog.base.set_state(764);
			recog.dataType()?;

			recog.base.set_state(771);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				/*InvokeRule syntaxComma*/
				recog.base.set_state(765);
				recog.syntaxComma()?;

				/*InvokeRule column*/
				recog.base.set_state(766);
				recog.column()?;

				/*InvokeRule dataType*/
				recog.base.set_state(767);
				recog.dataType()?;

				}
				}
				recog.base.set_state(773);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- createTrigger ----------------
pub type CreateTriggerContextAll<'input> = CreateTriggerContext<'input>;


pub type CreateTriggerContext<'input> = BaseParserRuleContext<'input,CreateTriggerContextExt<'input>>;

#[derive(Clone)]
pub struct CreateTriggerContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for CreateTriggerContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for CreateTriggerContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_createTrigger(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_createTrigger(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for CreateTriggerContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_createTrigger(self);
	}
}

impl<'input> CustomRuleContext<'input> for CreateTriggerContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_createTrigger }
	//fn type_rule_index() -> usize where Self: Sized { RULE_createTrigger }
}
antlr_rust::type_id!{CreateTriggerContextExt<'a>}

impl<'input> CreateTriggerContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CreateTriggerContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CreateTriggerContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CreateTriggerContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<CreateTriggerContextExt<'input>>{

fn kwCreate(&self) -> Option<Rc<KwCreateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwTrigger(&self) -> Option<Rc<KwTriggerContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn trigger(&self) -> Option<Rc<TriggerContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwUsing(&self) -> Option<Rc<KwUsingContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn triggerClass(&self) -> Option<Rc<TriggerClassContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifNotExist(&self) -> Option<Rc<IfNotExistContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn keyspace(&self) -> Option<Rc<KeyspaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}

}

impl<'input> CreateTriggerContextAttrs<'input> for CreateTriggerContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn createTrigger(&mut self,)
	-> Result<Rc<CreateTriggerContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CreateTriggerContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 32, RULE_createTrigger);
        let mut _localctx: Rc<CreateTriggerContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwCreate*/
			recog.base.set_state(774);
			recog.kwCreate()?;

			/*InvokeRule kwTrigger*/
			recog.base.set_state(775);
			recog.kwTrigger()?;

			recog.base.set_state(777);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_IF {
				{
				/*InvokeRule ifNotExist*/
				recog.base.set_state(776);
				recog.ifNotExist()?;

				}
			}

			recog.base.set_state(782);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(27,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule keyspace*/
					recog.base.set_state(779);
					recog.keyspace()?;

					recog.base.set_state(780);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			/*InvokeRule trigger*/
			recog.base.set_state(784);
			recog.trigger()?;

			/*InvokeRule kwUsing*/
			recog.base.set_state(785);
			recog.kwUsing()?;

			/*InvokeRule triggerClass*/
			recog.base.set_state(786);
			recog.triggerClass()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- createMaterializedView ----------------
pub type CreateMaterializedViewContextAll<'input> = CreateMaterializedViewContext<'input>;


pub type CreateMaterializedViewContext<'input> = BaseParserRuleContext<'input,CreateMaterializedViewContextExt<'input>>;

#[derive(Clone)]
pub struct CreateMaterializedViewContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for CreateMaterializedViewContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for CreateMaterializedViewContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_createMaterializedView(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_createMaterializedView(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for CreateMaterializedViewContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_createMaterializedView(self);
	}
}

impl<'input> CustomRuleContext<'input> for CreateMaterializedViewContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_createMaterializedView }
	//fn type_rule_index() -> usize where Self: Sized { RULE_createMaterializedView }
}
antlr_rust::type_id!{CreateMaterializedViewContextExt<'a>}

impl<'input> CreateMaterializedViewContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CreateMaterializedViewContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CreateMaterializedViewContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CreateMaterializedViewContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<CreateMaterializedViewContextExt<'input>>{

fn kwCreate(&self) -> Option<Rc<KwCreateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwMaterialized(&self) -> Option<Rc<KwMaterializedContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwView(&self) -> Option<Rc<KwViewContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn materializedView(&self) -> Option<Rc<MaterializedViewContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwAs(&self) -> Option<Rc<KwAsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwSelect(&self) -> Option<Rc<KwSelectContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn columnList_all(&self) ->  Vec<Rc<ColumnListContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn columnList(&self, i: usize) -> Option<Rc<ColumnListContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn kwFrom(&self) -> Option<Rc<KwFromContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn table(&self) -> Option<Rc<TableContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn materializedViewWhere(&self) -> Option<Rc<MaterializedViewWhereContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwPrimary(&self) -> Option<Rc<KwPrimaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwKey(&self) -> Option<Rc<KwKeyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn syntaxBracketLr(&self) -> Option<Rc<SyntaxBracketLrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn syntaxBracketRr(&self) -> Option<Rc<SyntaxBracketRrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifNotExist(&self) -> Option<Rc<IfNotExistContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn keyspace_all(&self) ->  Vec<Rc<KeyspaceContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn keyspace(&self, i: usize) -> Option<Rc<KeyspaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token DOT in current rule
fn DOT_all(&self) -> Vec<Rc<TerminalNode<'input,CqlParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token DOT, starting from 0.
/// Returns `None` if number of children corresponding to token DOT is less or equal than `i`.
fn DOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(DOT, i)
}
fn kwWith(&self) -> Option<Rc<KwWithContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn materializedViewOptions(&self) -> Option<Rc<MaterializedViewOptionsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CreateMaterializedViewContextAttrs<'input> for CreateMaterializedViewContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn createMaterializedView(&mut self,)
	-> Result<Rc<CreateMaterializedViewContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CreateMaterializedViewContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 34, RULE_createMaterializedView);
        let mut _localctx: Rc<CreateMaterializedViewContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwCreate*/
			recog.base.set_state(788);
			recog.kwCreate()?;

			/*InvokeRule kwMaterialized*/
			recog.base.set_state(789);
			recog.kwMaterialized()?;

			/*InvokeRule kwView*/
			recog.base.set_state(790);
			recog.kwView()?;

			recog.base.set_state(792);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_IF {
				{
				/*InvokeRule ifNotExist*/
				recog.base.set_state(791);
				recog.ifNotExist()?;

				}
			}

			recog.base.set_state(797);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(29,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule keyspace*/
					recog.base.set_state(794);
					recog.keyspace()?;

					recog.base.set_state(795);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			/*InvokeRule materializedView*/
			recog.base.set_state(799);
			recog.materializedView()?;

			/*InvokeRule kwAs*/
			recog.base.set_state(800);
			recog.kwAs()?;

			/*InvokeRule kwSelect*/
			recog.base.set_state(801);
			recog.kwSelect()?;

			/*InvokeRule columnList*/
			recog.base.set_state(802);
			recog.columnList()?;

			/*InvokeRule kwFrom*/
			recog.base.set_state(803);
			recog.kwFrom()?;

			recog.base.set_state(807);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(30,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule keyspace*/
					recog.base.set_state(804);
					recog.keyspace()?;

					recog.base.set_state(805);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			/*InvokeRule table*/
			recog.base.set_state(809);
			recog.table()?;

			/*InvokeRule materializedViewWhere*/
			recog.base.set_state(810);
			recog.materializedViewWhere()?;

			/*InvokeRule kwPrimary*/
			recog.base.set_state(811);
			recog.kwPrimary()?;

			/*InvokeRule kwKey*/
			recog.base.set_state(812);
			recog.kwKey()?;

			/*InvokeRule syntaxBracketLr*/
			recog.base.set_state(813);
			recog.syntaxBracketLr()?;

			/*InvokeRule columnList*/
			recog.base.set_state(814);
			recog.columnList()?;

			/*InvokeRule syntaxBracketRr*/
			recog.base.set_state(815);
			recog.syntaxBracketRr()?;

			recog.base.set_state(819);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_WITH {
				{
				/*InvokeRule kwWith*/
				recog.base.set_state(816);
				recog.kwWith()?;

				/*InvokeRule materializedViewOptions*/
				recog.base.set_state(817);
				recog.materializedViewOptions()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- materializedViewWhere ----------------
pub type MaterializedViewWhereContextAll<'input> = MaterializedViewWhereContext<'input>;


pub type MaterializedViewWhereContext<'input> = BaseParserRuleContext<'input,MaterializedViewWhereContextExt<'input>>;

#[derive(Clone)]
pub struct MaterializedViewWhereContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for MaterializedViewWhereContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for MaterializedViewWhereContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_materializedViewWhere(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_materializedViewWhere(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for MaterializedViewWhereContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_materializedViewWhere(self);
	}
}

impl<'input> CustomRuleContext<'input> for MaterializedViewWhereContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_materializedViewWhere }
	//fn type_rule_index() -> usize where Self: Sized { RULE_materializedViewWhere }
}
antlr_rust::type_id!{MaterializedViewWhereContextExt<'a>}

impl<'input> MaterializedViewWhereContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MaterializedViewWhereContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MaterializedViewWhereContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MaterializedViewWhereContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<MaterializedViewWhereContextExt<'input>>{

fn kwWhere(&self) -> Option<Rc<KwWhereContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn columnNotNullList(&self) -> Option<Rc<ColumnNotNullListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwAnd(&self) -> Option<Rc<KwAndContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn relationElements(&self) -> Option<Rc<RelationElementsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MaterializedViewWhereContextAttrs<'input> for MaterializedViewWhereContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn materializedViewWhere(&mut self,)
	-> Result<Rc<MaterializedViewWhereContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MaterializedViewWhereContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 36, RULE_materializedViewWhere);
        let mut _localctx: Rc<MaterializedViewWhereContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwWhere*/
			recog.base.set_state(821);
			recog.kwWhere()?;

			/*InvokeRule columnNotNullList*/
			recog.base.set_state(822);
			recog.columnNotNullList()?;

			recog.base.set_state(826);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_AND {
				{
				/*InvokeRule kwAnd*/
				recog.base.set_state(823);
				recog.kwAnd()?;

				/*InvokeRule relationElements*/
				recog.base.set_state(824);
				recog.relationElements()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- columnNotNullList ----------------
pub type ColumnNotNullListContextAll<'input> = ColumnNotNullListContext<'input>;


pub type ColumnNotNullListContext<'input> = BaseParserRuleContext<'input,ColumnNotNullListContextExt<'input>>;

#[derive(Clone)]
pub struct ColumnNotNullListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for ColumnNotNullListContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for ColumnNotNullListContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_columnNotNullList(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_columnNotNullList(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for ColumnNotNullListContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_columnNotNullList(self);
	}
}

impl<'input> CustomRuleContext<'input> for ColumnNotNullListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_columnNotNullList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_columnNotNullList }
}
antlr_rust::type_id!{ColumnNotNullListContextExt<'a>}

impl<'input> ColumnNotNullListContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ColumnNotNullListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ColumnNotNullListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ColumnNotNullListContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<ColumnNotNullListContextExt<'input>>{

fn columnNotNull_all(&self) ->  Vec<Rc<ColumnNotNullContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn columnNotNull(&self, i: usize) -> Option<Rc<ColumnNotNullContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn kwAnd_all(&self) ->  Vec<Rc<KwAndContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn kwAnd(&self, i: usize) -> Option<Rc<KwAndContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ColumnNotNullListContextAttrs<'input> for ColumnNotNullListContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn columnNotNullList(&mut self,)
	-> Result<Rc<ColumnNotNullListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ColumnNotNullListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 38, RULE_columnNotNullList);
        let mut _localctx: Rc<ColumnNotNullListContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule columnNotNull*/
			recog.base.set_state(828);
			recog.columnNotNull()?;

			recog.base.set_state(834);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(33,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule kwAnd*/
					recog.base.set_state(829);
					recog.kwAnd()?;

					/*InvokeRule columnNotNull*/
					recog.base.set_state(830);
					recog.columnNotNull()?;

					}
					} 
				}
				recog.base.set_state(836);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(33,&mut recog.base)?;
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- columnNotNull ----------------
pub type ColumnNotNullContextAll<'input> = ColumnNotNullContext<'input>;


pub type ColumnNotNullContext<'input> = BaseParserRuleContext<'input,ColumnNotNullContextExt<'input>>;

#[derive(Clone)]
pub struct ColumnNotNullContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for ColumnNotNullContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for ColumnNotNullContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_columnNotNull(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_columnNotNull(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for ColumnNotNullContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_columnNotNull(self);
	}
}

impl<'input> CustomRuleContext<'input> for ColumnNotNullContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_columnNotNull }
	//fn type_rule_index() -> usize where Self: Sized { RULE_columnNotNull }
}
antlr_rust::type_id!{ColumnNotNullContextExt<'a>}

impl<'input> ColumnNotNullContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ColumnNotNullContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ColumnNotNullContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ColumnNotNullContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<ColumnNotNullContextExt<'input>>{

fn column(&self) -> Option<Rc<ColumnContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwIs(&self) -> Option<Rc<KwIsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwNot(&self) -> Option<Rc<KwNotContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwNull(&self) -> Option<Rc<KwNullContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ColumnNotNullContextAttrs<'input> for ColumnNotNullContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn columnNotNull(&mut self,)
	-> Result<Rc<ColumnNotNullContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ColumnNotNullContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 40, RULE_columnNotNull);
        let mut _localctx: Rc<ColumnNotNullContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule column*/
			recog.base.set_state(837);
			recog.column()?;

			/*InvokeRule kwIs*/
			recog.base.set_state(838);
			recog.kwIs()?;

			/*InvokeRule kwNot*/
			recog.base.set_state(839);
			recog.kwNot()?;

			/*InvokeRule kwNull*/
			recog.base.set_state(840);
			recog.kwNull()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- materializedViewOptions ----------------
pub type MaterializedViewOptionsContextAll<'input> = MaterializedViewOptionsContext<'input>;


pub type MaterializedViewOptionsContext<'input> = BaseParserRuleContext<'input,MaterializedViewOptionsContextExt<'input>>;

#[derive(Clone)]
pub struct MaterializedViewOptionsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for MaterializedViewOptionsContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for MaterializedViewOptionsContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_materializedViewOptions(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_materializedViewOptions(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for MaterializedViewOptionsContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_materializedViewOptions(self);
	}
}

impl<'input> CustomRuleContext<'input> for MaterializedViewOptionsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_materializedViewOptions }
	//fn type_rule_index() -> usize where Self: Sized { RULE_materializedViewOptions }
}
antlr_rust::type_id!{MaterializedViewOptionsContextExt<'a>}

impl<'input> MaterializedViewOptionsContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MaterializedViewOptionsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MaterializedViewOptionsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MaterializedViewOptionsContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<MaterializedViewOptionsContextExt<'input>>{

fn tableOptions(&self) -> Option<Rc<TableOptionsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwAnd(&self) -> Option<Rc<KwAndContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn clusteringOrder(&self) -> Option<Rc<ClusteringOrderContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MaterializedViewOptionsContextAttrs<'input> for MaterializedViewOptionsContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn materializedViewOptions(&mut self,)
	-> Result<Rc<MaterializedViewOptionsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MaterializedViewOptionsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 42, RULE_materializedViewOptions);
        let mut _localctx: Rc<MaterializedViewOptionsContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(848);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(34,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule tableOptions*/
					recog.base.set_state(842);
					recog.tableOptions()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule tableOptions*/
					recog.base.set_state(843);
					recog.tableOptions()?;

					/*InvokeRule kwAnd*/
					recog.base.set_state(844);
					recog.kwAnd()?;

					/*InvokeRule clusteringOrder*/
					recog.base.set_state(845);
					recog.clusteringOrder()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule clusteringOrder*/
					recog.base.set_state(847);
					recog.clusteringOrder()?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- createKeyspace ----------------
pub type CreateKeyspaceContextAll<'input> = CreateKeyspaceContext<'input>;


pub type CreateKeyspaceContext<'input> = BaseParserRuleContext<'input,CreateKeyspaceContextExt<'input>>;

#[derive(Clone)]
pub struct CreateKeyspaceContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for CreateKeyspaceContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for CreateKeyspaceContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_createKeyspace(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_createKeyspace(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for CreateKeyspaceContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_createKeyspace(self);
	}
}

impl<'input> CustomRuleContext<'input> for CreateKeyspaceContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_createKeyspace }
	//fn type_rule_index() -> usize where Self: Sized { RULE_createKeyspace }
}
antlr_rust::type_id!{CreateKeyspaceContextExt<'a>}

impl<'input> CreateKeyspaceContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CreateKeyspaceContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CreateKeyspaceContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CreateKeyspaceContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<CreateKeyspaceContextExt<'input>>{

fn kwCreate(&self) -> Option<Rc<KwCreateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwKeyspace(&self) -> Option<Rc<KwKeyspaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn keyspace(&self) -> Option<Rc<KeyspaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwWith(&self) -> Option<Rc<KwWithContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwReplication(&self) -> Option<Rc<KwReplicationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token OPERATOR_EQ
/// Returns `None` if there is no child corresponding to token OPERATOR_EQ
fn OPERATOR_EQ(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OPERATOR_EQ, 0)
}
fn syntaxBracketLc(&self) -> Option<Rc<SyntaxBracketLcContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn replicationList(&self) -> Option<Rc<ReplicationListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn syntaxBracketRc(&self) -> Option<Rc<SyntaxBracketRcContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifNotExist(&self) -> Option<Rc<IfNotExistContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwAnd(&self) -> Option<Rc<KwAndContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn durableWrites(&self) -> Option<Rc<DurableWritesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CreateKeyspaceContextAttrs<'input> for CreateKeyspaceContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn createKeyspace(&mut self,)
	-> Result<Rc<CreateKeyspaceContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CreateKeyspaceContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 44, RULE_createKeyspace);
        let mut _localctx: Rc<CreateKeyspaceContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwCreate*/
			recog.base.set_state(850);
			recog.kwCreate()?;

			/*InvokeRule kwKeyspace*/
			recog.base.set_state(851);
			recog.kwKeyspace()?;

			recog.base.set_state(853);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_IF {
				{
				/*InvokeRule ifNotExist*/
				recog.base.set_state(852);
				recog.ifNotExist()?;

				}
			}

			/*InvokeRule keyspace*/
			recog.base.set_state(855);
			recog.keyspace()?;

			/*InvokeRule kwWith*/
			recog.base.set_state(856);
			recog.kwWith()?;

			/*InvokeRule kwReplication*/
			recog.base.set_state(857);
			recog.kwReplication()?;

			recog.base.set_state(858);
			recog.base.match_token(OPERATOR_EQ,&mut recog.err_handler)?;

			/*InvokeRule syntaxBracketLc*/
			recog.base.set_state(859);
			recog.syntaxBracketLc()?;

			/*InvokeRule replicationList*/
			recog.base.set_state(860);
			recog.replicationList()?;

			/*InvokeRule syntaxBracketRc*/
			recog.base.set_state(861);
			recog.syntaxBracketRc()?;

			recog.base.set_state(865);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_AND {
				{
				/*InvokeRule kwAnd*/
				recog.base.set_state(862);
				recog.kwAnd()?;

				/*InvokeRule durableWrites*/
				recog.base.set_state(863);
				recog.durableWrites()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- createFunction ----------------
pub type CreateFunctionContextAll<'input> = CreateFunctionContext<'input>;


pub type CreateFunctionContext<'input> = BaseParserRuleContext<'input,CreateFunctionContextExt<'input>>;

#[derive(Clone)]
pub struct CreateFunctionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for CreateFunctionContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for CreateFunctionContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_createFunction(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_createFunction(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for CreateFunctionContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_createFunction(self);
	}
}

impl<'input> CustomRuleContext<'input> for CreateFunctionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_createFunction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_createFunction }
}
antlr_rust::type_id!{CreateFunctionContextExt<'a>}

impl<'input> CreateFunctionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CreateFunctionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CreateFunctionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CreateFunctionContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<CreateFunctionContextExt<'input>>{

fn kwCreate(&self) -> Option<Rc<KwCreateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwFunction(&self) -> Option<Rc<KwFunctionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn function_(&self) -> Option<Rc<Function_ContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn syntaxBracketLr(&self) -> Option<Rc<SyntaxBracketLrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn syntaxBracketRr(&self) -> Option<Rc<SyntaxBracketRrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn returnMode(&self) -> Option<Rc<ReturnModeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwReturns(&self) -> Option<Rc<KwReturnsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn dataType(&self) -> Option<Rc<DataTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwLanguage(&self) -> Option<Rc<KwLanguageContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn language(&self) -> Option<Rc<LanguageContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwAs(&self) -> Option<Rc<KwAsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn codeBlock(&self) -> Option<Rc<CodeBlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn orReplace(&self) -> Option<Rc<OrReplaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifNotExist(&self) -> Option<Rc<IfNotExistContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn keyspace(&self) -> Option<Rc<KeyspaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
fn paramList(&self) -> Option<Rc<ParamListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CreateFunctionContextAttrs<'input> for CreateFunctionContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn createFunction(&mut self,)
	-> Result<Rc<CreateFunctionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CreateFunctionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 46, RULE_createFunction);
        let mut _localctx: Rc<CreateFunctionContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwCreate*/
			recog.base.set_state(867);
			recog.kwCreate()?;

			recog.base.set_state(869);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_OR {
				{
				/*InvokeRule orReplace*/
				recog.base.set_state(868);
				recog.orReplace()?;

				}
			}

			/*InvokeRule kwFunction*/
			recog.base.set_state(871);
			recog.kwFunction()?;

			recog.base.set_state(873);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_IF {
				{
				/*InvokeRule ifNotExist*/
				recog.base.set_state(872);
				recog.ifNotExist()?;

				}
			}

			recog.base.set_state(878);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(39,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule keyspace*/
					recog.base.set_state(875);
					recog.keyspace()?;

					recog.base.set_state(876);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			/*InvokeRule function_*/
			recog.base.set_state(880);
			recog.function_()?;

			/*InvokeRule syntaxBracketLr*/
			recog.base.set_state(881);
			recog.syntaxBracketLr()?;

			recog.base.set_state(883);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==OBJECT_NAME {
				{
				/*InvokeRule paramList*/
				recog.base.set_state(882);
				recog.paramList()?;

				}
			}

			/*InvokeRule syntaxBracketRr*/
			recog.base.set_state(885);
			recog.syntaxBracketRr()?;

			/*InvokeRule returnMode*/
			recog.base.set_state(886);
			recog.returnMode()?;

			/*InvokeRule kwReturns*/
			recog.base.set_state(887);
			recog.kwReturns()?;

			/*InvokeRule dataType*/
			recog.base.set_state(888);
			recog.dataType()?;

			/*InvokeRule kwLanguage*/
			recog.base.set_state(889);
			recog.kwLanguage()?;

			/*InvokeRule language*/
			recog.base.set_state(890);
			recog.language()?;

			/*InvokeRule kwAs*/
			recog.base.set_state(891);
			recog.kwAs()?;

			/*InvokeRule codeBlock*/
			recog.base.set_state(892);
			recog.codeBlock()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- codeBlock ----------------
pub type CodeBlockContextAll<'input> = CodeBlockContext<'input>;


pub type CodeBlockContext<'input> = BaseParserRuleContext<'input,CodeBlockContextExt<'input>>;

#[derive(Clone)]
pub struct CodeBlockContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for CodeBlockContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for CodeBlockContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_codeBlock(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_codeBlock(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for CodeBlockContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_codeBlock(self);
	}
}

impl<'input> CustomRuleContext<'input> for CodeBlockContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_codeBlock }
	//fn type_rule_index() -> usize where Self: Sized { RULE_codeBlock }
}
antlr_rust::type_id!{CodeBlockContextExt<'a>}

impl<'input> CodeBlockContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CodeBlockContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CodeBlockContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CodeBlockContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<CodeBlockContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token CODE_BLOCK
/// Returns `None` if there is no child corresponding to token CODE_BLOCK
fn CODE_BLOCK(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(CODE_BLOCK, 0)
}

}

impl<'input> CodeBlockContextAttrs<'input> for CodeBlockContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn codeBlock(&mut self,)
	-> Result<Rc<CodeBlockContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CodeBlockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 48, RULE_codeBlock);
        let mut _localctx: Rc<CodeBlockContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(894);
			recog.base.match_token(CODE_BLOCK,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- paramList ----------------
pub type ParamListContextAll<'input> = ParamListContext<'input>;


pub type ParamListContext<'input> = BaseParserRuleContext<'input,ParamListContextExt<'input>>;

#[derive(Clone)]
pub struct ParamListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for ParamListContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for ParamListContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_paramList(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_paramList(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for ParamListContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_paramList(self);
	}
}

impl<'input> CustomRuleContext<'input> for ParamListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_paramList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_paramList }
}
antlr_rust::type_id!{ParamListContextExt<'a>}

impl<'input> ParamListContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ParamListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ParamListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ParamListContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<ParamListContextExt<'input>>{

fn param_all(&self) ->  Vec<Rc<ParamContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn param(&self, i: usize) -> Option<Rc<ParamContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn syntaxComma_all(&self) ->  Vec<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn syntaxComma(&self, i: usize) -> Option<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ParamListContextAttrs<'input> for ParamListContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn paramList(&mut self,)
	-> Result<Rc<ParamListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ParamListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 50, RULE_paramList);
        let mut _localctx: Rc<ParamListContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule param*/
			recog.base.set_state(896);
			recog.param()?;

			recog.base.set_state(902);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				/*InvokeRule syntaxComma*/
				recog.base.set_state(897);
				recog.syntaxComma()?;

				/*InvokeRule param*/
				recog.base.set_state(898);
				recog.param()?;

				}
				}
				recog.base.set_state(904);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- returnMode ----------------
pub type ReturnModeContextAll<'input> = ReturnModeContext<'input>;


pub type ReturnModeContext<'input> = BaseParserRuleContext<'input,ReturnModeContextExt<'input>>;

#[derive(Clone)]
pub struct ReturnModeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for ReturnModeContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for ReturnModeContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_returnMode(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_returnMode(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for ReturnModeContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_returnMode(self);
	}
}

impl<'input> CustomRuleContext<'input> for ReturnModeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_returnMode }
	//fn type_rule_index() -> usize where Self: Sized { RULE_returnMode }
}
antlr_rust::type_id!{ReturnModeContextExt<'a>}

impl<'input> ReturnModeContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ReturnModeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ReturnModeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ReturnModeContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<ReturnModeContextExt<'input>>{

fn kwOn(&self) -> Option<Rc<KwOnContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwNull_all(&self) ->  Vec<Rc<KwNullContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn kwNull(&self, i: usize) -> Option<Rc<KwNullContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn kwInput(&self) -> Option<Rc<KwInputContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwCalled(&self) -> Option<Rc<KwCalledContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwReturns(&self) -> Option<Rc<KwReturnsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ReturnModeContextAttrs<'input> for ReturnModeContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn returnMode(&mut self,)
	-> Result<Rc<ReturnModeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ReturnModeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 52, RULE_returnMode);
        let mut _localctx: Rc<ReturnModeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(909);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 K_CALLED 
				=> {
					{
					/*InvokeRule kwCalled*/
					recog.base.set_state(905);
					recog.kwCalled()?;

					}
				}

			 K_RETURNS 
				=> {
					{
					/*InvokeRule kwReturns*/
					recog.base.set_state(906);
					recog.kwReturns()?;

					/*InvokeRule kwNull*/
					recog.base.set_state(907);
					recog.kwNull()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			/*InvokeRule kwOn*/
			recog.base.set_state(911);
			recog.kwOn()?;

			/*InvokeRule kwNull*/
			recog.base.set_state(912);
			recog.kwNull()?;

			/*InvokeRule kwInput*/
			recog.base.set_state(913);
			recog.kwInput()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- createAggregate ----------------
pub type CreateAggregateContextAll<'input> = CreateAggregateContext<'input>;


pub type CreateAggregateContext<'input> = BaseParserRuleContext<'input,CreateAggregateContextExt<'input>>;

#[derive(Clone)]
pub struct CreateAggregateContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for CreateAggregateContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for CreateAggregateContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_createAggregate(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_createAggregate(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for CreateAggregateContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_createAggregate(self);
	}
}

impl<'input> CustomRuleContext<'input> for CreateAggregateContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_createAggregate }
	//fn type_rule_index() -> usize where Self: Sized { RULE_createAggregate }
}
antlr_rust::type_id!{CreateAggregateContextExt<'a>}

impl<'input> CreateAggregateContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CreateAggregateContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CreateAggregateContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CreateAggregateContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<CreateAggregateContextExt<'input>>{

fn kwCreate(&self) -> Option<Rc<KwCreateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwAggregate(&self) -> Option<Rc<KwAggregateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn aggregate(&self) -> Option<Rc<AggregateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn syntaxBracketLr(&self) -> Option<Rc<SyntaxBracketLrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn dataType_all(&self) ->  Vec<Rc<DataTypeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn dataType(&self, i: usize) -> Option<Rc<DataTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn syntaxBracketRr(&self) -> Option<Rc<SyntaxBracketRrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwSfunc(&self) -> Option<Rc<KwSfuncContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn function__all(&self) ->  Vec<Rc<Function_ContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn function_(&self, i: usize) -> Option<Rc<Function_ContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn kwStype(&self) -> Option<Rc<KwStypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwFinalfunc(&self) -> Option<Rc<KwFinalfuncContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwInitcond(&self) -> Option<Rc<KwInitcondContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn initCondDefinition(&self) -> Option<Rc<InitCondDefinitionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn orReplace(&self) -> Option<Rc<OrReplaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifNotExist(&self) -> Option<Rc<IfNotExistContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn keyspace(&self) -> Option<Rc<KeyspaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}

}

impl<'input> CreateAggregateContextAttrs<'input> for CreateAggregateContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn createAggregate(&mut self,)
	-> Result<Rc<CreateAggregateContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CreateAggregateContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 54, RULE_createAggregate);
        let mut _localctx: Rc<CreateAggregateContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwCreate*/
			recog.base.set_state(915);
			recog.kwCreate()?;

			recog.base.set_state(917);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_OR {
				{
				/*InvokeRule orReplace*/
				recog.base.set_state(916);
				recog.orReplace()?;

				}
			}

			/*InvokeRule kwAggregate*/
			recog.base.set_state(919);
			recog.kwAggregate()?;

			recog.base.set_state(921);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_IF {
				{
				/*InvokeRule ifNotExist*/
				recog.base.set_state(920);
				recog.ifNotExist()?;

				}
			}

			recog.base.set_state(926);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(45,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule keyspace*/
					recog.base.set_state(923);
					recog.keyspace()?;

					recog.base.set_state(924);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			/*InvokeRule aggregate*/
			recog.base.set_state(928);
			recog.aggregate()?;

			/*InvokeRule syntaxBracketLr*/
			recog.base.set_state(929);
			recog.syntaxBracketLr()?;

			/*InvokeRule dataType*/
			recog.base.set_state(930);
			recog.dataType()?;

			/*InvokeRule syntaxBracketRr*/
			recog.base.set_state(931);
			recog.syntaxBracketRr()?;

			/*InvokeRule kwSfunc*/
			recog.base.set_state(932);
			recog.kwSfunc()?;

			/*InvokeRule function_*/
			recog.base.set_state(933);
			recog.function_()?;

			/*InvokeRule kwStype*/
			recog.base.set_state(934);
			recog.kwStype()?;

			/*InvokeRule dataType*/
			recog.base.set_state(935);
			recog.dataType()?;

			/*InvokeRule kwFinalfunc*/
			recog.base.set_state(936);
			recog.kwFinalfunc()?;

			/*InvokeRule function_*/
			recog.base.set_state(937);
			recog.function_()?;

			/*InvokeRule kwInitcond*/
			recog.base.set_state(938);
			recog.kwInitcond()?;

			/*InvokeRule initCondDefinition*/
			recog.base.set_state(939);
			recog.initCondDefinition()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- initCondDefinition ----------------
pub type InitCondDefinitionContextAll<'input> = InitCondDefinitionContext<'input>;


pub type InitCondDefinitionContext<'input> = BaseParserRuleContext<'input,InitCondDefinitionContextExt<'input>>;

#[derive(Clone)]
pub struct InitCondDefinitionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for InitCondDefinitionContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for InitCondDefinitionContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_initCondDefinition(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_initCondDefinition(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for InitCondDefinitionContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_initCondDefinition(self);
	}
}

impl<'input> CustomRuleContext<'input> for InitCondDefinitionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_initCondDefinition }
	//fn type_rule_index() -> usize where Self: Sized { RULE_initCondDefinition }
}
antlr_rust::type_id!{InitCondDefinitionContextExt<'a>}

impl<'input> InitCondDefinitionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InitCondDefinitionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InitCondDefinitionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InitCondDefinitionContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<InitCondDefinitionContextExt<'input>>{

fn constant(&self) -> Option<Rc<ConstantContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn initCondList(&self) -> Option<Rc<InitCondListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn initCondListNested(&self) -> Option<Rc<InitCondListNestedContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn initCondHash(&self) -> Option<Rc<InitCondHashContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InitCondDefinitionContextAttrs<'input> for InitCondDefinitionContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn initCondDefinition(&mut self,)
	-> Result<Rc<InitCondDefinitionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InitCondDefinitionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 56, RULE_initCondDefinition);
        let mut _localctx: Rc<InitCondDefinitionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(945);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(46,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule constant*/
					recog.base.set_state(941);
					recog.constant()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule initCondList*/
					recog.base.set_state(942);
					recog.initCondList()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule initCondListNested*/
					recog.base.set_state(943);
					recog.initCondListNested()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule initCondHash*/
					recog.base.set_state(944);
					recog.initCondHash()?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- initCondHash ----------------
pub type InitCondHashContextAll<'input> = InitCondHashContext<'input>;


pub type InitCondHashContext<'input> = BaseParserRuleContext<'input,InitCondHashContextExt<'input>>;

#[derive(Clone)]
pub struct InitCondHashContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for InitCondHashContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for InitCondHashContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_initCondHash(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_initCondHash(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for InitCondHashContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_initCondHash(self);
	}
}

impl<'input> CustomRuleContext<'input> for InitCondHashContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_initCondHash }
	//fn type_rule_index() -> usize where Self: Sized { RULE_initCondHash }
}
antlr_rust::type_id!{InitCondHashContextExt<'a>}

impl<'input> InitCondHashContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InitCondHashContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InitCondHashContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InitCondHashContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<InitCondHashContextExt<'input>>{

fn syntaxBracketLc(&self) -> Option<Rc<SyntaxBracketLcContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn initCondHashItem_all(&self) ->  Vec<Rc<InitCondHashItemContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn initCondHashItem(&self, i: usize) -> Option<Rc<InitCondHashItemContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn syntaxBracketRc(&self) -> Option<Rc<SyntaxBracketRcContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn syntaxComma_all(&self) ->  Vec<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn syntaxComma(&self, i: usize) -> Option<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> InitCondHashContextAttrs<'input> for InitCondHashContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn initCondHash(&mut self,)
	-> Result<Rc<InitCondHashContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InitCondHashContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 58, RULE_initCondHash);
        let mut _localctx: Rc<InitCondHashContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule syntaxBracketLc*/
			recog.base.set_state(947);
			recog.syntaxBracketLc()?;

			/*InvokeRule initCondHashItem*/
			recog.base.set_state(948);
			recog.initCondHashItem()?;

			recog.base.set_state(954);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				/*InvokeRule syntaxComma*/
				recog.base.set_state(949);
				recog.syntaxComma()?;

				/*InvokeRule initCondHashItem*/
				recog.base.set_state(950);
				recog.initCondHashItem()?;

				}
				}
				recog.base.set_state(956);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule syntaxBracketRc*/
			recog.base.set_state(957);
			recog.syntaxBracketRc()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- initCondHashItem ----------------
pub type InitCondHashItemContextAll<'input> = InitCondHashItemContext<'input>;


pub type InitCondHashItemContext<'input> = BaseParserRuleContext<'input,InitCondHashItemContextExt<'input>>;

#[derive(Clone)]
pub struct InitCondHashItemContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for InitCondHashItemContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for InitCondHashItemContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_initCondHashItem(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_initCondHashItem(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for InitCondHashItemContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_initCondHashItem(self);
	}
}

impl<'input> CustomRuleContext<'input> for InitCondHashItemContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_initCondHashItem }
	//fn type_rule_index() -> usize where Self: Sized { RULE_initCondHashItem }
}
antlr_rust::type_id!{InitCondHashItemContextExt<'a>}

impl<'input> InitCondHashItemContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InitCondHashItemContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InitCondHashItemContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InitCondHashItemContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<InitCondHashItemContextExt<'input>>{

fn hashKey(&self) -> Option<Rc<HashKeyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn initCondDefinition(&self) -> Option<Rc<InitCondDefinitionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InitCondHashItemContextAttrs<'input> for InitCondHashItemContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn initCondHashItem(&mut self,)
	-> Result<Rc<InitCondHashItemContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InitCondHashItemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 60, RULE_initCondHashItem);
        let mut _localctx: Rc<InitCondHashItemContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule hashKey*/
			recog.base.set_state(959);
			recog.hashKey()?;

			recog.base.set_state(960);
			recog.base.match_token(COLON,&mut recog.err_handler)?;

			/*InvokeRule initCondDefinition*/
			recog.base.set_state(961);
			recog.initCondDefinition()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- initCondListNested ----------------
pub type InitCondListNestedContextAll<'input> = InitCondListNestedContext<'input>;


pub type InitCondListNestedContext<'input> = BaseParserRuleContext<'input,InitCondListNestedContextExt<'input>>;

#[derive(Clone)]
pub struct InitCondListNestedContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for InitCondListNestedContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for InitCondListNestedContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_initCondListNested(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_initCondListNested(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for InitCondListNestedContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_initCondListNested(self);
	}
}

impl<'input> CustomRuleContext<'input> for InitCondListNestedContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_initCondListNested }
	//fn type_rule_index() -> usize where Self: Sized { RULE_initCondListNested }
}
antlr_rust::type_id!{InitCondListNestedContextExt<'a>}

impl<'input> InitCondListNestedContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InitCondListNestedContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InitCondListNestedContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InitCondListNestedContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<InitCondListNestedContextExt<'input>>{

fn syntaxBracketLr(&self) -> Option<Rc<SyntaxBracketLrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn initCondList_all(&self) ->  Vec<Rc<InitCondListContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn initCondList(&self, i: usize) -> Option<Rc<InitCondListContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn syntaxBracketRr(&self) -> Option<Rc<SyntaxBracketRrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn syntaxComma_all(&self) ->  Vec<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn syntaxComma(&self, i: usize) -> Option<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn constant_all(&self) ->  Vec<Rc<ConstantContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn constant(&self, i: usize) -> Option<Rc<ConstantContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> InitCondListNestedContextAttrs<'input> for InitCondListNestedContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn initCondListNested(&mut self,)
	-> Result<Rc<InitCondListNestedContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InitCondListNestedContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 62, RULE_initCondListNested);
        let mut _localctx: Rc<InitCondListNestedContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule syntaxBracketLr*/
			recog.base.set_state(963);
			recog.syntaxBracketLr()?;

			/*InvokeRule initCondList*/
			recog.base.set_state(964);
			recog.initCondList()?;

			recog.base.set_state(971);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==LR_BRACKET || _la==COMMA {
				{
				recog.base.set_state(969);
				recog.err_handler.sync(&mut recog.base)?;
				match recog.base.input.la(1) {
				 COMMA 
					=> {
						{
						/*InvokeRule syntaxComma*/
						recog.base.set_state(965);
						recog.syntaxComma()?;

						/*InvokeRule constant*/
						recog.base.set_state(966);
						recog.constant()?;

						}
					}

				 LR_BRACKET 
					=> {
						{
						/*InvokeRule initCondList*/
						recog.base.set_state(968);
						recog.initCondList()?;

						}
					}

					_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
				}
				}
				recog.base.set_state(973);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule syntaxBracketRr*/
			recog.base.set_state(974);
			recog.syntaxBracketRr()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- initCondList ----------------
pub type InitCondListContextAll<'input> = InitCondListContext<'input>;


pub type InitCondListContext<'input> = BaseParserRuleContext<'input,InitCondListContextExt<'input>>;

#[derive(Clone)]
pub struct InitCondListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for InitCondListContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for InitCondListContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_initCondList(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_initCondList(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for InitCondListContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_initCondList(self);
	}
}

impl<'input> CustomRuleContext<'input> for InitCondListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_initCondList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_initCondList }
}
antlr_rust::type_id!{InitCondListContextExt<'a>}

impl<'input> InitCondListContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InitCondListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InitCondListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InitCondListContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<InitCondListContextExt<'input>>{

fn syntaxBracketLr(&self) -> Option<Rc<SyntaxBracketLrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn constant_all(&self) ->  Vec<Rc<ConstantContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn constant(&self, i: usize) -> Option<Rc<ConstantContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn syntaxBracketRr(&self) -> Option<Rc<SyntaxBracketRrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn syntaxComma_all(&self) ->  Vec<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn syntaxComma(&self, i: usize) -> Option<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> InitCondListContextAttrs<'input> for InitCondListContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn initCondList(&mut self,)
	-> Result<Rc<InitCondListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InitCondListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 64, RULE_initCondList);
        let mut _localctx: Rc<InitCondListContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule syntaxBracketLr*/
			recog.base.set_state(976);
			recog.syntaxBracketLr()?;

			/*InvokeRule constant*/
			recog.base.set_state(977);
			recog.constant()?;

			recog.base.set_state(983);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				/*InvokeRule syntaxComma*/
				recog.base.set_state(978);
				recog.syntaxComma()?;

				/*InvokeRule constant*/
				recog.base.set_state(979);
				recog.constant()?;

				}
				}
				recog.base.set_state(985);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule syntaxBracketRr*/
			recog.base.set_state(986);
			recog.syntaxBracketRr()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- orReplace ----------------
pub type OrReplaceContextAll<'input> = OrReplaceContext<'input>;


pub type OrReplaceContext<'input> = BaseParserRuleContext<'input,OrReplaceContextExt<'input>>;

#[derive(Clone)]
pub struct OrReplaceContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for OrReplaceContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for OrReplaceContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_orReplace(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_orReplace(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for OrReplaceContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_orReplace(self);
	}
}

impl<'input> CustomRuleContext<'input> for OrReplaceContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_orReplace }
	//fn type_rule_index() -> usize where Self: Sized { RULE_orReplace }
}
antlr_rust::type_id!{OrReplaceContextExt<'a>}

impl<'input> OrReplaceContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<OrReplaceContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,OrReplaceContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait OrReplaceContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<OrReplaceContextExt<'input>>{

fn kwOr(&self) -> Option<Rc<KwOrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwReplace(&self) -> Option<Rc<KwReplaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> OrReplaceContextAttrs<'input> for OrReplaceContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn orReplace(&mut self,)
	-> Result<Rc<OrReplaceContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = OrReplaceContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 66, RULE_orReplace);
        let mut _localctx: Rc<OrReplaceContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwOr*/
			recog.base.set_state(988);
			recog.kwOr()?;

			/*InvokeRule kwReplace*/
			recog.base.set_state(989);
			recog.kwReplace()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- alterUser ----------------
pub type AlterUserContextAll<'input> = AlterUserContext<'input>;


pub type AlterUserContext<'input> = BaseParserRuleContext<'input,AlterUserContextExt<'input>>;

#[derive(Clone)]
pub struct AlterUserContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for AlterUserContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for AlterUserContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_alterUser(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_alterUser(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for AlterUserContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_alterUser(self);
	}
}

impl<'input> CustomRuleContext<'input> for AlterUserContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_alterUser }
	//fn type_rule_index() -> usize where Self: Sized { RULE_alterUser }
}
antlr_rust::type_id!{AlterUserContextExt<'a>}

impl<'input> AlterUserContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AlterUserContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AlterUserContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AlterUserContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<AlterUserContextExt<'input>>{

fn kwAlter(&self) -> Option<Rc<KwAlterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwUser(&self) -> Option<Rc<KwUserContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn user(&self) -> Option<Rc<UserContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwWith(&self) -> Option<Rc<KwWithContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn userPassword(&self) -> Option<Rc<UserPasswordContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn userSuperUser(&self) -> Option<Rc<UserSuperUserContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AlterUserContextAttrs<'input> for AlterUserContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn alterUser(&mut self,)
	-> Result<Rc<AlterUserContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AlterUserContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 68, RULE_alterUser);
        let mut _localctx: Rc<AlterUserContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwAlter*/
			recog.base.set_state(991);
			recog.kwAlter()?;

			/*InvokeRule kwUser*/
			recog.base.set_state(992);
			recog.kwUser()?;

			/*InvokeRule user*/
			recog.base.set_state(993);
			recog.user()?;

			/*InvokeRule kwWith*/
			recog.base.set_state(994);
			recog.kwWith()?;

			/*InvokeRule userPassword*/
			recog.base.set_state(995);
			recog.userPassword()?;

			recog.base.set_state(997);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_NOSUPERUSER || _la==K_SUPERUSER {
				{
				/*InvokeRule userSuperUser*/
				recog.base.set_state(996);
				recog.userSuperUser()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- userPassword ----------------
pub type UserPasswordContextAll<'input> = UserPasswordContext<'input>;


pub type UserPasswordContext<'input> = BaseParserRuleContext<'input,UserPasswordContextExt<'input>>;

#[derive(Clone)]
pub struct UserPasswordContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for UserPasswordContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for UserPasswordContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_userPassword(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_userPassword(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for UserPasswordContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_userPassword(self);
	}
}

impl<'input> CustomRuleContext<'input> for UserPasswordContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_userPassword }
	//fn type_rule_index() -> usize where Self: Sized { RULE_userPassword }
}
antlr_rust::type_id!{UserPasswordContextExt<'a>}

impl<'input> UserPasswordContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UserPasswordContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UserPasswordContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UserPasswordContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<UserPasswordContextExt<'input>>{

fn kwPassword(&self) -> Option<Rc<KwPasswordContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn stringLiteral(&self) -> Option<Rc<StringLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UserPasswordContextAttrs<'input> for UserPasswordContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn userPassword(&mut self,)
	-> Result<Rc<UserPasswordContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UserPasswordContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 70, RULE_userPassword);
        let mut _localctx: Rc<UserPasswordContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwPassword*/
			recog.base.set_state(999);
			recog.kwPassword()?;

			/*InvokeRule stringLiteral*/
			recog.base.set_state(1000);
			recog.stringLiteral()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- userSuperUser ----------------
pub type UserSuperUserContextAll<'input> = UserSuperUserContext<'input>;


pub type UserSuperUserContext<'input> = BaseParserRuleContext<'input,UserSuperUserContextExt<'input>>;

#[derive(Clone)]
pub struct UserSuperUserContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for UserSuperUserContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for UserSuperUserContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_userSuperUser(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_userSuperUser(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for UserSuperUserContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_userSuperUser(self);
	}
}

impl<'input> CustomRuleContext<'input> for UserSuperUserContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_userSuperUser }
	//fn type_rule_index() -> usize where Self: Sized { RULE_userSuperUser }
}
antlr_rust::type_id!{UserSuperUserContextExt<'a>}

impl<'input> UserSuperUserContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UserSuperUserContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UserSuperUserContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UserSuperUserContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<UserSuperUserContextExt<'input>>{

fn kwSuperuser(&self) -> Option<Rc<KwSuperuserContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwNosuperuser(&self) -> Option<Rc<KwNosuperuserContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UserSuperUserContextAttrs<'input> for UserSuperUserContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn userSuperUser(&mut self,)
	-> Result<Rc<UserSuperUserContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UserSuperUserContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 72, RULE_userSuperUser);
        let mut _localctx: Rc<UserSuperUserContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1004);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 K_SUPERUSER 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule kwSuperuser*/
					recog.base.set_state(1002);
					recog.kwSuperuser()?;

					}
				}

			 K_NOSUPERUSER 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule kwNosuperuser*/
					recog.base.set_state(1003);
					recog.kwNosuperuser()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- alterType ----------------
pub type AlterTypeContextAll<'input> = AlterTypeContext<'input>;


pub type AlterTypeContext<'input> = BaseParserRuleContext<'input,AlterTypeContextExt<'input>>;

#[derive(Clone)]
pub struct AlterTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for AlterTypeContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for AlterTypeContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_alterType(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_alterType(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for AlterTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_alterType(self);
	}
}

impl<'input> CustomRuleContext<'input> for AlterTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_alterType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_alterType }
}
antlr_rust::type_id!{AlterTypeContextExt<'a>}

impl<'input> AlterTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AlterTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AlterTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AlterTypeContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<AlterTypeContextExt<'input>>{

fn kwAlter(&self) -> Option<Rc<KwAlterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwType(&self) -> Option<Rc<KwTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn type_(&self) -> Option<Rc<Type_ContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn alterTypeOperation(&self) -> Option<Rc<AlterTypeOperationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn keyspace(&self) -> Option<Rc<KeyspaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}

}

impl<'input> AlterTypeContextAttrs<'input> for AlterTypeContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn alterType(&mut self,)
	-> Result<Rc<AlterTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AlterTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 74, RULE_alterType);
        let mut _localctx: Rc<AlterTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwAlter*/
			recog.base.set_state(1006);
			recog.kwAlter()?;

			/*InvokeRule kwType*/
			recog.base.set_state(1007);
			recog.kwType()?;

			recog.base.set_state(1011);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(53,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule keyspace*/
					recog.base.set_state(1008);
					recog.keyspace()?;

					recog.base.set_state(1009);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			/*InvokeRule type_*/
			recog.base.set_state(1013);
			recog.type_()?;

			/*InvokeRule alterTypeOperation*/
			recog.base.set_state(1014);
			recog.alterTypeOperation()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- alterTypeOperation ----------------
pub type AlterTypeOperationContextAll<'input> = AlterTypeOperationContext<'input>;


pub type AlterTypeOperationContext<'input> = BaseParserRuleContext<'input,AlterTypeOperationContextExt<'input>>;

#[derive(Clone)]
pub struct AlterTypeOperationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for AlterTypeOperationContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for AlterTypeOperationContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_alterTypeOperation(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_alterTypeOperation(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for AlterTypeOperationContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_alterTypeOperation(self);
	}
}

impl<'input> CustomRuleContext<'input> for AlterTypeOperationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_alterTypeOperation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_alterTypeOperation }
}
antlr_rust::type_id!{AlterTypeOperationContextExt<'a>}

impl<'input> AlterTypeOperationContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AlterTypeOperationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AlterTypeOperationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AlterTypeOperationContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<AlterTypeOperationContextExt<'input>>{

fn alterTypeAlterType(&self) -> Option<Rc<AlterTypeAlterTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn alterTypeAdd(&self) -> Option<Rc<AlterTypeAddContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn alterTypeRename(&self) -> Option<Rc<AlterTypeRenameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AlterTypeOperationContextAttrs<'input> for AlterTypeOperationContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn alterTypeOperation(&mut self,)
	-> Result<Rc<AlterTypeOperationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AlterTypeOperationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 76, RULE_alterTypeOperation);
        let mut _localctx: Rc<AlterTypeOperationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1019);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 K_ALTER 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule alterTypeAlterType*/
					recog.base.set_state(1016);
					recog.alterTypeAlterType()?;

					}
				}

			 K_ADD 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule alterTypeAdd*/
					recog.base.set_state(1017);
					recog.alterTypeAdd()?;

					}
				}

			 K_RENAME 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule alterTypeRename*/
					recog.base.set_state(1018);
					recog.alterTypeRename()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- alterTypeRename ----------------
pub type AlterTypeRenameContextAll<'input> = AlterTypeRenameContext<'input>;


pub type AlterTypeRenameContext<'input> = BaseParserRuleContext<'input,AlterTypeRenameContextExt<'input>>;

#[derive(Clone)]
pub struct AlterTypeRenameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for AlterTypeRenameContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for AlterTypeRenameContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_alterTypeRename(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_alterTypeRename(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for AlterTypeRenameContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_alterTypeRename(self);
	}
}

impl<'input> CustomRuleContext<'input> for AlterTypeRenameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_alterTypeRename }
	//fn type_rule_index() -> usize where Self: Sized { RULE_alterTypeRename }
}
antlr_rust::type_id!{AlterTypeRenameContextExt<'a>}

impl<'input> AlterTypeRenameContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AlterTypeRenameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AlterTypeRenameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AlterTypeRenameContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<AlterTypeRenameContextExt<'input>>{

fn kwRename(&self) -> Option<Rc<KwRenameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn alterTypeRenameList(&self) -> Option<Rc<AlterTypeRenameListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AlterTypeRenameContextAttrs<'input> for AlterTypeRenameContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn alterTypeRename(&mut self,)
	-> Result<Rc<AlterTypeRenameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AlterTypeRenameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 78, RULE_alterTypeRename);
        let mut _localctx: Rc<AlterTypeRenameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwRename*/
			recog.base.set_state(1021);
			recog.kwRename()?;

			/*InvokeRule alterTypeRenameList*/
			recog.base.set_state(1022);
			recog.alterTypeRenameList()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- alterTypeRenameList ----------------
pub type AlterTypeRenameListContextAll<'input> = AlterTypeRenameListContext<'input>;


pub type AlterTypeRenameListContext<'input> = BaseParserRuleContext<'input,AlterTypeRenameListContextExt<'input>>;

#[derive(Clone)]
pub struct AlterTypeRenameListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for AlterTypeRenameListContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for AlterTypeRenameListContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_alterTypeRenameList(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_alterTypeRenameList(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for AlterTypeRenameListContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_alterTypeRenameList(self);
	}
}

impl<'input> CustomRuleContext<'input> for AlterTypeRenameListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_alterTypeRenameList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_alterTypeRenameList }
}
antlr_rust::type_id!{AlterTypeRenameListContextExt<'a>}

impl<'input> AlterTypeRenameListContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AlterTypeRenameListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AlterTypeRenameListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AlterTypeRenameListContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<AlterTypeRenameListContextExt<'input>>{

fn alterTypeRenameItem_all(&self) ->  Vec<Rc<AlterTypeRenameItemContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn alterTypeRenameItem(&self, i: usize) -> Option<Rc<AlterTypeRenameItemContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn kwAnd_all(&self) ->  Vec<Rc<KwAndContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn kwAnd(&self, i: usize) -> Option<Rc<KwAndContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> AlterTypeRenameListContextAttrs<'input> for AlterTypeRenameListContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn alterTypeRenameList(&mut self,)
	-> Result<Rc<AlterTypeRenameListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AlterTypeRenameListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 80, RULE_alterTypeRenameList);
        let mut _localctx: Rc<AlterTypeRenameListContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule alterTypeRenameItem*/
			recog.base.set_state(1024);
			recog.alterTypeRenameItem()?;

			recog.base.set_state(1030);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==K_AND {
				{
				{
				/*InvokeRule kwAnd*/
				recog.base.set_state(1025);
				recog.kwAnd()?;

				/*InvokeRule alterTypeRenameItem*/
				recog.base.set_state(1026);
				recog.alterTypeRenameItem()?;

				}
				}
				recog.base.set_state(1032);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- alterTypeRenameItem ----------------
pub type AlterTypeRenameItemContextAll<'input> = AlterTypeRenameItemContext<'input>;


pub type AlterTypeRenameItemContext<'input> = BaseParserRuleContext<'input,AlterTypeRenameItemContextExt<'input>>;

#[derive(Clone)]
pub struct AlterTypeRenameItemContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for AlterTypeRenameItemContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for AlterTypeRenameItemContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_alterTypeRenameItem(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_alterTypeRenameItem(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for AlterTypeRenameItemContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_alterTypeRenameItem(self);
	}
}

impl<'input> CustomRuleContext<'input> for AlterTypeRenameItemContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_alterTypeRenameItem }
	//fn type_rule_index() -> usize where Self: Sized { RULE_alterTypeRenameItem }
}
antlr_rust::type_id!{AlterTypeRenameItemContextExt<'a>}

impl<'input> AlterTypeRenameItemContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AlterTypeRenameItemContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AlterTypeRenameItemContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AlterTypeRenameItemContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<AlterTypeRenameItemContextExt<'input>>{

fn column_all(&self) ->  Vec<Rc<ColumnContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn column(&self, i: usize) -> Option<Rc<ColumnContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn kwTo(&self) -> Option<Rc<KwToContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AlterTypeRenameItemContextAttrs<'input> for AlterTypeRenameItemContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn alterTypeRenameItem(&mut self,)
	-> Result<Rc<AlterTypeRenameItemContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AlterTypeRenameItemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 82, RULE_alterTypeRenameItem);
        let mut _localctx: Rc<AlterTypeRenameItemContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule column*/
			recog.base.set_state(1033);
			recog.column()?;

			/*InvokeRule kwTo*/
			recog.base.set_state(1034);
			recog.kwTo()?;

			/*InvokeRule column*/
			recog.base.set_state(1035);
			recog.column()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- alterTypeAdd ----------------
pub type AlterTypeAddContextAll<'input> = AlterTypeAddContext<'input>;


pub type AlterTypeAddContext<'input> = BaseParserRuleContext<'input,AlterTypeAddContextExt<'input>>;

#[derive(Clone)]
pub struct AlterTypeAddContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for AlterTypeAddContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for AlterTypeAddContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_alterTypeAdd(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_alterTypeAdd(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for AlterTypeAddContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_alterTypeAdd(self);
	}
}

impl<'input> CustomRuleContext<'input> for AlterTypeAddContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_alterTypeAdd }
	//fn type_rule_index() -> usize where Self: Sized { RULE_alterTypeAdd }
}
antlr_rust::type_id!{AlterTypeAddContextExt<'a>}

impl<'input> AlterTypeAddContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AlterTypeAddContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AlterTypeAddContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AlterTypeAddContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<AlterTypeAddContextExt<'input>>{

fn kwAdd(&self) -> Option<Rc<KwAddContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn column_all(&self) ->  Vec<Rc<ColumnContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn column(&self, i: usize) -> Option<Rc<ColumnContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn dataType_all(&self) ->  Vec<Rc<DataTypeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn dataType(&self, i: usize) -> Option<Rc<DataTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn syntaxComma_all(&self) ->  Vec<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn syntaxComma(&self, i: usize) -> Option<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> AlterTypeAddContextAttrs<'input> for AlterTypeAddContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn alterTypeAdd(&mut self,)
	-> Result<Rc<AlterTypeAddContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AlterTypeAddContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 84, RULE_alterTypeAdd);
        let mut _localctx: Rc<AlterTypeAddContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwAdd*/
			recog.base.set_state(1037);
			recog.kwAdd()?;

			/*InvokeRule column*/
			recog.base.set_state(1038);
			recog.column()?;

			/*InvokeRule dataType*/
			recog.base.set_state(1039);
			recog.dataType()?;

			recog.base.set_state(1046);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				/*InvokeRule syntaxComma*/
				recog.base.set_state(1040);
				recog.syntaxComma()?;

				/*InvokeRule column*/
				recog.base.set_state(1041);
				recog.column()?;

				/*InvokeRule dataType*/
				recog.base.set_state(1042);
				recog.dataType()?;

				}
				}
				recog.base.set_state(1048);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- alterTypeAlterType ----------------
pub type AlterTypeAlterTypeContextAll<'input> = AlterTypeAlterTypeContext<'input>;


pub type AlterTypeAlterTypeContext<'input> = BaseParserRuleContext<'input,AlterTypeAlterTypeContextExt<'input>>;

#[derive(Clone)]
pub struct AlterTypeAlterTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for AlterTypeAlterTypeContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for AlterTypeAlterTypeContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_alterTypeAlterType(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_alterTypeAlterType(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for AlterTypeAlterTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_alterTypeAlterType(self);
	}
}

impl<'input> CustomRuleContext<'input> for AlterTypeAlterTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_alterTypeAlterType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_alterTypeAlterType }
}
antlr_rust::type_id!{AlterTypeAlterTypeContextExt<'a>}

impl<'input> AlterTypeAlterTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AlterTypeAlterTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AlterTypeAlterTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AlterTypeAlterTypeContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<AlterTypeAlterTypeContextExt<'input>>{

fn kwAlter(&self) -> Option<Rc<KwAlterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn column(&self) -> Option<Rc<ColumnContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwType(&self) -> Option<Rc<KwTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn dataType(&self) -> Option<Rc<DataTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AlterTypeAlterTypeContextAttrs<'input> for AlterTypeAlterTypeContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn alterTypeAlterType(&mut self,)
	-> Result<Rc<AlterTypeAlterTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AlterTypeAlterTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 86, RULE_alterTypeAlterType);
        let mut _localctx: Rc<AlterTypeAlterTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwAlter*/
			recog.base.set_state(1049);
			recog.kwAlter()?;

			/*InvokeRule column*/
			recog.base.set_state(1050);
			recog.column()?;

			/*InvokeRule kwType*/
			recog.base.set_state(1051);
			recog.kwType()?;

			/*InvokeRule dataType*/
			recog.base.set_state(1052);
			recog.dataType()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- alterTable ----------------
pub type AlterTableContextAll<'input> = AlterTableContext<'input>;


pub type AlterTableContext<'input> = BaseParserRuleContext<'input,AlterTableContextExt<'input>>;

#[derive(Clone)]
pub struct AlterTableContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for AlterTableContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for AlterTableContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_alterTable(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_alterTable(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for AlterTableContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_alterTable(self);
	}
}

impl<'input> CustomRuleContext<'input> for AlterTableContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_alterTable }
	//fn type_rule_index() -> usize where Self: Sized { RULE_alterTable }
}
antlr_rust::type_id!{AlterTableContextExt<'a>}

impl<'input> AlterTableContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AlterTableContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AlterTableContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AlterTableContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<AlterTableContextExt<'input>>{

fn kwAlter(&self) -> Option<Rc<KwAlterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwTable(&self) -> Option<Rc<KwTableContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn table(&self) -> Option<Rc<TableContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn alterTableOperation(&self) -> Option<Rc<AlterTableOperationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn keyspace(&self) -> Option<Rc<KeyspaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}

}

impl<'input> AlterTableContextAttrs<'input> for AlterTableContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn alterTable(&mut self,)
	-> Result<Rc<AlterTableContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AlterTableContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 88, RULE_alterTable);
        let mut _localctx: Rc<AlterTableContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwAlter*/
			recog.base.set_state(1054);
			recog.kwAlter()?;

			/*InvokeRule kwTable*/
			recog.base.set_state(1055);
			recog.kwTable()?;

			recog.base.set_state(1059);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(57,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule keyspace*/
					recog.base.set_state(1056);
					recog.keyspace()?;

					recog.base.set_state(1057);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			/*InvokeRule table*/
			recog.base.set_state(1061);
			recog.table()?;

			/*InvokeRule alterTableOperation*/
			recog.base.set_state(1062);
			recog.alterTableOperation()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- alterTableOperation ----------------
pub type AlterTableOperationContextAll<'input> = AlterTableOperationContext<'input>;


pub type AlterTableOperationContext<'input> = BaseParserRuleContext<'input,AlterTableOperationContextExt<'input>>;

#[derive(Clone)]
pub struct AlterTableOperationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for AlterTableOperationContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for AlterTableOperationContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_alterTableOperation(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_alterTableOperation(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for AlterTableOperationContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_alterTableOperation(self);
	}
}

impl<'input> CustomRuleContext<'input> for AlterTableOperationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_alterTableOperation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_alterTableOperation }
}
antlr_rust::type_id!{AlterTableOperationContextExt<'a>}

impl<'input> AlterTableOperationContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AlterTableOperationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AlterTableOperationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AlterTableOperationContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<AlterTableOperationContextExt<'input>>{

fn alterTableAdd(&self) -> Option<Rc<AlterTableAddContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn alterTableDropColumns(&self) -> Option<Rc<AlterTableDropColumnsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn alterTableDropCompactStorage(&self) -> Option<Rc<AlterTableDropCompactStorageContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn alterTableRename(&self) -> Option<Rc<AlterTableRenameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn alterTableWith(&self) -> Option<Rc<AlterTableWithContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AlterTableOperationContextAttrs<'input> for AlterTableOperationContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn alterTableOperation(&mut self,)
	-> Result<Rc<AlterTableOperationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AlterTableOperationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 90, RULE_alterTableOperation);
        let mut _localctx: Rc<AlterTableOperationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1070);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(58,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule alterTableAdd*/
					recog.base.set_state(1064);
					recog.alterTableAdd()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule alterTableDropColumns*/
					recog.base.set_state(1065);
					recog.alterTableDropColumns()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule alterTableDropColumns*/
					recog.base.set_state(1066);
					recog.alterTableDropColumns()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule alterTableDropCompactStorage*/
					recog.base.set_state(1067);
					recog.alterTableDropCompactStorage()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule alterTableRename*/
					recog.base.set_state(1068);
					recog.alterTableRename()?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule alterTableWith*/
					recog.base.set_state(1069);
					recog.alterTableWith()?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- alterTableWith ----------------
pub type AlterTableWithContextAll<'input> = AlterTableWithContext<'input>;


pub type AlterTableWithContext<'input> = BaseParserRuleContext<'input,AlterTableWithContextExt<'input>>;

#[derive(Clone)]
pub struct AlterTableWithContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for AlterTableWithContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for AlterTableWithContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_alterTableWith(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_alterTableWith(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for AlterTableWithContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_alterTableWith(self);
	}
}

impl<'input> CustomRuleContext<'input> for AlterTableWithContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_alterTableWith }
	//fn type_rule_index() -> usize where Self: Sized { RULE_alterTableWith }
}
antlr_rust::type_id!{AlterTableWithContextExt<'a>}

impl<'input> AlterTableWithContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AlterTableWithContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AlterTableWithContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AlterTableWithContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<AlterTableWithContextExt<'input>>{

fn kwWith(&self) -> Option<Rc<KwWithContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn tableOptions(&self) -> Option<Rc<TableOptionsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AlterTableWithContextAttrs<'input> for AlterTableWithContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn alterTableWith(&mut self,)
	-> Result<Rc<AlterTableWithContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AlterTableWithContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 92, RULE_alterTableWith);
        let mut _localctx: Rc<AlterTableWithContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwWith*/
			recog.base.set_state(1072);
			recog.kwWith()?;

			/*InvokeRule tableOptions*/
			recog.base.set_state(1073);
			recog.tableOptions()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- alterTableRename ----------------
pub type AlterTableRenameContextAll<'input> = AlterTableRenameContext<'input>;


pub type AlterTableRenameContext<'input> = BaseParserRuleContext<'input,AlterTableRenameContextExt<'input>>;

#[derive(Clone)]
pub struct AlterTableRenameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for AlterTableRenameContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for AlterTableRenameContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_alterTableRename(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_alterTableRename(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for AlterTableRenameContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_alterTableRename(self);
	}
}

impl<'input> CustomRuleContext<'input> for AlterTableRenameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_alterTableRename }
	//fn type_rule_index() -> usize where Self: Sized { RULE_alterTableRename }
}
antlr_rust::type_id!{AlterTableRenameContextExt<'a>}

impl<'input> AlterTableRenameContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AlterTableRenameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AlterTableRenameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AlterTableRenameContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<AlterTableRenameContextExt<'input>>{

fn kwRename(&self) -> Option<Rc<KwRenameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn column_all(&self) ->  Vec<Rc<ColumnContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn column(&self, i: usize) -> Option<Rc<ColumnContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn kwTo(&self) -> Option<Rc<KwToContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AlterTableRenameContextAttrs<'input> for AlterTableRenameContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn alterTableRename(&mut self,)
	-> Result<Rc<AlterTableRenameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AlterTableRenameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 94, RULE_alterTableRename);
        let mut _localctx: Rc<AlterTableRenameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwRename*/
			recog.base.set_state(1075);
			recog.kwRename()?;

			/*InvokeRule column*/
			recog.base.set_state(1076);
			recog.column()?;

			/*InvokeRule kwTo*/
			recog.base.set_state(1077);
			recog.kwTo()?;

			/*InvokeRule column*/
			recog.base.set_state(1078);
			recog.column()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- alterTableDropCompactStorage ----------------
pub type AlterTableDropCompactStorageContextAll<'input> = AlterTableDropCompactStorageContext<'input>;


pub type AlterTableDropCompactStorageContext<'input> = BaseParserRuleContext<'input,AlterTableDropCompactStorageContextExt<'input>>;

#[derive(Clone)]
pub struct AlterTableDropCompactStorageContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for AlterTableDropCompactStorageContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for AlterTableDropCompactStorageContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_alterTableDropCompactStorage(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_alterTableDropCompactStorage(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for AlterTableDropCompactStorageContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_alterTableDropCompactStorage(self);
	}
}

impl<'input> CustomRuleContext<'input> for AlterTableDropCompactStorageContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_alterTableDropCompactStorage }
	//fn type_rule_index() -> usize where Self: Sized { RULE_alterTableDropCompactStorage }
}
antlr_rust::type_id!{AlterTableDropCompactStorageContextExt<'a>}

impl<'input> AlterTableDropCompactStorageContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AlterTableDropCompactStorageContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AlterTableDropCompactStorageContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AlterTableDropCompactStorageContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<AlterTableDropCompactStorageContextExt<'input>>{

fn kwDrop(&self) -> Option<Rc<KwDropContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwCompact(&self) -> Option<Rc<KwCompactContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwStorage(&self) -> Option<Rc<KwStorageContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AlterTableDropCompactStorageContextAttrs<'input> for AlterTableDropCompactStorageContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn alterTableDropCompactStorage(&mut self,)
	-> Result<Rc<AlterTableDropCompactStorageContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AlterTableDropCompactStorageContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 96, RULE_alterTableDropCompactStorage);
        let mut _localctx: Rc<AlterTableDropCompactStorageContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwDrop*/
			recog.base.set_state(1080);
			recog.kwDrop()?;

			/*InvokeRule kwCompact*/
			recog.base.set_state(1081);
			recog.kwCompact()?;

			/*InvokeRule kwStorage*/
			recog.base.set_state(1082);
			recog.kwStorage()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- alterTableDropColumns ----------------
pub type AlterTableDropColumnsContextAll<'input> = AlterTableDropColumnsContext<'input>;


pub type AlterTableDropColumnsContext<'input> = BaseParserRuleContext<'input,AlterTableDropColumnsContextExt<'input>>;

#[derive(Clone)]
pub struct AlterTableDropColumnsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for AlterTableDropColumnsContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for AlterTableDropColumnsContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_alterTableDropColumns(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_alterTableDropColumns(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for AlterTableDropColumnsContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_alterTableDropColumns(self);
	}
}

impl<'input> CustomRuleContext<'input> for AlterTableDropColumnsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_alterTableDropColumns }
	//fn type_rule_index() -> usize where Self: Sized { RULE_alterTableDropColumns }
}
antlr_rust::type_id!{AlterTableDropColumnsContextExt<'a>}

impl<'input> AlterTableDropColumnsContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AlterTableDropColumnsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AlterTableDropColumnsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AlterTableDropColumnsContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<AlterTableDropColumnsContextExt<'input>>{

fn kwDrop(&self) -> Option<Rc<KwDropContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn alterTableDropColumnList(&self) -> Option<Rc<AlterTableDropColumnListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AlterTableDropColumnsContextAttrs<'input> for AlterTableDropColumnsContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn alterTableDropColumns(&mut self,)
	-> Result<Rc<AlterTableDropColumnsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AlterTableDropColumnsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 98, RULE_alterTableDropColumns);
        let mut _localctx: Rc<AlterTableDropColumnsContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwDrop*/
			recog.base.set_state(1084);
			recog.kwDrop()?;

			/*InvokeRule alterTableDropColumnList*/
			recog.base.set_state(1085);
			recog.alterTableDropColumnList()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- alterTableDropColumnList ----------------
pub type AlterTableDropColumnListContextAll<'input> = AlterTableDropColumnListContext<'input>;


pub type AlterTableDropColumnListContext<'input> = BaseParserRuleContext<'input,AlterTableDropColumnListContextExt<'input>>;

#[derive(Clone)]
pub struct AlterTableDropColumnListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for AlterTableDropColumnListContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for AlterTableDropColumnListContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_alterTableDropColumnList(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_alterTableDropColumnList(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for AlterTableDropColumnListContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_alterTableDropColumnList(self);
	}
}

impl<'input> CustomRuleContext<'input> for AlterTableDropColumnListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_alterTableDropColumnList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_alterTableDropColumnList }
}
antlr_rust::type_id!{AlterTableDropColumnListContextExt<'a>}

impl<'input> AlterTableDropColumnListContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AlterTableDropColumnListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AlterTableDropColumnListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AlterTableDropColumnListContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<AlterTableDropColumnListContextExt<'input>>{

fn column_all(&self) ->  Vec<Rc<ColumnContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn column(&self, i: usize) -> Option<Rc<ColumnContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn syntaxComma_all(&self) ->  Vec<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn syntaxComma(&self, i: usize) -> Option<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> AlterTableDropColumnListContextAttrs<'input> for AlterTableDropColumnListContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn alterTableDropColumnList(&mut self,)
	-> Result<Rc<AlterTableDropColumnListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AlterTableDropColumnListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 100, RULE_alterTableDropColumnList);
        let mut _localctx: Rc<AlterTableDropColumnListContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule column*/
			recog.base.set_state(1087);
			recog.column()?;

			recog.base.set_state(1093);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				/*InvokeRule syntaxComma*/
				recog.base.set_state(1088);
				recog.syntaxComma()?;

				/*InvokeRule column*/
				recog.base.set_state(1089);
				recog.column()?;

				}
				}
				recog.base.set_state(1095);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- alterTableAdd ----------------
pub type AlterTableAddContextAll<'input> = AlterTableAddContext<'input>;


pub type AlterTableAddContext<'input> = BaseParserRuleContext<'input,AlterTableAddContextExt<'input>>;

#[derive(Clone)]
pub struct AlterTableAddContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for AlterTableAddContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for AlterTableAddContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_alterTableAdd(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_alterTableAdd(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for AlterTableAddContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_alterTableAdd(self);
	}
}

impl<'input> CustomRuleContext<'input> for AlterTableAddContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_alterTableAdd }
	//fn type_rule_index() -> usize where Self: Sized { RULE_alterTableAdd }
}
antlr_rust::type_id!{AlterTableAddContextExt<'a>}

impl<'input> AlterTableAddContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AlterTableAddContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AlterTableAddContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AlterTableAddContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<AlterTableAddContextExt<'input>>{

fn kwAdd(&self) -> Option<Rc<KwAddContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn alterTableColumnDefinition(&self) -> Option<Rc<AlterTableColumnDefinitionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AlterTableAddContextAttrs<'input> for AlterTableAddContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn alterTableAdd(&mut self,)
	-> Result<Rc<AlterTableAddContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AlterTableAddContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 102, RULE_alterTableAdd);
        let mut _localctx: Rc<AlterTableAddContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwAdd*/
			recog.base.set_state(1096);
			recog.kwAdd()?;

			/*InvokeRule alterTableColumnDefinition*/
			recog.base.set_state(1097);
			recog.alterTableColumnDefinition()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- alterTableColumnDefinition ----------------
pub type AlterTableColumnDefinitionContextAll<'input> = AlterTableColumnDefinitionContext<'input>;


pub type AlterTableColumnDefinitionContext<'input> = BaseParserRuleContext<'input,AlterTableColumnDefinitionContextExt<'input>>;

#[derive(Clone)]
pub struct AlterTableColumnDefinitionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for AlterTableColumnDefinitionContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for AlterTableColumnDefinitionContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_alterTableColumnDefinition(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_alterTableColumnDefinition(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for AlterTableColumnDefinitionContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_alterTableColumnDefinition(self);
	}
}

impl<'input> CustomRuleContext<'input> for AlterTableColumnDefinitionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_alterTableColumnDefinition }
	//fn type_rule_index() -> usize where Self: Sized { RULE_alterTableColumnDefinition }
}
antlr_rust::type_id!{AlterTableColumnDefinitionContextExt<'a>}

impl<'input> AlterTableColumnDefinitionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AlterTableColumnDefinitionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AlterTableColumnDefinitionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AlterTableColumnDefinitionContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<AlterTableColumnDefinitionContextExt<'input>>{

fn column_all(&self) ->  Vec<Rc<ColumnContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn column(&self, i: usize) -> Option<Rc<ColumnContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn dataType_all(&self) ->  Vec<Rc<DataTypeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn dataType(&self, i: usize) -> Option<Rc<DataTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn syntaxComma_all(&self) ->  Vec<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn syntaxComma(&self, i: usize) -> Option<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> AlterTableColumnDefinitionContextAttrs<'input> for AlterTableColumnDefinitionContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn alterTableColumnDefinition(&mut self,)
	-> Result<Rc<AlterTableColumnDefinitionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AlterTableColumnDefinitionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 104, RULE_alterTableColumnDefinition);
        let mut _localctx: Rc<AlterTableColumnDefinitionContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule column*/
			recog.base.set_state(1099);
			recog.column()?;

			/*InvokeRule dataType*/
			recog.base.set_state(1100);
			recog.dataType()?;

			recog.base.set_state(1107);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				/*InvokeRule syntaxComma*/
				recog.base.set_state(1101);
				recog.syntaxComma()?;

				/*InvokeRule column*/
				recog.base.set_state(1102);
				recog.column()?;

				/*InvokeRule dataType*/
				recog.base.set_state(1103);
				recog.dataType()?;

				}
				}
				recog.base.set_state(1109);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- alterRole ----------------
pub type AlterRoleContextAll<'input> = AlterRoleContext<'input>;


pub type AlterRoleContext<'input> = BaseParserRuleContext<'input,AlterRoleContextExt<'input>>;

#[derive(Clone)]
pub struct AlterRoleContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for AlterRoleContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for AlterRoleContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_alterRole(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_alterRole(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for AlterRoleContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_alterRole(self);
	}
}

impl<'input> CustomRuleContext<'input> for AlterRoleContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_alterRole }
	//fn type_rule_index() -> usize where Self: Sized { RULE_alterRole }
}
antlr_rust::type_id!{AlterRoleContextExt<'a>}

impl<'input> AlterRoleContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AlterRoleContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AlterRoleContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AlterRoleContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<AlterRoleContextExt<'input>>{

fn kwAlter(&self) -> Option<Rc<KwAlterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwRole(&self) -> Option<Rc<KwRoleContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn role(&self) -> Option<Rc<RoleContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn roleWith(&self) -> Option<Rc<RoleWithContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AlterRoleContextAttrs<'input> for AlterRoleContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn alterRole(&mut self,)
	-> Result<Rc<AlterRoleContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AlterRoleContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 106, RULE_alterRole);
        let mut _localctx: Rc<AlterRoleContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwAlter*/
			recog.base.set_state(1110);
			recog.kwAlter()?;

			/*InvokeRule kwRole*/
			recog.base.set_state(1111);
			recog.kwRole()?;

			/*InvokeRule role*/
			recog.base.set_state(1112);
			recog.role()?;

			recog.base.set_state(1114);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_WITH {
				{
				/*InvokeRule roleWith*/
				recog.base.set_state(1113);
				recog.roleWith()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- roleWith ----------------
pub type RoleWithContextAll<'input> = RoleWithContext<'input>;


pub type RoleWithContext<'input> = BaseParserRuleContext<'input,RoleWithContextExt<'input>>;

#[derive(Clone)]
pub struct RoleWithContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for RoleWithContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for RoleWithContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_roleWith(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_roleWith(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for RoleWithContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_roleWith(self);
	}
}

impl<'input> CustomRuleContext<'input> for RoleWithContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_roleWith }
	//fn type_rule_index() -> usize where Self: Sized { RULE_roleWith }
}
antlr_rust::type_id!{RoleWithContextExt<'a>}

impl<'input> RoleWithContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RoleWithContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RoleWithContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RoleWithContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<RoleWithContextExt<'input>>{

fn kwWith(&self) -> Option<Rc<KwWithContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn roleWithOptions_all(&self) ->  Vec<Rc<RoleWithOptionsContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn roleWithOptions(&self, i: usize) -> Option<Rc<RoleWithOptionsContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn kwAnd_all(&self) ->  Vec<Rc<KwAndContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn kwAnd(&self, i: usize) -> Option<Rc<KwAndContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> RoleWithContextAttrs<'input> for RoleWithContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn roleWith(&mut self,)
	-> Result<Rc<RoleWithContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RoleWithContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 108, RULE_roleWith);
        let mut _localctx: Rc<RoleWithContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwWith*/
			recog.base.set_state(1116);
			recog.kwWith()?;

			{
			/*InvokeRule roleWithOptions*/
			recog.base.set_state(1117);
			recog.roleWithOptions()?;

			recog.base.set_state(1123);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==K_AND {
				{
				{
				/*InvokeRule kwAnd*/
				recog.base.set_state(1118);
				recog.kwAnd()?;

				/*InvokeRule roleWithOptions*/
				recog.base.set_state(1119);
				recog.roleWithOptions()?;

				}
				}
				recog.base.set_state(1125);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- roleWithOptions ----------------
pub type RoleWithOptionsContextAll<'input> = RoleWithOptionsContext<'input>;


pub type RoleWithOptionsContext<'input> = BaseParserRuleContext<'input,RoleWithOptionsContextExt<'input>>;

#[derive(Clone)]
pub struct RoleWithOptionsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for RoleWithOptionsContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for RoleWithOptionsContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_roleWithOptions(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_roleWithOptions(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for RoleWithOptionsContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_roleWithOptions(self);
	}
}

impl<'input> CustomRuleContext<'input> for RoleWithOptionsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_roleWithOptions }
	//fn type_rule_index() -> usize where Self: Sized { RULE_roleWithOptions }
}
antlr_rust::type_id!{RoleWithOptionsContextExt<'a>}

impl<'input> RoleWithOptionsContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RoleWithOptionsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RoleWithOptionsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RoleWithOptionsContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<RoleWithOptionsContextExt<'input>>{

fn kwPassword(&self) -> Option<Rc<KwPasswordContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token OPERATOR_EQ
/// Returns `None` if there is no child corresponding to token OPERATOR_EQ
fn OPERATOR_EQ(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OPERATOR_EQ, 0)
}
fn stringLiteral(&self) -> Option<Rc<StringLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwLogin(&self) -> Option<Rc<KwLoginContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn booleanLiteral(&self) -> Option<Rc<BooleanLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwSuperuser(&self) -> Option<Rc<KwSuperuserContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwOptions(&self) -> Option<Rc<KwOptionsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn optionHash(&self) -> Option<Rc<OptionHashContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RoleWithOptionsContextAttrs<'input> for RoleWithOptionsContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn roleWithOptions(&mut self,)
	-> Result<Rc<RoleWithOptionsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RoleWithOptionsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 110, RULE_roleWithOptions);
        let mut _localctx: Rc<RoleWithOptionsContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1142);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 K_PASSWORD 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule kwPassword*/
					recog.base.set_state(1126);
					recog.kwPassword()?;

					recog.base.set_state(1127);
					recog.base.match_token(OPERATOR_EQ,&mut recog.err_handler)?;

					/*InvokeRule stringLiteral*/
					recog.base.set_state(1128);
					recog.stringLiteral()?;

					}
				}

			 K_LOGIN 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule kwLogin*/
					recog.base.set_state(1130);
					recog.kwLogin()?;

					recog.base.set_state(1131);
					recog.base.match_token(OPERATOR_EQ,&mut recog.err_handler)?;

					/*InvokeRule booleanLiteral*/
					recog.base.set_state(1132);
					recog.booleanLiteral()?;

					}
				}

			 K_SUPERUSER 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule kwSuperuser*/
					recog.base.set_state(1134);
					recog.kwSuperuser()?;

					recog.base.set_state(1135);
					recog.base.match_token(OPERATOR_EQ,&mut recog.err_handler)?;

					/*InvokeRule booleanLiteral*/
					recog.base.set_state(1136);
					recog.booleanLiteral()?;

					}
				}

			 K_OPTIONS 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule kwOptions*/
					recog.base.set_state(1138);
					recog.kwOptions()?;

					recog.base.set_state(1139);
					recog.base.match_token(OPERATOR_EQ,&mut recog.err_handler)?;

					/*InvokeRule optionHash*/
					recog.base.set_state(1140);
					recog.optionHash()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- alterMaterializedView ----------------
pub type AlterMaterializedViewContextAll<'input> = AlterMaterializedViewContext<'input>;


pub type AlterMaterializedViewContext<'input> = BaseParserRuleContext<'input,AlterMaterializedViewContextExt<'input>>;

#[derive(Clone)]
pub struct AlterMaterializedViewContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for AlterMaterializedViewContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for AlterMaterializedViewContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_alterMaterializedView(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_alterMaterializedView(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for AlterMaterializedViewContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_alterMaterializedView(self);
	}
}

impl<'input> CustomRuleContext<'input> for AlterMaterializedViewContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_alterMaterializedView }
	//fn type_rule_index() -> usize where Self: Sized { RULE_alterMaterializedView }
}
antlr_rust::type_id!{AlterMaterializedViewContextExt<'a>}

impl<'input> AlterMaterializedViewContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AlterMaterializedViewContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AlterMaterializedViewContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AlterMaterializedViewContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<AlterMaterializedViewContextExt<'input>>{

fn kwAlter(&self) -> Option<Rc<KwAlterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwMaterialized(&self) -> Option<Rc<KwMaterializedContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwView(&self) -> Option<Rc<KwViewContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn materializedView(&self) -> Option<Rc<MaterializedViewContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn keyspace(&self) -> Option<Rc<KeyspaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
fn kwWith(&self) -> Option<Rc<KwWithContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn tableOptions(&self) -> Option<Rc<TableOptionsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AlterMaterializedViewContextAttrs<'input> for AlterMaterializedViewContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn alterMaterializedView(&mut self,)
	-> Result<Rc<AlterMaterializedViewContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AlterMaterializedViewContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 112, RULE_alterMaterializedView);
        let mut _localctx: Rc<AlterMaterializedViewContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwAlter*/
			recog.base.set_state(1144);
			recog.kwAlter()?;

			/*InvokeRule kwMaterialized*/
			recog.base.set_state(1145);
			recog.kwMaterialized()?;

			/*InvokeRule kwView*/
			recog.base.set_state(1146);
			recog.kwView()?;

			recog.base.set_state(1150);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(64,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule keyspace*/
					recog.base.set_state(1147);
					recog.keyspace()?;

					recog.base.set_state(1148);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			/*InvokeRule materializedView*/
			recog.base.set_state(1152);
			recog.materializedView()?;

			recog.base.set_state(1156);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_WITH {
				{
				/*InvokeRule kwWith*/
				recog.base.set_state(1153);
				recog.kwWith()?;

				/*InvokeRule tableOptions*/
				recog.base.set_state(1154);
				recog.tableOptions()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- dropUser ----------------
pub type DropUserContextAll<'input> = DropUserContext<'input>;


pub type DropUserContext<'input> = BaseParserRuleContext<'input,DropUserContextExt<'input>>;

#[derive(Clone)]
pub struct DropUserContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for DropUserContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for DropUserContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_dropUser(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_dropUser(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for DropUserContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_dropUser(self);
	}
}

impl<'input> CustomRuleContext<'input> for DropUserContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_dropUser }
	//fn type_rule_index() -> usize where Self: Sized { RULE_dropUser }
}
antlr_rust::type_id!{DropUserContextExt<'a>}

impl<'input> DropUserContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DropUserContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DropUserContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DropUserContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<DropUserContextExt<'input>>{

fn kwDrop(&self) -> Option<Rc<KwDropContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwUser(&self) -> Option<Rc<KwUserContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn user(&self) -> Option<Rc<UserContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifExist(&self) -> Option<Rc<IfExistContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DropUserContextAttrs<'input> for DropUserContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn dropUser(&mut self,)
	-> Result<Rc<DropUserContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DropUserContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 114, RULE_dropUser);
        let mut _localctx: Rc<DropUserContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwDrop*/
			recog.base.set_state(1158);
			recog.kwDrop()?;

			/*InvokeRule kwUser*/
			recog.base.set_state(1159);
			recog.kwUser()?;

			recog.base.set_state(1161);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_IF {
				{
				/*InvokeRule ifExist*/
				recog.base.set_state(1160);
				recog.ifExist()?;

				}
			}

			/*InvokeRule user*/
			recog.base.set_state(1163);
			recog.user()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- dropType ----------------
pub type DropTypeContextAll<'input> = DropTypeContext<'input>;


pub type DropTypeContext<'input> = BaseParserRuleContext<'input,DropTypeContextExt<'input>>;

#[derive(Clone)]
pub struct DropTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for DropTypeContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for DropTypeContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_dropType(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_dropType(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for DropTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_dropType(self);
	}
}

impl<'input> CustomRuleContext<'input> for DropTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_dropType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_dropType }
}
antlr_rust::type_id!{DropTypeContextExt<'a>}

impl<'input> DropTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DropTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DropTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DropTypeContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<DropTypeContextExt<'input>>{

fn kwDrop(&self) -> Option<Rc<KwDropContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwType(&self) -> Option<Rc<KwTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn type_(&self) -> Option<Rc<Type_ContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifExist(&self) -> Option<Rc<IfExistContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn keyspace(&self) -> Option<Rc<KeyspaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}

}

impl<'input> DropTypeContextAttrs<'input> for DropTypeContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn dropType(&mut self,)
	-> Result<Rc<DropTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DropTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 116, RULE_dropType);
        let mut _localctx: Rc<DropTypeContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwDrop*/
			recog.base.set_state(1165);
			recog.kwDrop()?;

			/*InvokeRule kwType*/
			recog.base.set_state(1166);
			recog.kwType()?;

			recog.base.set_state(1168);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_IF {
				{
				/*InvokeRule ifExist*/
				recog.base.set_state(1167);
				recog.ifExist()?;

				}
			}

			recog.base.set_state(1173);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(68,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule keyspace*/
					recog.base.set_state(1170);
					recog.keyspace()?;

					recog.base.set_state(1171);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			/*InvokeRule type_*/
			recog.base.set_state(1175);
			recog.type_()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- dropMaterializedView ----------------
pub type DropMaterializedViewContextAll<'input> = DropMaterializedViewContext<'input>;


pub type DropMaterializedViewContext<'input> = BaseParserRuleContext<'input,DropMaterializedViewContextExt<'input>>;

#[derive(Clone)]
pub struct DropMaterializedViewContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for DropMaterializedViewContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for DropMaterializedViewContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_dropMaterializedView(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_dropMaterializedView(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for DropMaterializedViewContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_dropMaterializedView(self);
	}
}

impl<'input> CustomRuleContext<'input> for DropMaterializedViewContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_dropMaterializedView }
	//fn type_rule_index() -> usize where Self: Sized { RULE_dropMaterializedView }
}
antlr_rust::type_id!{DropMaterializedViewContextExt<'a>}

impl<'input> DropMaterializedViewContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DropMaterializedViewContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DropMaterializedViewContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DropMaterializedViewContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<DropMaterializedViewContextExt<'input>>{

fn kwDrop(&self) -> Option<Rc<KwDropContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwMaterialized(&self) -> Option<Rc<KwMaterializedContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwView(&self) -> Option<Rc<KwViewContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn materializedView(&self) -> Option<Rc<MaterializedViewContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifExist(&self) -> Option<Rc<IfExistContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn keyspace(&self) -> Option<Rc<KeyspaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}

}

impl<'input> DropMaterializedViewContextAttrs<'input> for DropMaterializedViewContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn dropMaterializedView(&mut self,)
	-> Result<Rc<DropMaterializedViewContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DropMaterializedViewContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 118, RULE_dropMaterializedView);
        let mut _localctx: Rc<DropMaterializedViewContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwDrop*/
			recog.base.set_state(1177);
			recog.kwDrop()?;

			/*InvokeRule kwMaterialized*/
			recog.base.set_state(1178);
			recog.kwMaterialized()?;

			/*InvokeRule kwView*/
			recog.base.set_state(1179);
			recog.kwView()?;

			recog.base.set_state(1181);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_IF {
				{
				/*InvokeRule ifExist*/
				recog.base.set_state(1180);
				recog.ifExist()?;

				}
			}

			recog.base.set_state(1186);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(70,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule keyspace*/
					recog.base.set_state(1183);
					recog.keyspace()?;

					recog.base.set_state(1184);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			/*InvokeRule materializedView*/
			recog.base.set_state(1188);
			recog.materializedView()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- dropAggregate ----------------
pub type DropAggregateContextAll<'input> = DropAggregateContext<'input>;


pub type DropAggregateContext<'input> = BaseParserRuleContext<'input,DropAggregateContextExt<'input>>;

#[derive(Clone)]
pub struct DropAggregateContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for DropAggregateContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for DropAggregateContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_dropAggregate(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_dropAggregate(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for DropAggregateContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_dropAggregate(self);
	}
}

impl<'input> CustomRuleContext<'input> for DropAggregateContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_dropAggregate }
	//fn type_rule_index() -> usize where Self: Sized { RULE_dropAggregate }
}
antlr_rust::type_id!{DropAggregateContextExt<'a>}

impl<'input> DropAggregateContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DropAggregateContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DropAggregateContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DropAggregateContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<DropAggregateContextExt<'input>>{

fn kwDrop(&self) -> Option<Rc<KwDropContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwAggregate(&self) -> Option<Rc<KwAggregateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn aggregate(&self) -> Option<Rc<AggregateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifExist(&self) -> Option<Rc<IfExistContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn keyspace(&self) -> Option<Rc<KeyspaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}

}

impl<'input> DropAggregateContextAttrs<'input> for DropAggregateContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn dropAggregate(&mut self,)
	-> Result<Rc<DropAggregateContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DropAggregateContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 120, RULE_dropAggregate);
        let mut _localctx: Rc<DropAggregateContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwDrop*/
			recog.base.set_state(1190);
			recog.kwDrop()?;

			/*InvokeRule kwAggregate*/
			recog.base.set_state(1191);
			recog.kwAggregate()?;

			recog.base.set_state(1193);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_IF {
				{
				/*InvokeRule ifExist*/
				recog.base.set_state(1192);
				recog.ifExist()?;

				}
			}

			recog.base.set_state(1198);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(72,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule keyspace*/
					recog.base.set_state(1195);
					recog.keyspace()?;

					recog.base.set_state(1196);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			/*InvokeRule aggregate*/
			recog.base.set_state(1200);
			recog.aggregate()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- dropFunction ----------------
pub type DropFunctionContextAll<'input> = DropFunctionContext<'input>;


pub type DropFunctionContext<'input> = BaseParserRuleContext<'input,DropFunctionContextExt<'input>>;

#[derive(Clone)]
pub struct DropFunctionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for DropFunctionContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for DropFunctionContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_dropFunction(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_dropFunction(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for DropFunctionContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_dropFunction(self);
	}
}

impl<'input> CustomRuleContext<'input> for DropFunctionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_dropFunction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_dropFunction }
}
antlr_rust::type_id!{DropFunctionContextExt<'a>}

impl<'input> DropFunctionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DropFunctionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DropFunctionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DropFunctionContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<DropFunctionContextExt<'input>>{

fn kwDrop(&self) -> Option<Rc<KwDropContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwFunction(&self) -> Option<Rc<KwFunctionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn function_(&self) -> Option<Rc<Function_ContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifExist(&self) -> Option<Rc<IfExistContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn keyspace(&self) -> Option<Rc<KeyspaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}

}

impl<'input> DropFunctionContextAttrs<'input> for DropFunctionContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn dropFunction(&mut self,)
	-> Result<Rc<DropFunctionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DropFunctionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 122, RULE_dropFunction);
        let mut _localctx: Rc<DropFunctionContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwDrop*/
			recog.base.set_state(1202);
			recog.kwDrop()?;

			/*InvokeRule kwFunction*/
			recog.base.set_state(1203);
			recog.kwFunction()?;

			recog.base.set_state(1205);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_IF {
				{
				/*InvokeRule ifExist*/
				recog.base.set_state(1204);
				recog.ifExist()?;

				}
			}

			recog.base.set_state(1210);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(74,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule keyspace*/
					recog.base.set_state(1207);
					recog.keyspace()?;

					recog.base.set_state(1208);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			/*InvokeRule function_*/
			recog.base.set_state(1212);
			recog.function_()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- dropTrigger ----------------
pub type DropTriggerContextAll<'input> = DropTriggerContext<'input>;


pub type DropTriggerContext<'input> = BaseParserRuleContext<'input,DropTriggerContextExt<'input>>;

#[derive(Clone)]
pub struct DropTriggerContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for DropTriggerContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for DropTriggerContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_dropTrigger(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_dropTrigger(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for DropTriggerContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_dropTrigger(self);
	}
}

impl<'input> CustomRuleContext<'input> for DropTriggerContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_dropTrigger }
	//fn type_rule_index() -> usize where Self: Sized { RULE_dropTrigger }
}
antlr_rust::type_id!{DropTriggerContextExt<'a>}

impl<'input> DropTriggerContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DropTriggerContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DropTriggerContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DropTriggerContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<DropTriggerContextExt<'input>>{

fn kwDrop(&self) -> Option<Rc<KwDropContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwTrigger(&self) -> Option<Rc<KwTriggerContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn trigger(&self) -> Option<Rc<TriggerContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwOn(&self) -> Option<Rc<KwOnContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn table(&self) -> Option<Rc<TableContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifExist(&self) -> Option<Rc<IfExistContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn keyspace(&self) -> Option<Rc<KeyspaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}

}

impl<'input> DropTriggerContextAttrs<'input> for DropTriggerContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn dropTrigger(&mut self,)
	-> Result<Rc<DropTriggerContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DropTriggerContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 124, RULE_dropTrigger);
        let mut _localctx: Rc<DropTriggerContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwDrop*/
			recog.base.set_state(1214);
			recog.kwDrop()?;

			/*InvokeRule kwTrigger*/
			recog.base.set_state(1215);
			recog.kwTrigger()?;

			recog.base.set_state(1217);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_IF {
				{
				/*InvokeRule ifExist*/
				recog.base.set_state(1216);
				recog.ifExist()?;

				}
			}

			/*InvokeRule trigger*/
			recog.base.set_state(1219);
			recog.trigger()?;

			/*InvokeRule kwOn*/
			recog.base.set_state(1220);
			recog.kwOn()?;

			recog.base.set_state(1224);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(76,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule keyspace*/
					recog.base.set_state(1221);
					recog.keyspace()?;

					recog.base.set_state(1222);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			/*InvokeRule table*/
			recog.base.set_state(1226);
			recog.table()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- dropRole ----------------
pub type DropRoleContextAll<'input> = DropRoleContext<'input>;


pub type DropRoleContext<'input> = BaseParserRuleContext<'input,DropRoleContextExt<'input>>;

#[derive(Clone)]
pub struct DropRoleContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for DropRoleContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for DropRoleContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_dropRole(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_dropRole(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for DropRoleContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_dropRole(self);
	}
}

impl<'input> CustomRuleContext<'input> for DropRoleContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_dropRole }
	//fn type_rule_index() -> usize where Self: Sized { RULE_dropRole }
}
antlr_rust::type_id!{DropRoleContextExt<'a>}

impl<'input> DropRoleContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DropRoleContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DropRoleContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DropRoleContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<DropRoleContextExt<'input>>{

fn kwDrop(&self) -> Option<Rc<KwDropContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwRole(&self) -> Option<Rc<KwRoleContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn role(&self) -> Option<Rc<RoleContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifExist(&self) -> Option<Rc<IfExistContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DropRoleContextAttrs<'input> for DropRoleContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn dropRole(&mut self,)
	-> Result<Rc<DropRoleContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DropRoleContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 126, RULE_dropRole);
        let mut _localctx: Rc<DropRoleContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwDrop*/
			recog.base.set_state(1228);
			recog.kwDrop()?;

			/*InvokeRule kwRole*/
			recog.base.set_state(1229);
			recog.kwRole()?;

			recog.base.set_state(1231);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_IF {
				{
				/*InvokeRule ifExist*/
				recog.base.set_state(1230);
				recog.ifExist()?;

				}
			}

			/*InvokeRule role*/
			recog.base.set_state(1233);
			recog.role()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- dropTable ----------------
pub type DropTableContextAll<'input> = DropTableContext<'input>;


pub type DropTableContext<'input> = BaseParserRuleContext<'input,DropTableContextExt<'input>>;

#[derive(Clone)]
pub struct DropTableContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for DropTableContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for DropTableContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_dropTable(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_dropTable(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for DropTableContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_dropTable(self);
	}
}

impl<'input> CustomRuleContext<'input> for DropTableContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_dropTable }
	//fn type_rule_index() -> usize where Self: Sized { RULE_dropTable }
}
antlr_rust::type_id!{DropTableContextExt<'a>}

impl<'input> DropTableContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DropTableContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DropTableContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DropTableContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<DropTableContextExt<'input>>{

fn kwDrop(&self) -> Option<Rc<KwDropContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwTable(&self) -> Option<Rc<KwTableContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn table(&self) -> Option<Rc<TableContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifExist(&self) -> Option<Rc<IfExistContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn keyspace(&self) -> Option<Rc<KeyspaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}

}

impl<'input> DropTableContextAttrs<'input> for DropTableContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn dropTable(&mut self,)
	-> Result<Rc<DropTableContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DropTableContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 128, RULE_dropTable);
        let mut _localctx: Rc<DropTableContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwDrop*/
			recog.base.set_state(1235);
			recog.kwDrop()?;

			/*InvokeRule kwTable*/
			recog.base.set_state(1236);
			recog.kwTable()?;

			recog.base.set_state(1238);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_IF {
				{
				/*InvokeRule ifExist*/
				recog.base.set_state(1237);
				recog.ifExist()?;

				}
			}

			recog.base.set_state(1243);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(79,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule keyspace*/
					recog.base.set_state(1240);
					recog.keyspace()?;

					recog.base.set_state(1241);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			/*InvokeRule table*/
			recog.base.set_state(1245);
			recog.table()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- dropKeyspace ----------------
pub type DropKeyspaceContextAll<'input> = DropKeyspaceContext<'input>;


pub type DropKeyspaceContext<'input> = BaseParserRuleContext<'input,DropKeyspaceContextExt<'input>>;

#[derive(Clone)]
pub struct DropKeyspaceContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for DropKeyspaceContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for DropKeyspaceContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_dropKeyspace(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_dropKeyspace(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for DropKeyspaceContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_dropKeyspace(self);
	}
}

impl<'input> CustomRuleContext<'input> for DropKeyspaceContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_dropKeyspace }
	//fn type_rule_index() -> usize where Self: Sized { RULE_dropKeyspace }
}
antlr_rust::type_id!{DropKeyspaceContextExt<'a>}

impl<'input> DropKeyspaceContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DropKeyspaceContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DropKeyspaceContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DropKeyspaceContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<DropKeyspaceContextExt<'input>>{

fn kwDrop(&self) -> Option<Rc<KwDropContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwKeyspace(&self) -> Option<Rc<KwKeyspaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn keyspace(&self) -> Option<Rc<KeyspaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifExist(&self) -> Option<Rc<IfExistContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DropKeyspaceContextAttrs<'input> for DropKeyspaceContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn dropKeyspace(&mut self,)
	-> Result<Rc<DropKeyspaceContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DropKeyspaceContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 130, RULE_dropKeyspace);
        let mut _localctx: Rc<DropKeyspaceContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwDrop*/
			recog.base.set_state(1247);
			recog.kwDrop()?;

			/*InvokeRule kwKeyspace*/
			recog.base.set_state(1248);
			recog.kwKeyspace()?;

			recog.base.set_state(1250);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_IF {
				{
				/*InvokeRule ifExist*/
				recog.base.set_state(1249);
				recog.ifExist()?;

				}
			}

			/*InvokeRule keyspace*/
			recog.base.set_state(1252);
			recog.keyspace()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- dropIndex ----------------
pub type DropIndexContextAll<'input> = DropIndexContext<'input>;


pub type DropIndexContext<'input> = BaseParserRuleContext<'input,DropIndexContextExt<'input>>;

#[derive(Clone)]
pub struct DropIndexContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for DropIndexContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for DropIndexContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_dropIndex(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_dropIndex(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for DropIndexContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_dropIndex(self);
	}
}

impl<'input> CustomRuleContext<'input> for DropIndexContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_dropIndex }
	//fn type_rule_index() -> usize where Self: Sized { RULE_dropIndex }
}
antlr_rust::type_id!{DropIndexContextExt<'a>}

impl<'input> DropIndexContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DropIndexContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DropIndexContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DropIndexContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<DropIndexContextExt<'input>>{

fn kwDrop(&self) -> Option<Rc<KwDropContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwIndex(&self) -> Option<Rc<KwIndexContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn indexName(&self) -> Option<Rc<IndexNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifExist(&self) -> Option<Rc<IfExistContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn keyspace(&self) -> Option<Rc<KeyspaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}

}

impl<'input> DropIndexContextAttrs<'input> for DropIndexContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn dropIndex(&mut self,)
	-> Result<Rc<DropIndexContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DropIndexContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 132, RULE_dropIndex);
        let mut _localctx: Rc<DropIndexContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwDrop*/
			recog.base.set_state(1254);
			recog.kwDrop()?;

			/*InvokeRule kwIndex*/
			recog.base.set_state(1255);
			recog.kwIndex()?;

			recog.base.set_state(1257);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_IF {
				{
				/*InvokeRule ifExist*/
				recog.base.set_state(1256);
				recog.ifExist()?;

				}
			}

			recog.base.set_state(1262);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(82,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule keyspace*/
					recog.base.set_state(1259);
					recog.keyspace()?;

					recog.base.set_state(1260);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			/*InvokeRule indexName*/
			recog.base.set_state(1264);
			recog.indexName()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- createTable ----------------
pub type CreateTableContextAll<'input> = CreateTableContext<'input>;


pub type CreateTableContext<'input> = BaseParserRuleContext<'input,CreateTableContextExt<'input>>;

#[derive(Clone)]
pub struct CreateTableContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for CreateTableContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for CreateTableContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_createTable(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_createTable(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for CreateTableContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_createTable(self);
	}
}

impl<'input> CustomRuleContext<'input> for CreateTableContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_createTable }
	//fn type_rule_index() -> usize where Self: Sized { RULE_createTable }
}
antlr_rust::type_id!{CreateTableContextExt<'a>}

impl<'input> CreateTableContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CreateTableContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CreateTableContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CreateTableContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<CreateTableContextExt<'input>>{

fn kwCreate(&self) -> Option<Rc<KwCreateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwTable(&self) -> Option<Rc<KwTableContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn table(&self) -> Option<Rc<TableContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn syntaxBracketLr(&self) -> Option<Rc<SyntaxBracketLrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn columnDefinitionList(&self) -> Option<Rc<ColumnDefinitionListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn syntaxBracketRr(&self) -> Option<Rc<SyntaxBracketRrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifNotExist(&self) -> Option<Rc<IfNotExistContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn keyspace(&self) -> Option<Rc<KeyspaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
fn withElement(&self) -> Option<Rc<WithElementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CreateTableContextAttrs<'input> for CreateTableContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn createTable(&mut self,)
	-> Result<Rc<CreateTableContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CreateTableContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 134, RULE_createTable);
        let mut _localctx: Rc<CreateTableContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwCreate*/
			recog.base.set_state(1266);
			recog.kwCreate()?;

			/*InvokeRule kwTable*/
			recog.base.set_state(1267);
			recog.kwTable()?;

			recog.base.set_state(1269);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_IF {
				{
				/*InvokeRule ifNotExist*/
				recog.base.set_state(1268);
				recog.ifNotExist()?;

				}
			}

			recog.base.set_state(1274);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(84,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule keyspace*/
					recog.base.set_state(1271);
					recog.keyspace()?;

					recog.base.set_state(1272);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			/*InvokeRule table*/
			recog.base.set_state(1276);
			recog.table()?;

			/*InvokeRule syntaxBracketLr*/
			recog.base.set_state(1277);
			recog.syntaxBracketLr()?;

			/*InvokeRule columnDefinitionList*/
			recog.base.set_state(1278);
			recog.columnDefinitionList()?;

			/*InvokeRule syntaxBracketRr*/
			recog.base.set_state(1279);
			recog.syntaxBracketRr()?;

			recog.base.set_state(1281);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_WITH {
				{
				/*InvokeRule withElement*/
				recog.base.set_state(1280);
				recog.withElement()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- withElement ----------------
pub type WithElementContextAll<'input> = WithElementContext<'input>;


pub type WithElementContext<'input> = BaseParserRuleContext<'input,WithElementContextExt<'input>>;

#[derive(Clone)]
pub struct WithElementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for WithElementContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for WithElementContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_withElement(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_withElement(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for WithElementContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_withElement(self);
	}
}

impl<'input> CustomRuleContext<'input> for WithElementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_withElement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_withElement }
}
antlr_rust::type_id!{WithElementContextExt<'a>}

impl<'input> WithElementContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<WithElementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,WithElementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait WithElementContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<WithElementContextExt<'input>>{

fn kwWith(&self) -> Option<Rc<KwWithContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn tableOptions(&self) -> Option<Rc<TableOptionsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn clusteringOrder(&self) -> Option<Rc<ClusteringOrderContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> WithElementContextAttrs<'input> for WithElementContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn withElement(&mut self,)
	-> Result<Rc<WithElementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = WithElementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 136, RULE_withElement);
        let mut _localctx: Rc<WithElementContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwWith*/
			recog.base.set_state(1283);
			recog.kwWith()?;

			recog.base.set_state(1285);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==OBJECT_NAME {
				{
				/*InvokeRule tableOptions*/
				recog.base.set_state(1284);
				recog.tableOptions()?;

				}
			}

			recog.base.set_state(1288);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_CLUSTERING {
				{
				/*InvokeRule clusteringOrder*/
				recog.base.set_state(1287);
				recog.clusteringOrder()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- clusteringOrder ----------------
pub type ClusteringOrderContextAll<'input> = ClusteringOrderContext<'input>;


pub type ClusteringOrderContext<'input> = BaseParserRuleContext<'input,ClusteringOrderContextExt<'input>>;

#[derive(Clone)]
pub struct ClusteringOrderContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for ClusteringOrderContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for ClusteringOrderContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_clusteringOrder(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_clusteringOrder(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for ClusteringOrderContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_clusteringOrder(self);
	}
}

impl<'input> CustomRuleContext<'input> for ClusteringOrderContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_clusteringOrder }
	//fn type_rule_index() -> usize where Self: Sized { RULE_clusteringOrder }
}
antlr_rust::type_id!{ClusteringOrderContextExt<'a>}

impl<'input> ClusteringOrderContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClusteringOrderContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClusteringOrderContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClusteringOrderContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<ClusteringOrderContextExt<'input>>{

fn kwClustering(&self) -> Option<Rc<KwClusteringContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwOrder(&self) -> Option<Rc<KwOrderContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwBy(&self) -> Option<Rc<KwByContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn syntaxBracketLr(&self) -> Option<Rc<SyntaxBracketLrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn column(&self) -> Option<Rc<ColumnContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn syntaxBracketRr(&self) -> Option<Rc<SyntaxBracketRrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn orderDirection(&self) -> Option<Rc<OrderDirectionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ClusteringOrderContextAttrs<'input> for ClusteringOrderContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn clusteringOrder(&mut self,)
	-> Result<Rc<ClusteringOrderContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClusteringOrderContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 138, RULE_clusteringOrder);
        let mut _localctx: Rc<ClusteringOrderContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwClustering*/
			recog.base.set_state(1290);
			recog.kwClustering()?;

			/*InvokeRule kwOrder*/
			recog.base.set_state(1291);
			recog.kwOrder()?;

			/*InvokeRule kwBy*/
			recog.base.set_state(1292);
			recog.kwBy()?;

			/*InvokeRule syntaxBracketLr*/
			recog.base.set_state(1293);
			recog.syntaxBracketLr()?;

			/*InvokeRule column*/
			recog.base.set_state(1294);
			recog.column()?;

			recog.base.set_state(1296);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_ASC || _la==K_DESC {
				{
				/*InvokeRule orderDirection*/
				recog.base.set_state(1295);
				recog.orderDirection()?;

				}
			}

			/*InvokeRule syntaxBracketRr*/
			recog.base.set_state(1298);
			recog.syntaxBracketRr()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- tableOptions ----------------
pub type TableOptionsContextAll<'input> = TableOptionsContext<'input>;


pub type TableOptionsContext<'input> = BaseParserRuleContext<'input,TableOptionsContextExt<'input>>;

#[derive(Clone)]
pub struct TableOptionsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for TableOptionsContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for TableOptionsContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_tableOptions(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_tableOptions(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for TableOptionsContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_tableOptions(self);
	}
}

impl<'input> CustomRuleContext<'input> for TableOptionsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_tableOptions }
	//fn type_rule_index() -> usize where Self: Sized { RULE_tableOptions }
}
antlr_rust::type_id!{TableOptionsContextExt<'a>}

impl<'input> TableOptionsContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TableOptionsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TableOptionsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TableOptionsContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<TableOptionsContextExt<'input>>{

fn tableOptionItem_all(&self) ->  Vec<Rc<TableOptionItemContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn tableOptionItem(&self, i: usize) -> Option<Rc<TableOptionItemContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn kwAnd_all(&self) ->  Vec<Rc<KwAndContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn kwAnd(&self, i: usize) -> Option<Rc<KwAndContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> TableOptionsContextAttrs<'input> for TableOptionsContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn tableOptions(&mut self,)
	-> Result<Rc<TableOptionsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TableOptionsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 140, RULE_tableOptions);
        let mut _localctx: Rc<TableOptionsContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule tableOptionItem*/
			recog.base.set_state(1300);
			recog.tableOptionItem()?;

			recog.base.set_state(1306);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(89,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule kwAnd*/
					recog.base.set_state(1301);
					recog.kwAnd()?;

					/*InvokeRule tableOptionItem*/
					recog.base.set_state(1302);
					recog.tableOptionItem()?;

					}
					} 
				}
				recog.base.set_state(1308);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(89,&mut recog.base)?;
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- tableOptionItem ----------------
pub type TableOptionItemContextAll<'input> = TableOptionItemContext<'input>;


pub type TableOptionItemContext<'input> = BaseParserRuleContext<'input,TableOptionItemContextExt<'input>>;

#[derive(Clone)]
pub struct TableOptionItemContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for TableOptionItemContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for TableOptionItemContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_tableOptionItem(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_tableOptionItem(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for TableOptionItemContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_tableOptionItem(self);
	}
}

impl<'input> CustomRuleContext<'input> for TableOptionItemContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_tableOptionItem }
	//fn type_rule_index() -> usize where Self: Sized { RULE_tableOptionItem }
}
antlr_rust::type_id!{TableOptionItemContextExt<'a>}

impl<'input> TableOptionItemContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TableOptionItemContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TableOptionItemContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TableOptionItemContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<TableOptionItemContextExt<'input>>{

fn tableOptionName(&self) -> Option<Rc<TableOptionNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token OPERATOR_EQ
/// Returns `None` if there is no child corresponding to token OPERATOR_EQ
fn OPERATOR_EQ(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OPERATOR_EQ, 0)
}
fn tableOptionValue(&self) -> Option<Rc<TableOptionValueContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn optionHash(&self) -> Option<Rc<OptionHashContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TableOptionItemContextAttrs<'input> for TableOptionItemContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn tableOptionItem(&mut self,)
	-> Result<Rc<TableOptionItemContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TableOptionItemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 142, RULE_tableOptionItem);
        let mut _localctx: Rc<TableOptionItemContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1317);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(90,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule tableOptionName*/
					recog.base.set_state(1309);
					recog.tableOptionName()?;

					recog.base.set_state(1310);
					recog.base.match_token(OPERATOR_EQ,&mut recog.err_handler)?;

					/*InvokeRule tableOptionValue*/
					recog.base.set_state(1311);
					recog.tableOptionValue()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule tableOptionName*/
					recog.base.set_state(1313);
					recog.tableOptionName()?;

					recog.base.set_state(1314);
					recog.base.match_token(OPERATOR_EQ,&mut recog.err_handler)?;

					/*InvokeRule optionHash*/
					recog.base.set_state(1315);
					recog.optionHash()?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- tableOptionName ----------------
pub type TableOptionNameContextAll<'input> = TableOptionNameContext<'input>;


pub type TableOptionNameContext<'input> = BaseParserRuleContext<'input,TableOptionNameContextExt<'input>>;

#[derive(Clone)]
pub struct TableOptionNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for TableOptionNameContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for TableOptionNameContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_tableOptionName(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_tableOptionName(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for TableOptionNameContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_tableOptionName(self);
	}
}

impl<'input> CustomRuleContext<'input> for TableOptionNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_tableOptionName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_tableOptionName }
}
antlr_rust::type_id!{TableOptionNameContextExt<'a>}

impl<'input> TableOptionNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TableOptionNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TableOptionNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TableOptionNameContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<TableOptionNameContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OBJECT_NAME
/// Returns `None` if there is no child corresponding to token OBJECT_NAME
fn OBJECT_NAME(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OBJECT_NAME, 0)
}

}

impl<'input> TableOptionNameContextAttrs<'input> for TableOptionNameContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn tableOptionName(&mut self,)
	-> Result<Rc<TableOptionNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TableOptionNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 144, RULE_tableOptionName);
        let mut _localctx: Rc<TableOptionNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1319);
			recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- tableOptionValue ----------------
pub type TableOptionValueContextAll<'input> = TableOptionValueContext<'input>;


pub type TableOptionValueContext<'input> = BaseParserRuleContext<'input,TableOptionValueContextExt<'input>>;

#[derive(Clone)]
pub struct TableOptionValueContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for TableOptionValueContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for TableOptionValueContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_tableOptionValue(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_tableOptionValue(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for TableOptionValueContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_tableOptionValue(self);
	}
}

impl<'input> CustomRuleContext<'input> for TableOptionValueContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_tableOptionValue }
	//fn type_rule_index() -> usize where Self: Sized { RULE_tableOptionValue }
}
antlr_rust::type_id!{TableOptionValueContextExt<'a>}

impl<'input> TableOptionValueContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TableOptionValueContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TableOptionValueContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TableOptionValueContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<TableOptionValueContextExt<'input>>{

fn stringLiteral(&self) -> Option<Rc<StringLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn floatLiteral(&self) -> Option<Rc<FloatLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TableOptionValueContextAttrs<'input> for TableOptionValueContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn tableOptionValue(&mut self,)
	-> Result<Rc<TableOptionValueContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TableOptionValueContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 146, RULE_tableOptionValue);
        let mut _localctx: Rc<TableOptionValueContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1323);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 STRING_LITERAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule stringLiteral*/
					recog.base.set_state(1321);
					recog.stringLiteral()?;

					}
				}

			 DECIMAL_LITERAL | FLOAT_LITERAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule floatLiteral*/
					recog.base.set_state(1322);
					recog.floatLiteral()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- optionHash ----------------
pub type OptionHashContextAll<'input> = OptionHashContext<'input>;


pub type OptionHashContext<'input> = BaseParserRuleContext<'input,OptionHashContextExt<'input>>;

#[derive(Clone)]
pub struct OptionHashContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for OptionHashContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for OptionHashContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_optionHash(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_optionHash(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for OptionHashContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_optionHash(self);
	}
}

impl<'input> CustomRuleContext<'input> for OptionHashContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_optionHash }
	//fn type_rule_index() -> usize where Self: Sized { RULE_optionHash }
}
antlr_rust::type_id!{OptionHashContextExt<'a>}

impl<'input> OptionHashContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<OptionHashContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,OptionHashContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait OptionHashContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<OptionHashContextExt<'input>>{

fn syntaxBracketLc(&self) -> Option<Rc<SyntaxBracketLcContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn optionHashItem_all(&self) ->  Vec<Rc<OptionHashItemContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn optionHashItem(&self, i: usize) -> Option<Rc<OptionHashItemContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn syntaxBracketRc(&self) -> Option<Rc<SyntaxBracketRcContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn syntaxComma_all(&self) ->  Vec<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn syntaxComma(&self, i: usize) -> Option<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> OptionHashContextAttrs<'input> for OptionHashContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn optionHash(&mut self,)
	-> Result<Rc<OptionHashContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = OptionHashContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 148, RULE_optionHash);
        let mut _localctx: Rc<OptionHashContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule syntaxBracketLc*/
			recog.base.set_state(1325);
			recog.syntaxBracketLc()?;

			/*InvokeRule optionHashItem*/
			recog.base.set_state(1326);
			recog.optionHashItem()?;

			recog.base.set_state(1332);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				/*InvokeRule syntaxComma*/
				recog.base.set_state(1327);
				recog.syntaxComma()?;

				/*InvokeRule optionHashItem*/
				recog.base.set_state(1328);
				recog.optionHashItem()?;

				}
				}
				recog.base.set_state(1334);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule syntaxBracketRc*/
			recog.base.set_state(1335);
			recog.syntaxBracketRc()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- optionHashItem ----------------
pub type OptionHashItemContextAll<'input> = OptionHashItemContext<'input>;


pub type OptionHashItemContext<'input> = BaseParserRuleContext<'input,OptionHashItemContextExt<'input>>;

#[derive(Clone)]
pub struct OptionHashItemContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for OptionHashItemContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for OptionHashItemContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_optionHashItem(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_optionHashItem(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for OptionHashItemContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_optionHashItem(self);
	}
}

impl<'input> CustomRuleContext<'input> for OptionHashItemContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_optionHashItem }
	//fn type_rule_index() -> usize where Self: Sized { RULE_optionHashItem }
}
antlr_rust::type_id!{OptionHashItemContextExt<'a>}

impl<'input> OptionHashItemContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<OptionHashItemContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,OptionHashItemContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait OptionHashItemContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<OptionHashItemContextExt<'input>>{

fn optionHashKey(&self) -> Option<Rc<OptionHashKeyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn optionHashValue(&self) -> Option<Rc<OptionHashValueContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> OptionHashItemContextAttrs<'input> for OptionHashItemContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn optionHashItem(&mut self,)
	-> Result<Rc<OptionHashItemContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = OptionHashItemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 150, RULE_optionHashItem);
        let mut _localctx: Rc<OptionHashItemContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule optionHashKey*/
			recog.base.set_state(1337);
			recog.optionHashKey()?;

			recog.base.set_state(1338);
			recog.base.match_token(COLON,&mut recog.err_handler)?;

			/*InvokeRule optionHashValue*/
			recog.base.set_state(1339);
			recog.optionHashValue()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- optionHashKey ----------------
pub type OptionHashKeyContextAll<'input> = OptionHashKeyContext<'input>;


pub type OptionHashKeyContext<'input> = BaseParserRuleContext<'input,OptionHashKeyContextExt<'input>>;

#[derive(Clone)]
pub struct OptionHashKeyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for OptionHashKeyContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for OptionHashKeyContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_optionHashKey(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_optionHashKey(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for OptionHashKeyContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_optionHashKey(self);
	}
}

impl<'input> CustomRuleContext<'input> for OptionHashKeyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_optionHashKey }
	//fn type_rule_index() -> usize where Self: Sized { RULE_optionHashKey }
}
antlr_rust::type_id!{OptionHashKeyContextExt<'a>}

impl<'input> OptionHashKeyContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<OptionHashKeyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,OptionHashKeyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait OptionHashKeyContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<OptionHashKeyContextExt<'input>>{

fn stringLiteral(&self) -> Option<Rc<StringLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> OptionHashKeyContextAttrs<'input> for OptionHashKeyContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn optionHashKey(&mut self,)
	-> Result<Rc<OptionHashKeyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = OptionHashKeyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 152, RULE_optionHashKey);
        let mut _localctx: Rc<OptionHashKeyContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule stringLiteral*/
			recog.base.set_state(1341);
			recog.stringLiteral()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- optionHashValue ----------------
pub type OptionHashValueContextAll<'input> = OptionHashValueContext<'input>;


pub type OptionHashValueContext<'input> = BaseParserRuleContext<'input,OptionHashValueContextExt<'input>>;

#[derive(Clone)]
pub struct OptionHashValueContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for OptionHashValueContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for OptionHashValueContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_optionHashValue(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_optionHashValue(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for OptionHashValueContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_optionHashValue(self);
	}
}

impl<'input> CustomRuleContext<'input> for OptionHashValueContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_optionHashValue }
	//fn type_rule_index() -> usize where Self: Sized { RULE_optionHashValue }
}
antlr_rust::type_id!{OptionHashValueContextExt<'a>}

impl<'input> OptionHashValueContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<OptionHashValueContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,OptionHashValueContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait OptionHashValueContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<OptionHashValueContextExt<'input>>{

fn stringLiteral(&self) -> Option<Rc<StringLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn floatLiteral(&self) -> Option<Rc<FloatLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> OptionHashValueContextAttrs<'input> for OptionHashValueContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn optionHashValue(&mut self,)
	-> Result<Rc<OptionHashValueContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = OptionHashValueContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 154, RULE_optionHashValue);
        let mut _localctx: Rc<OptionHashValueContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1345);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 STRING_LITERAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule stringLiteral*/
					recog.base.set_state(1343);
					recog.stringLiteral()?;

					}
				}

			 DECIMAL_LITERAL | FLOAT_LITERAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule floatLiteral*/
					recog.base.set_state(1344);
					recog.floatLiteral()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- columnDefinitionList ----------------
pub type ColumnDefinitionListContextAll<'input> = ColumnDefinitionListContext<'input>;


pub type ColumnDefinitionListContext<'input> = BaseParserRuleContext<'input,ColumnDefinitionListContextExt<'input>>;

#[derive(Clone)]
pub struct ColumnDefinitionListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for ColumnDefinitionListContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for ColumnDefinitionListContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_columnDefinitionList(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_columnDefinitionList(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for ColumnDefinitionListContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_columnDefinitionList(self);
	}
}

impl<'input> CustomRuleContext<'input> for ColumnDefinitionListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_columnDefinitionList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_columnDefinitionList }
}
antlr_rust::type_id!{ColumnDefinitionListContextExt<'a>}

impl<'input> ColumnDefinitionListContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ColumnDefinitionListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ColumnDefinitionListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ColumnDefinitionListContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<ColumnDefinitionListContextExt<'input>>{

fn columnDefinition_all(&self) ->  Vec<Rc<ColumnDefinitionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn columnDefinition(&self, i: usize) -> Option<Rc<ColumnDefinitionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn syntaxComma_all(&self) ->  Vec<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn syntaxComma(&self, i: usize) -> Option<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn primaryKeyElement(&self) -> Option<Rc<PrimaryKeyElementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ColumnDefinitionListContextAttrs<'input> for ColumnDefinitionListContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn columnDefinitionList(&mut self,)
	-> Result<Rc<ColumnDefinitionListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ColumnDefinitionListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 156, RULE_columnDefinitionList);
        let mut _localctx: Rc<ColumnDefinitionListContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule columnDefinition*/
			recog.base.set_state(1347);
			recog.columnDefinition()?;

			}
			recog.base.set_state(1353);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(94,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule syntaxComma*/
					recog.base.set_state(1348);
					recog.syntaxComma()?;

					/*InvokeRule columnDefinition*/
					recog.base.set_state(1349);
					recog.columnDefinition()?;

					}
					} 
				}
				recog.base.set_state(1355);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(94,&mut recog.base)?;
			}
			recog.base.set_state(1359);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==COMMA {
				{
				/*InvokeRule syntaxComma*/
				recog.base.set_state(1356);
				recog.syntaxComma()?;

				/*InvokeRule primaryKeyElement*/
				recog.base.set_state(1357);
				recog.primaryKeyElement()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- columnDefinition ----------------
pub type ColumnDefinitionContextAll<'input> = ColumnDefinitionContext<'input>;


pub type ColumnDefinitionContext<'input> = BaseParserRuleContext<'input,ColumnDefinitionContextExt<'input>>;

#[derive(Clone)]
pub struct ColumnDefinitionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for ColumnDefinitionContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for ColumnDefinitionContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_columnDefinition(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_columnDefinition(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for ColumnDefinitionContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_columnDefinition(self);
	}
}

impl<'input> CustomRuleContext<'input> for ColumnDefinitionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_columnDefinition }
	//fn type_rule_index() -> usize where Self: Sized { RULE_columnDefinition }
}
antlr_rust::type_id!{ColumnDefinitionContextExt<'a>}

impl<'input> ColumnDefinitionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ColumnDefinitionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ColumnDefinitionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ColumnDefinitionContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<ColumnDefinitionContextExt<'input>>{

fn column(&self) -> Option<Rc<ColumnContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn dataType(&self) -> Option<Rc<DataTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn primaryKeyColumn(&self) -> Option<Rc<PrimaryKeyColumnContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ColumnDefinitionContextAttrs<'input> for ColumnDefinitionContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn columnDefinition(&mut self,)
	-> Result<Rc<ColumnDefinitionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ColumnDefinitionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 158, RULE_columnDefinition);
        let mut _localctx: Rc<ColumnDefinitionContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule column*/
			recog.base.set_state(1361);
			recog.column()?;

			/*InvokeRule dataType*/
			recog.base.set_state(1362);
			recog.dataType()?;

			recog.base.set_state(1364);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_PRIMARY {
				{
				/*InvokeRule primaryKeyColumn*/
				recog.base.set_state(1363);
				recog.primaryKeyColumn()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- primaryKeyColumn ----------------
pub type PrimaryKeyColumnContextAll<'input> = PrimaryKeyColumnContext<'input>;


pub type PrimaryKeyColumnContext<'input> = BaseParserRuleContext<'input,PrimaryKeyColumnContextExt<'input>>;

#[derive(Clone)]
pub struct PrimaryKeyColumnContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for PrimaryKeyColumnContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for PrimaryKeyColumnContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_primaryKeyColumn(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_primaryKeyColumn(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for PrimaryKeyColumnContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_primaryKeyColumn(self);
	}
}

impl<'input> CustomRuleContext<'input> for PrimaryKeyColumnContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryKeyColumn }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryKeyColumn }
}
antlr_rust::type_id!{PrimaryKeyColumnContextExt<'a>}

impl<'input> PrimaryKeyColumnContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PrimaryKeyColumnContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PrimaryKeyColumnContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PrimaryKeyColumnContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<PrimaryKeyColumnContextExt<'input>>{

fn kwPrimary(&self) -> Option<Rc<KwPrimaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwKey(&self) -> Option<Rc<KwKeyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PrimaryKeyColumnContextAttrs<'input> for PrimaryKeyColumnContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn primaryKeyColumn(&mut self,)
	-> Result<Rc<PrimaryKeyColumnContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PrimaryKeyColumnContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 160, RULE_primaryKeyColumn);
        let mut _localctx: Rc<PrimaryKeyColumnContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwPrimary*/
			recog.base.set_state(1366);
			recog.kwPrimary()?;

			/*InvokeRule kwKey*/
			recog.base.set_state(1367);
			recog.kwKey()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- primaryKeyElement ----------------
pub type PrimaryKeyElementContextAll<'input> = PrimaryKeyElementContext<'input>;


pub type PrimaryKeyElementContext<'input> = BaseParserRuleContext<'input,PrimaryKeyElementContextExt<'input>>;

#[derive(Clone)]
pub struct PrimaryKeyElementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for PrimaryKeyElementContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for PrimaryKeyElementContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_primaryKeyElement(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_primaryKeyElement(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for PrimaryKeyElementContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_primaryKeyElement(self);
	}
}

impl<'input> CustomRuleContext<'input> for PrimaryKeyElementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryKeyElement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryKeyElement }
}
antlr_rust::type_id!{PrimaryKeyElementContextExt<'a>}

impl<'input> PrimaryKeyElementContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PrimaryKeyElementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PrimaryKeyElementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PrimaryKeyElementContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<PrimaryKeyElementContextExt<'input>>{

fn kwPrimary(&self) -> Option<Rc<KwPrimaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwKey(&self) -> Option<Rc<KwKeyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn syntaxBracketLr(&self) -> Option<Rc<SyntaxBracketLrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn primaryKeyDefinition(&self) -> Option<Rc<PrimaryKeyDefinitionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn syntaxBracketRr(&self) -> Option<Rc<SyntaxBracketRrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PrimaryKeyElementContextAttrs<'input> for PrimaryKeyElementContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn primaryKeyElement(&mut self,)
	-> Result<Rc<PrimaryKeyElementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PrimaryKeyElementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 162, RULE_primaryKeyElement);
        let mut _localctx: Rc<PrimaryKeyElementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwPrimary*/
			recog.base.set_state(1369);
			recog.kwPrimary()?;

			/*InvokeRule kwKey*/
			recog.base.set_state(1370);
			recog.kwKey()?;

			/*InvokeRule syntaxBracketLr*/
			recog.base.set_state(1371);
			recog.syntaxBracketLr()?;

			/*InvokeRule primaryKeyDefinition*/
			recog.base.set_state(1372);
			recog.primaryKeyDefinition()?;

			/*InvokeRule syntaxBracketRr*/
			recog.base.set_state(1373);
			recog.syntaxBracketRr()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- primaryKeyDefinition ----------------
pub type PrimaryKeyDefinitionContextAll<'input> = PrimaryKeyDefinitionContext<'input>;


pub type PrimaryKeyDefinitionContext<'input> = BaseParserRuleContext<'input,PrimaryKeyDefinitionContextExt<'input>>;

#[derive(Clone)]
pub struct PrimaryKeyDefinitionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for PrimaryKeyDefinitionContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for PrimaryKeyDefinitionContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_primaryKeyDefinition(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_primaryKeyDefinition(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for PrimaryKeyDefinitionContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_primaryKeyDefinition(self);
	}
}

impl<'input> CustomRuleContext<'input> for PrimaryKeyDefinitionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryKeyDefinition }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryKeyDefinition }
}
antlr_rust::type_id!{PrimaryKeyDefinitionContextExt<'a>}

impl<'input> PrimaryKeyDefinitionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PrimaryKeyDefinitionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PrimaryKeyDefinitionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PrimaryKeyDefinitionContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<PrimaryKeyDefinitionContextExt<'input>>{

fn singlePrimaryKey(&self) -> Option<Rc<SinglePrimaryKeyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn compoundKey(&self) -> Option<Rc<CompoundKeyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn compositeKey(&self) -> Option<Rc<CompositeKeyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PrimaryKeyDefinitionContextAttrs<'input> for PrimaryKeyDefinitionContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn primaryKeyDefinition(&mut self,)
	-> Result<Rc<PrimaryKeyDefinitionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PrimaryKeyDefinitionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 164, RULE_primaryKeyDefinition);
        let mut _localctx: Rc<PrimaryKeyDefinitionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1378);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(97,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule singlePrimaryKey*/
					recog.base.set_state(1375);
					recog.singlePrimaryKey()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule compoundKey*/
					recog.base.set_state(1376);
					recog.compoundKey()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule compositeKey*/
					recog.base.set_state(1377);
					recog.compositeKey()?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- singlePrimaryKey ----------------
pub type SinglePrimaryKeyContextAll<'input> = SinglePrimaryKeyContext<'input>;


pub type SinglePrimaryKeyContext<'input> = BaseParserRuleContext<'input,SinglePrimaryKeyContextExt<'input>>;

#[derive(Clone)]
pub struct SinglePrimaryKeyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for SinglePrimaryKeyContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for SinglePrimaryKeyContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_singlePrimaryKey(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_singlePrimaryKey(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for SinglePrimaryKeyContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_singlePrimaryKey(self);
	}
}

impl<'input> CustomRuleContext<'input> for SinglePrimaryKeyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_singlePrimaryKey }
	//fn type_rule_index() -> usize where Self: Sized { RULE_singlePrimaryKey }
}
antlr_rust::type_id!{SinglePrimaryKeyContextExt<'a>}

impl<'input> SinglePrimaryKeyContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SinglePrimaryKeyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SinglePrimaryKeyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SinglePrimaryKeyContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<SinglePrimaryKeyContextExt<'input>>{

fn column(&self) -> Option<Rc<ColumnContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SinglePrimaryKeyContextAttrs<'input> for SinglePrimaryKeyContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn singlePrimaryKey(&mut self,)
	-> Result<Rc<SinglePrimaryKeyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SinglePrimaryKeyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 166, RULE_singlePrimaryKey);
        let mut _localctx: Rc<SinglePrimaryKeyContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule column*/
			recog.base.set_state(1380);
			recog.column()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- compoundKey ----------------
pub type CompoundKeyContextAll<'input> = CompoundKeyContext<'input>;


pub type CompoundKeyContext<'input> = BaseParserRuleContext<'input,CompoundKeyContextExt<'input>>;

#[derive(Clone)]
pub struct CompoundKeyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for CompoundKeyContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for CompoundKeyContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_compoundKey(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_compoundKey(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for CompoundKeyContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_compoundKey(self);
	}
}

impl<'input> CustomRuleContext<'input> for CompoundKeyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_compoundKey }
	//fn type_rule_index() -> usize where Self: Sized { RULE_compoundKey }
}
antlr_rust::type_id!{CompoundKeyContextExt<'a>}

impl<'input> CompoundKeyContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CompoundKeyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CompoundKeyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CompoundKeyContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<CompoundKeyContextExt<'input>>{

fn partitionKey(&self) -> Option<Rc<PartitionKeyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn syntaxComma(&self) -> Option<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn clusteringKeyList(&self) -> Option<Rc<ClusteringKeyListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CompoundKeyContextAttrs<'input> for CompoundKeyContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn compoundKey(&mut self,)
	-> Result<Rc<CompoundKeyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CompoundKeyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 168, RULE_compoundKey);
        let mut _localctx: Rc<CompoundKeyContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule partitionKey*/
			recog.base.set_state(1382);
			recog.partitionKey()?;

			{
			/*InvokeRule syntaxComma*/
			recog.base.set_state(1383);
			recog.syntaxComma()?;

			/*InvokeRule clusteringKeyList*/
			recog.base.set_state(1384);
			recog.clusteringKeyList()?;

			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- compositeKey ----------------
pub type CompositeKeyContextAll<'input> = CompositeKeyContext<'input>;


pub type CompositeKeyContext<'input> = BaseParserRuleContext<'input,CompositeKeyContextExt<'input>>;

#[derive(Clone)]
pub struct CompositeKeyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for CompositeKeyContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for CompositeKeyContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_compositeKey(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_compositeKey(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for CompositeKeyContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_compositeKey(self);
	}
}

impl<'input> CustomRuleContext<'input> for CompositeKeyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_compositeKey }
	//fn type_rule_index() -> usize where Self: Sized { RULE_compositeKey }
}
antlr_rust::type_id!{CompositeKeyContextExt<'a>}

impl<'input> CompositeKeyContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CompositeKeyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CompositeKeyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CompositeKeyContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<CompositeKeyContextExt<'input>>{

fn syntaxBracketLr(&self) -> Option<Rc<SyntaxBracketLrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn partitionKeyList(&self) -> Option<Rc<PartitionKeyListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn syntaxBracketRr(&self) -> Option<Rc<SyntaxBracketRrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn syntaxComma(&self) -> Option<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn clusteringKeyList(&self) -> Option<Rc<ClusteringKeyListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CompositeKeyContextAttrs<'input> for CompositeKeyContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn compositeKey(&mut self,)
	-> Result<Rc<CompositeKeyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CompositeKeyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 170, RULE_compositeKey);
        let mut _localctx: Rc<CompositeKeyContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule syntaxBracketLr*/
			recog.base.set_state(1386);
			recog.syntaxBracketLr()?;

			/*InvokeRule partitionKeyList*/
			recog.base.set_state(1387);
			recog.partitionKeyList()?;

			/*InvokeRule syntaxBracketRr*/
			recog.base.set_state(1388);
			recog.syntaxBracketRr()?;

			{
			/*InvokeRule syntaxComma*/
			recog.base.set_state(1389);
			recog.syntaxComma()?;

			/*InvokeRule clusteringKeyList*/
			recog.base.set_state(1390);
			recog.clusteringKeyList()?;

			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- partitionKeyList ----------------
pub type PartitionKeyListContextAll<'input> = PartitionKeyListContext<'input>;


pub type PartitionKeyListContext<'input> = BaseParserRuleContext<'input,PartitionKeyListContextExt<'input>>;

#[derive(Clone)]
pub struct PartitionKeyListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for PartitionKeyListContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for PartitionKeyListContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_partitionKeyList(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_partitionKeyList(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for PartitionKeyListContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_partitionKeyList(self);
	}
}

impl<'input> CustomRuleContext<'input> for PartitionKeyListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_partitionKeyList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_partitionKeyList }
}
antlr_rust::type_id!{PartitionKeyListContextExt<'a>}

impl<'input> PartitionKeyListContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PartitionKeyListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PartitionKeyListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PartitionKeyListContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<PartitionKeyListContextExt<'input>>{

fn partitionKey_all(&self) ->  Vec<Rc<PartitionKeyContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn partitionKey(&self, i: usize) -> Option<Rc<PartitionKeyContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn syntaxComma_all(&self) ->  Vec<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn syntaxComma(&self, i: usize) -> Option<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> PartitionKeyListContextAttrs<'input> for PartitionKeyListContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn partitionKeyList(&mut self,)
	-> Result<Rc<PartitionKeyListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PartitionKeyListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 172, RULE_partitionKeyList);
        let mut _localctx: Rc<PartitionKeyListContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule partitionKey*/
			recog.base.set_state(1392);
			recog.partitionKey()?;

			}
			recog.base.set_state(1398);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				/*InvokeRule syntaxComma*/
				recog.base.set_state(1393);
				recog.syntaxComma()?;

				/*InvokeRule partitionKey*/
				recog.base.set_state(1394);
				recog.partitionKey()?;

				}
				}
				recog.base.set_state(1400);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- clusteringKeyList ----------------
pub type ClusteringKeyListContextAll<'input> = ClusteringKeyListContext<'input>;


pub type ClusteringKeyListContext<'input> = BaseParserRuleContext<'input,ClusteringKeyListContextExt<'input>>;

#[derive(Clone)]
pub struct ClusteringKeyListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for ClusteringKeyListContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for ClusteringKeyListContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_clusteringKeyList(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_clusteringKeyList(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for ClusteringKeyListContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_clusteringKeyList(self);
	}
}

impl<'input> CustomRuleContext<'input> for ClusteringKeyListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_clusteringKeyList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_clusteringKeyList }
}
antlr_rust::type_id!{ClusteringKeyListContextExt<'a>}

impl<'input> ClusteringKeyListContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClusteringKeyListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClusteringKeyListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClusteringKeyListContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<ClusteringKeyListContextExt<'input>>{

fn clusteringKey_all(&self) ->  Vec<Rc<ClusteringKeyContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn clusteringKey(&self, i: usize) -> Option<Rc<ClusteringKeyContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn syntaxComma_all(&self) ->  Vec<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn syntaxComma(&self, i: usize) -> Option<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ClusteringKeyListContextAttrs<'input> for ClusteringKeyListContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn clusteringKeyList(&mut self,)
	-> Result<Rc<ClusteringKeyListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClusteringKeyListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 174, RULE_clusteringKeyList);
        let mut _localctx: Rc<ClusteringKeyListContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule clusteringKey*/
			recog.base.set_state(1401);
			recog.clusteringKey()?;

			}
			recog.base.set_state(1407);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				/*InvokeRule syntaxComma*/
				recog.base.set_state(1402);
				recog.syntaxComma()?;

				/*InvokeRule clusteringKey*/
				recog.base.set_state(1403);
				recog.clusteringKey()?;

				}
				}
				recog.base.set_state(1409);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- partitionKey ----------------
pub type PartitionKeyContextAll<'input> = PartitionKeyContext<'input>;


pub type PartitionKeyContext<'input> = BaseParserRuleContext<'input,PartitionKeyContextExt<'input>>;

#[derive(Clone)]
pub struct PartitionKeyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for PartitionKeyContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for PartitionKeyContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_partitionKey(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_partitionKey(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for PartitionKeyContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_partitionKey(self);
	}
}

impl<'input> CustomRuleContext<'input> for PartitionKeyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_partitionKey }
	//fn type_rule_index() -> usize where Self: Sized { RULE_partitionKey }
}
antlr_rust::type_id!{PartitionKeyContextExt<'a>}

impl<'input> PartitionKeyContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PartitionKeyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PartitionKeyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PartitionKeyContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<PartitionKeyContextExt<'input>>{

fn column(&self) -> Option<Rc<ColumnContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PartitionKeyContextAttrs<'input> for PartitionKeyContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn partitionKey(&mut self,)
	-> Result<Rc<PartitionKeyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PartitionKeyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 176, RULE_partitionKey);
        let mut _localctx: Rc<PartitionKeyContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule column*/
			recog.base.set_state(1410);
			recog.column()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- clusteringKey ----------------
pub type ClusteringKeyContextAll<'input> = ClusteringKeyContext<'input>;


pub type ClusteringKeyContext<'input> = BaseParserRuleContext<'input,ClusteringKeyContextExt<'input>>;

#[derive(Clone)]
pub struct ClusteringKeyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for ClusteringKeyContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for ClusteringKeyContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_clusteringKey(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_clusteringKey(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for ClusteringKeyContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_clusteringKey(self);
	}
}

impl<'input> CustomRuleContext<'input> for ClusteringKeyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_clusteringKey }
	//fn type_rule_index() -> usize where Self: Sized { RULE_clusteringKey }
}
antlr_rust::type_id!{ClusteringKeyContextExt<'a>}

impl<'input> ClusteringKeyContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClusteringKeyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClusteringKeyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClusteringKeyContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<ClusteringKeyContextExt<'input>>{

fn column(&self) -> Option<Rc<ColumnContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ClusteringKeyContextAttrs<'input> for ClusteringKeyContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn clusteringKey(&mut self,)
	-> Result<Rc<ClusteringKeyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClusteringKeyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 178, RULE_clusteringKey);
        let mut _localctx: Rc<ClusteringKeyContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule column*/
			recog.base.set_state(1412);
			recog.column()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- applyBatch ----------------
pub type ApplyBatchContextAll<'input> = ApplyBatchContext<'input>;


pub type ApplyBatchContext<'input> = BaseParserRuleContext<'input,ApplyBatchContextExt<'input>>;

#[derive(Clone)]
pub struct ApplyBatchContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for ApplyBatchContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for ApplyBatchContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_applyBatch(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_applyBatch(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for ApplyBatchContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_applyBatch(self);
	}
}

impl<'input> CustomRuleContext<'input> for ApplyBatchContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_applyBatch }
	//fn type_rule_index() -> usize where Self: Sized { RULE_applyBatch }
}
antlr_rust::type_id!{ApplyBatchContextExt<'a>}

impl<'input> ApplyBatchContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ApplyBatchContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ApplyBatchContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ApplyBatchContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<ApplyBatchContextExt<'input>>{

fn kwApply(&self) -> Option<Rc<KwApplyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwBatch(&self) -> Option<Rc<KwBatchContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ApplyBatchContextAttrs<'input> for ApplyBatchContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn applyBatch(&mut self,)
	-> Result<Rc<ApplyBatchContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ApplyBatchContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 180, RULE_applyBatch);
        let mut _localctx: Rc<ApplyBatchContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwApply*/
			recog.base.set_state(1414);
			recog.kwApply()?;

			/*InvokeRule kwBatch*/
			recog.base.set_state(1415);
			recog.kwBatch()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- beginBatch ----------------
pub type BeginBatchContextAll<'input> = BeginBatchContext<'input>;


pub type BeginBatchContext<'input> = BaseParserRuleContext<'input,BeginBatchContextExt<'input>>;

#[derive(Clone)]
pub struct BeginBatchContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for BeginBatchContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for BeginBatchContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_beginBatch(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_beginBatch(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for BeginBatchContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_beginBatch(self);
	}
}

impl<'input> CustomRuleContext<'input> for BeginBatchContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_beginBatch }
	//fn type_rule_index() -> usize where Self: Sized { RULE_beginBatch }
}
antlr_rust::type_id!{BeginBatchContextExt<'a>}

impl<'input> BeginBatchContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BeginBatchContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BeginBatchContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BeginBatchContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<BeginBatchContextExt<'input>>{

fn kwBegin(&self) -> Option<Rc<KwBeginContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwBatch(&self) -> Option<Rc<KwBatchContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn batchType(&self) -> Option<Rc<BatchTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn usingTimestampSpec(&self) -> Option<Rc<UsingTimestampSpecContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> BeginBatchContextAttrs<'input> for BeginBatchContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn beginBatch(&mut self,)
	-> Result<Rc<BeginBatchContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BeginBatchContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 182, RULE_beginBatch);
        let mut _localctx: Rc<BeginBatchContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwBegin*/
			recog.base.set_state(1417);
			recog.kwBegin()?;

			recog.base.set_state(1419);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_LOGGED || _la==K_UNLOGGED {
				{
				/*InvokeRule batchType*/
				recog.base.set_state(1418);
				recog.batchType()?;

				}
			}

			/*InvokeRule kwBatch*/
			recog.base.set_state(1421);
			recog.kwBatch()?;

			recog.base.set_state(1423);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_USING {
				{
				/*InvokeRule usingTimestampSpec*/
				recog.base.set_state(1422);
				recog.usingTimestampSpec()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- batchType ----------------
pub type BatchTypeContextAll<'input> = BatchTypeContext<'input>;


pub type BatchTypeContext<'input> = BaseParserRuleContext<'input,BatchTypeContextExt<'input>>;

#[derive(Clone)]
pub struct BatchTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for BatchTypeContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for BatchTypeContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_batchType(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_batchType(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for BatchTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_batchType(self);
	}
}

impl<'input> CustomRuleContext<'input> for BatchTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_batchType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_batchType }
}
antlr_rust::type_id!{BatchTypeContextExt<'a>}

impl<'input> BatchTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BatchTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BatchTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BatchTypeContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<BatchTypeContextExt<'input>>{

fn kwLogged(&self) -> Option<Rc<KwLoggedContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwUnlogged(&self) -> Option<Rc<KwUnloggedContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> BatchTypeContextAttrs<'input> for BatchTypeContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn batchType(&mut self,)
	-> Result<Rc<BatchTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BatchTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 184, RULE_batchType);
        let mut _localctx: Rc<BatchTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1427);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 K_LOGGED 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule kwLogged*/
					recog.base.set_state(1425);
					recog.kwLogged()?;

					}
				}

			 K_UNLOGGED 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule kwUnlogged*/
					recog.base.set_state(1426);
					recog.kwUnlogged()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- alterKeyspace ----------------
pub type AlterKeyspaceContextAll<'input> = AlterKeyspaceContext<'input>;


pub type AlterKeyspaceContext<'input> = BaseParserRuleContext<'input,AlterKeyspaceContextExt<'input>>;

#[derive(Clone)]
pub struct AlterKeyspaceContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for AlterKeyspaceContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for AlterKeyspaceContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_alterKeyspace(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_alterKeyspace(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for AlterKeyspaceContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_alterKeyspace(self);
	}
}

impl<'input> CustomRuleContext<'input> for AlterKeyspaceContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_alterKeyspace }
	//fn type_rule_index() -> usize where Self: Sized { RULE_alterKeyspace }
}
antlr_rust::type_id!{AlterKeyspaceContextExt<'a>}

impl<'input> AlterKeyspaceContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AlterKeyspaceContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AlterKeyspaceContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AlterKeyspaceContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<AlterKeyspaceContextExt<'input>>{

fn kwAlter(&self) -> Option<Rc<KwAlterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwKeyspace(&self) -> Option<Rc<KwKeyspaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn keyspace(&self) -> Option<Rc<KeyspaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwWith(&self) -> Option<Rc<KwWithContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwReplication(&self) -> Option<Rc<KwReplicationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token OPERATOR_EQ
/// Returns `None` if there is no child corresponding to token OPERATOR_EQ
fn OPERATOR_EQ(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OPERATOR_EQ, 0)
}
fn syntaxBracketLc(&self) -> Option<Rc<SyntaxBracketLcContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn replicationList(&self) -> Option<Rc<ReplicationListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn syntaxBracketRc(&self) -> Option<Rc<SyntaxBracketRcContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwAnd(&self) -> Option<Rc<KwAndContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn durableWrites(&self) -> Option<Rc<DurableWritesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AlterKeyspaceContextAttrs<'input> for AlterKeyspaceContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn alterKeyspace(&mut self,)
	-> Result<Rc<AlterKeyspaceContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AlterKeyspaceContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 186, RULE_alterKeyspace);
        let mut _localctx: Rc<AlterKeyspaceContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwAlter*/
			recog.base.set_state(1429);
			recog.kwAlter()?;

			/*InvokeRule kwKeyspace*/
			recog.base.set_state(1430);
			recog.kwKeyspace()?;

			/*InvokeRule keyspace*/
			recog.base.set_state(1431);
			recog.keyspace()?;

			/*InvokeRule kwWith*/
			recog.base.set_state(1432);
			recog.kwWith()?;

			/*InvokeRule kwReplication*/
			recog.base.set_state(1433);
			recog.kwReplication()?;

			recog.base.set_state(1434);
			recog.base.match_token(OPERATOR_EQ,&mut recog.err_handler)?;

			/*InvokeRule syntaxBracketLc*/
			recog.base.set_state(1435);
			recog.syntaxBracketLc()?;

			/*InvokeRule replicationList*/
			recog.base.set_state(1436);
			recog.replicationList()?;

			/*InvokeRule syntaxBracketRc*/
			recog.base.set_state(1437);
			recog.syntaxBracketRc()?;

			recog.base.set_state(1441);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_AND {
				{
				/*InvokeRule kwAnd*/
				recog.base.set_state(1438);
				recog.kwAnd()?;

				/*InvokeRule durableWrites*/
				recog.base.set_state(1439);
				recog.durableWrites()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- replicationList ----------------
pub type ReplicationListContextAll<'input> = ReplicationListContext<'input>;


pub type ReplicationListContext<'input> = BaseParserRuleContext<'input,ReplicationListContextExt<'input>>;

#[derive(Clone)]
pub struct ReplicationListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for ReplicationListContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for ReplicationListContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_replicationList(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_replicationList(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for ReplicationListContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_replicationList(self);
	}
}

impl<'input> CustomRuleContext<'input> for ReplicationListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_replicationList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_replicationList }
}
antlr_rust::type_id!{ReplicationListContextExt<'a>}

impl<'input> ReplicationListContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ReplicationListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ReplicationListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ReplicationListContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<ReplicationListContextExt<'input>>{

fn replicationListItem_all(&self) ->  Vec<Rc<ReplicationListItemContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn replicationListItem(&self, i: usize) -> Option<Rc<ReplicationListItemContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn syntaxComma_all(&self) ->  Vec<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn syntaxComma(&self, i: usize) -> Option<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ReplicationListContextAttrs<'input> for ReplicationListContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn replicationList(&mut self,)
	-> Result<Rc<ReplicationListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ReplicationListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 188, RULE_replicationList);
        let mut _localctx: Rc<ReplicationListContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule replicationListItem*/
			recog.base.set_state(1443);
			recog.replicationListItem()?;

			}
			recog.base.set_state(1449);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				/*InvokeRule syntaxComma*/
				recog.base.set_state(1444);
				recog.syntaxComma()?;

				/*InvokeRule replicationListItem*/
				recog.base.set_state(1445);
				recog.replicationListItem()?;

				}
				}
				recog.base.set_state(1451);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- replicationListItem ----------------
pub type ReplicationListItemContextAll<'input> = ReplicationListItemContext<'input>;


pub type ReplicationListItemContext<'input> = BaseParserRuleContext<'input,ReplicationListItemContextExt<'input>>;

#[derive(Clone)]
pub struct ReplicationListItemContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for ReplicationListItemContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for ReplicationListItemContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_replicationListItem(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_replicationListItem(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for ReplicationListItemContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_replicationListItem(self);
	}
}

impl<'input> CustomRuleContext<'input> for ReplicationListItemContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_replicationListItem }
	//fn type_rule_index() -> usize where Self: Sized { RULE_replicationListItem }
}
antlr_rust::type_id!{ReplicationListItemContextExt<'a>}

impl<'input> ReplicationListItemContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ReplicationListItemContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ReplicationListItemContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ReplicationListItemContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<ReplicationListItemContextExt<'input>>{

/// Retrieves all `TerminalNode`s corresponding to token STRING_LITERAL in current rule
fn STRING_LITERAL_all(&self) -> Vec<Rc<TerminalNode<'input,CqlParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token STRING_LITERAL, starting from 0.
/// Returns `None` if number of children corresponding to token STRING_LITERAL is less or equal than `i`.
fn STRING_LITERAL(&self, i: usize) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(STRING_LITERAL, i)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
/// Retrieves first TerminalNode corresponding to token DECIMAL_LITERAL
/// Returns `None` if there is no child corresponding to token DECIMAL_LITERAL
fn DECIMAL_LITERAL(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(DECIMAL_LITERAL, 0)
}

}

impl<'input> ReplicationListItemContextAttrs<'input> for ReplicationListItemContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn replicationListItem(&mut self,)
	-> Result<Rc<ReplicationListItemContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ReplicationListItemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 190, RULE_replicationListItem);
        let mut _localctx: Rc<ReplicationListItemContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1458);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(105,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1452);
					recog.base.match_token(STRING_LITERAL,&mut recog.err_handler)?;

					recog.base.set_state(1453);
					recog.base.match_token(COLON,&mut recog.err_handler)?;

					recog.base.set_state(1454);
					recog.base.match_token(STRING_LITERAL,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1455);
					recog.base.match_token(STRING_LITERAL,&mut recog.err_handler)?;

					recog.base.set_state(1456);
					recog.base.match_token(COLON,&mut recog.err_handler)?;

					recog.base.set_state(1457);
					recog.base.match_token(DECIMAL_LITERAL,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- durableWrites ----------------
pub type DurableWritesContextAll<'input> = DurableWritesContext<'input>;


pub type DurableWritesContext<'input> = BaseParserRuleContext<'input,DurableWritesContextExt<'input>>;

#[derive(Clone)]
pub struct DurableWritesContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for DurableWritesContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for DurableWritesContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_durableWrites(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_durableWrites(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for DurableWritesContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_durableWrites(self);
	}
}

impl<'input> CustomRuleContext<'input> for DurableWritesContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_durableWrites }
	//fn type_rule_index() -> usize where Self: Sized { RULE_durableWrites }
}
antlr_rust::type_id!{DurableWritesContextExt<'a>}

impl<'input> DurableWritesContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DurableWritesContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DurableWritesContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DurableWritesContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<DurableWritesContextExt<'input>>{

fn kwDurableWrites(&self) -> Option<Rc<KwDurableWritesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token OPERATOR_EQ
/// Returns `None` if there is no child corresponding to token OPERATOR_EQ
fn OPERATOR_EQ(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OPERATOR_EQ, 0)
}
fn booleanLiteral(&self) -> Option<Rc<BooleanLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DurableWritesContextAttrs<'input> for DurableWritesContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn durableWrites(&mut self,)
	-> Result<Rc<DurableWritesContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DurableWritesContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 192, RULE_durableWrites);
        let mut _localctx: Rc<DurableWritesContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwDurableWrites*/
			recog.base.set_state(1460);
			recog.kwDurableWrites()?;

			recog.base.set_state(1461);
			recog.base.match_token(OPERATOR_EQ,&mut recog.err_handler)?;

			/*InvokeRule booleanLiteral*/
			recog.base.set_state(1462);
			recog.booleanLiteral()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- use_ ----------------
pub type Use_ContextAll<'input> = Use_Context<'input>;


pub type Use_Context<'input> = BaseParserRuleContext<'input,Use_ContextExt<'input>>;

#[derive(Clone)]
pub struct Use_ContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for Use_Context<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for Use_Context<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_use_(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_use_(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for Use_Context<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_use_(self);
	}
}

impl<'input> CustomRuleContext<'input> for Use_ContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_use_ }
	//fn type_rule_index() -> usize where Self: Sized { RULE_use_ }
}
antlr_rust::type_id!{Use_ContextExt<'a>}

impl<'input> Use_ContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Use_ContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Use_ContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Use_ContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<Use_ContextExt<'input>>{

fn kwUse(&self) -> Option<Rc<KwUseContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn keyspace(&self) -> Option<Rc<KeyspaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> Use_ContextAttrs<'input> for Use_Context<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn use_(&mut self,)
	-> Result<Rc<Use_ContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Use_ContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 194, RULE_use_);
        let mut _localctx: Rc<Use_ContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwUse*/
			recog.base.set_state(1464);
			recog.kwUse()?;

			/*InvokeRule keyspace*/
			recog.base.set_state(1465);
			recog.keyspace()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- truncate ----------------
pub type TruncateContextAll<'input> = TruncateContext<'input>;


pub type TruncateContext<'input> = BaseParserRuleContext<'input,TruncateContextExt<'input>>;

#[derive(Clone)]
pub struct TruncateContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for TruncateContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for TruncateContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_truncate(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_truncate(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for TruncateContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_truncate(self);
	}
}

impl<'input> CustomRuleContext<'input> for TruncateContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_truncate }
	//fn type_rule_index() -> usize where Self: Sized { RULE_truncate }
}
antlr_rust::type_id!{TruncateContextExt<'a>}

impl<'input> TruncateContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TruncateContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TruncateContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TruncateContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<TruncateContextExt<'input>>{

fn kwTruncate(&self) -> Option<Rc<KwTruncateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn table(&self) -> Option<Rc<TableContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwTable(&self) -> Option<Rc<KwTableContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn keyspace(&self) -> Option<Rc<KeyspaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}

}

impl<'input> TruncateContextAttrs<'input> for TruncateContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn truncate(&mut self,)
	-> Result<Rc<TruncateContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TruncateContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 196, RULE_truncate);
        let mut _localctx: Rc<TruncateContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwTruncate*/
			recog.base.set_state(1467);
			recog.kwTruncate()?;

			recog.base.set_state(1469);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_TABLE {
				{
				/*InvokeRule kwTable*/
				recog.base.set_state(1468);
				recog.kwTable()?;

				}
			}

			recog.base.set_state(1474);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(107,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule keyspace*/
					recog.base.set_state(1471);
					recog.keyspace()?;

					recog.base.set_state(1472);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			/*InvokeRule table*/
			recog.base.set_state(1476);
			recog.table()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- createIndex ----------------
pub type CreateIndexContextAll<'input> = CreateIndexContext<'input>;


pub type CreateIndexContext<'input> = BaseParserRuleContext<'input,CreateIndexContextExt<'input>>;

#[derive(Clone)]
pub struct CreateIndexContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for CreateIndexContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for CreateIndexContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_createIndex(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_createIndex(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for CreateIndexContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_createIndex(self);
	}
}

impl<'input> CustomRuleContext<'input> for CreateIndexContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_createIndex }
	//fn type_rule_index() -> usize where Self: Sized { RULE_createIndex }
}
antlr_rust::type_id!{CreateIndexContextExt<'a>}

impl<'input> CreateIndexContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CreateIndexContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CreateIndexContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CreateIndexContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<CreateIndexContextExt<'input>>{

fn kwCreate(&self) -> Option<Rc<KwCreateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwIndex(&self) -> Option<Rc<KwIndexContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwOn(&self) -> Option<Rc<KwOnContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn table(&self) -> Option<Rc<TableContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn syntaxBracketLr(&self) -> Option<Rc<SyntaxBracketLrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn indexColumnSpec(&self) -> Option<Rc<IndexColumnSpecContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn syntaxBracketRr(&self) -> Option<Rc<SyntaxBracketRrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifNotExist(&self) -> Option<Rc<IfNotExistContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn indexName(&self) -> Option<Rc<IndexNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn keyspace(&self) -> Option<Rc<KeyspaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}

}

impl<'input> CreateIndexContextAttrs<'input> for CreateIndexContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn createIndex(&mut self,)
	-> Result<Rc<CreateIndexContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CreateIndexContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 198, RULE_createIndex);
        let mut _localctx: Rc<CreateIndexContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwCreate*/
			recog.base.set_state(1478);
			recog.kwCreate()?;

			/*InvokeRule kwIndex*/
			recog.base.set_state(1479);
			recog.kwIndex()?;

			recog.base.set_state(1481);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_IF {
				{
				/*InvokeRule ifNotExist*/
				recog.base.set_state(1480);
				recog.ifNotExist()?;

				}
			}

			recog.base.set_state(1484);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==STRING_LITERAL || _la==OBJECT_NAME {
				{
				/*InvokeRule indexName*/
				recog.base.set_state(1483);
				recog.indexName()?;

				}
			}

			/*InvokeRule kwOn*/
			recog.base.set_state(1486);
			recog.kwOn()?;

			recog.base.set_state(1490);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(110,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule keyspace*/
					recog.base.set_state(1487);
					recog.keyspace()?;

					recog.base.set_state(1488);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			/*InvokeRule table*/
			recog.base.set_state(1492);
			recog.table()?;

			/*InvokeRule syntaxBracketLr*/
			recog.base.set_state(1493);
			recog.syntaxBracketLr()?;

			/*InvokeRule indexColumnSpec*/
			recog.base.set_state(1494);
			recog.indexColumnSpec()?;

			/*InvokeRule syntaxBracketRr*/
			recog.base.set_state(1495);
			recog.syntaxBracketRr()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- indexName ----------------
pub type IndexNameContextAll<'input> = IndexNameContext<'input>;


pub type IndexNameContext<'input> = BaseParserRuleContext<'input,IndexNameContextExt<'input>>;

#[derive(Clone)]
pub struct IndexNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for IndexNameContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for IndexNameContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_indexName(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_indexName(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for IndexNameContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_indexName(self);
	}
}

impl<'input> CustomRuleContext<'input> for IndexNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_indexName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_indexName }
}
antlr_rust::type_id!{IndexNameContextExt<'a>}

impl<'input> IndexNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IndexNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IndexNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IndexNameContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<IndexNameContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OBJECT_NAME
/// Returns `None` if there is no child corresponding to token OBJECT_NAME
fn OBJECT_NAME(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OBJECT_NAME, 0)
}
fn stringLiteral(&self) -> Option<Rc<StringLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IndexNameContextAttrs<'input> for IndexNameContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn indexName(&mut self,)
	-> Result<Rc<IndexNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IndexNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 200, RULE_indexName);
        let mut _localctx: Rc<IndexNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1499);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 OBJECT_NAME 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1497);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					}
				}

			 STRING_LITERAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule stringLiteral*/
					recog.base.set_state(1498);
					recog.stringLiteral()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- indexColumnSpec ----------------
pub type IndexColumnSpecContextAll<'input> = IndexColumnSpecContext<'input>;


pub type IndexColumnSpecContext<'input> = BaseParserRuleContext<'input,IndexColumnSpecContextExt<'input>>;

#[derive(Clone)]
pub struct IndexColumnSpecContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for IndexColumnSpecContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for IndexColumnSpecContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_indexColumnSpec(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_indexColumnSpec(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for IndexColumnSpecContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_indexColumnSpec(self);
	}
}

impl<'input> CustomRuleContext<'input> for IndexColumnSpecContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_indexColumnSpec }
	//fn type_rule_index() -> usize where Self: Sized { RULE_indexColumnSpec }
}
antlr_rust::type_id!{IndexColumnSpecContextExt<'a>}

impl<'input> IndexColumnSpecContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IndexColumnSpecContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IndexColumnSpecContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IndexColumnSpecContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<IndexColumnSpecContextExt<'input>>{

fn column(&self) -> Option<Rc<ColumnContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn indexKeysSpec(&self) -> Option<Rc<IndexKeysSpecContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn indexEntriesSSpec(&self) -> Option<Rc<IndexEntriesSSpecContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn indexFullSpec(&self) -> Option<Rc<IndexFullSpecContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IndexColumnSpecContextAttrs<'input> for IndexColumnSpecContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn indexColumnSpec(&mut self,)
	-> Result<Rc<IndexColumnSpecContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IndexColumnSpecContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 202, RULE_indexColumnSpec);
        let mut _localctx: Rc<IndexColumnSpecContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1505);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 DQUOTE | OBJECT_NAME 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule column*/
					recog.base.set_state(1501);
					recog.column()?;

					}
				}

			 K_KEYS 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule indexKeysSpec*/
					recog.base.set_state(1502);
					recog.indexKeysSpec()?;

					}
				}

			 K_ENTRIES 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule indexEntriesSSpec*/
					recog.base.set_state(1503);
					recog.indexEntriesSSpec()?;

					}
				}

			 K_FULL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule indexFullSpec*/
					recog.base.set_state(1504);
					recog.indexFullSpec()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- indexKeysSpec ----------------
pub type IndexKeysSpecContextAll<'input> = IndexKeysSpecContext<'input>;


pub type IndexKeysSpecContext<'input> = BaseParserRuleContext<'input,IndexKeysSpecContextExt<'input>>;

#[derive(Clone)]
pub struct IndexKeysSpecContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for IndexKeysSpecContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for IndexKeysSpecContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_indexKeysSpec(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_indexKeysSpec(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for IndexKeysSpecContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_indexKeysSpec(self);
	}
}

impl<'input> CustomRuleContext<'input> for IndexKeysSpecContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_indexKeysSpec }
	//fn type_rule_index() -> usize where Self: Sized { RULE_indexKeysSpec }
}
antlr_rust::type_id!{IndexKeysSpecContextExt<'a>}

impl<'input> IndexKeysSpecContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IndexKeysSpecContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IndexKeysSpecContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IndexKeysSpecContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<IndexKeysSpecContextExt<'input>>{

fn kwKeys(&self) -> Option<Rc<KwKeysContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn syntaxBracketLr(&self) -> Option<Rc<SyntaxBracketLrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token OBJECT_NAME
/// Returns `None` if there is no child corresponding to token OBJECT_NAME
fn OBJECT_NAME(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OBJECT_NAME, 0)
}
fn syntaxBracketRr(&self) -> Option<Rc<SyntaxBracketRrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IndexKeysSpecContextAttrs<'input> for IndexKeysSpecContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn indexKeysSpec(&mut self,)
	-> Result<Rc<IndexKeysSpecContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IndexKeysSpecContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 204, RULE_indexKeysSpec);
        let mut _localctx: Rc<IndexKeysSpecContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwKeys*/
			recog.base.set_state(1507);
			recog.kwKeys()?;

			/*InvokeRule syntaxBracketLr*/
			recog.base.set_state(1508);
			recog.syntaxBracketLr()?;

			recog.base.set_state(1509);
			recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

			/*InvokeRule syntaxBracketRr*/
			recog.base.set_state(1510);
			recog.syntaxBracketRr()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- indexEntriesSSpec ----------------
pub type IndexEntriesSSpecContextAll<'input> = IndexEntriesSSpecContext<'input>;


pub type IndexEntriesSSpecContext<'input> = BaseParserRuleContext<'input,IndexEntriesSSpecContextExt<'input>>;

#[derive(Clone)]
pub struct IndexEntriesSSpecContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for IndexEntriesSSpecContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for IndexEntriesSSpecContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_indexEntriesSSpec(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_indexEntriesSSpec(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for IndexEntriesSSpecContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_indexEntriesSSpec(self);
	}
}

impl<'input> CustomRuleContext<'input> for IndexEntriesSSpecContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_indexEntriesSSpec }
	//fn type_rule_index() -> usize where Self: Sized { RULE_indexEntriesSSpec }
}
antlr_rust::type_id!{IndexEntriesSSpecContextExt<'a>}

impl<'input> IndexEntriesSSpecContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IndexEntriesSSpecContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IndexEntriesSSpecContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IndexEntriesSSpecContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<IndexEntriesSSpecContextExt<'input>>{

fn kwEntries(&self) -> Option<Rc<KwEntriesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn syntaxBracketLr(&self) -> Option<Rc<SyntaxBracketLrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token OBJECT_NAME
/// Returns `None` if there is no child corresponding to token OBJECT_NAME
fn OBJECT_NAME(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OBJECT_NAME, 0)
}
fn syntaxBracketRr(&self) -> Option<Rc<SyntaxBracketRrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IndexEntriesSSpecContextAttrs<'input> for IndexEntriesSSpecContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn indexEntriesSSpec(&mut self,)
	-> Result<Rc<IndexEntriesSSpecContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IndexEntriesSSpecContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 206, RULE_indexEntriesSSpec);
        let mut _localctx: Rc<IndexEntriesSSpecContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwEntries*/
			recog.base.set_state(1512);
			recog.kwEntries()?;

			/*InvokeRule syntaxBracketLr*/
			recog.base.set_state(1513);
			recog.syntaxBracketLr()?;

			recog.base.set_state(1514);
			recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

			/*InvokeRule syntaxBracketRr*/
			recog.base.set_state(1515);
			recog.syntaxBracketRr()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- indexFullSpec ----------------
pub type IndexFullSpecContextAll<'input> = IndexFullSpecContext<'input>;


pub type IndexFullSpecContext<'input> = BaseParserRuleContext<'input,IndexFullSpecContextExt<'input>>;

#[derive(Clone)]
pub struct IndexFullSpecContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for IndexFullSpecContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for IndexFullSpecContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_indexFullSpec(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_indexFullSpec(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for IndexFullSpecContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_indexFullSpec(self);
	}
}

impl<'input> CustomRuleContext<'input> for IndexFullSpecContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_indexFullSpec }
	//fn type_rule_index() -> usize where Self: Sized { RULE_indexFullSpec }
}
antlr_rust::type_id!{IndexFullSpecContextExt<'a>}

impl<'input> IndexFullSpecContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IndexFullSpecContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IndexFullSpecContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IndexFullSpecContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<IndexFullSpecContextExt<'input>>{

fn kwFull(&self) -> Option<Rc<KwFullContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn syntaxBracketLr(&self) -> Option<Rc<SyntaxBracketLrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token OBJECT_NAME
/// Returns `None` if there is no child corresponding to token OBJECT_NAME
fn OBJECT_NAME(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OBJECT_NAME, 0)
}
fn syntaxBracketRr(&self) -> Option<Rc<SyntaxBracketRrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IndexFullSpecContextAttrs<'input> for IndexFullSpecContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn indexFullSpec(&mut self,)
	-> Result<Rc<IndexFullSpecContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IndexFullSpecContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 208, RULE_indexFullSpec);
        let mut _localctx: Rc<IndexFullSpecContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwFull*/
			recog.base.set_state(1517);
			recog.kwFull()?;

			/*InvokeRule syntaxBracketLr*/
			recog.base.set_state(1518);
			recog.syntaxBracketLr()?;

			recog.base.set_state(1519);
			recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

			/*InvokeRule syntaxBracketRr*/
			recog.base.set_state(1520);
			recog.syntaxBracketRr()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- delete_ ----------------
pub type Delete_ContextAll<'input> = Delete_Context<'input>;


pub type Delete_Context<'input> = BaseParserRuleContext<'input,Delete_ContextExt<'input>>;

#[derive(Clone)]
pub struct Delete_ContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for Delete_Context<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for Delete_Context<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_delete_(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_delete_(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for Delete_Context<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_delete_(self);
	}
}

impl<'input> CustomRuleContext<'input> for Delete_ContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_delete_ }
	//fn type_rule_index() -> usize where Self: Sized { RULE_delete_ }
}
antlr_rust::type_id!{Delete_ContextExt<'a>}

impl<'input> Delete_ContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Delete_ContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Delete_ContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Delete_ContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<Delete_ContextExt<'input>>{

fn kwDelete(&self) -> Option<Rc<KwDeleteContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn fromSpec(&self) -> Option<Rc<FromSpecContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn whereSpec(&self) -> Option<Rc<WhereSpecContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn beginBatch(&self) -> Option<Rc<BeginBatchContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn deleteColumnList(&self) -> Option<Rc<DeleteColumnListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn usingTimestampSpec(&self) -> Option<Rc<UsingTimestampSpecContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifExist(&self) -> Option<Rc<IfExistContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifSpec(&self) -> Option<Rc<IfSpecContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> Delete_ContextAttrs<'input> for Delete_Context<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn delete_(&mut self,)
	-> Result<Rc<Delete_ContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Delete_ContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 210, RULE_delete_);
        let mut _localctx: Rc<Delete_ContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1523);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_BEGIN {
				{
				/*InvokeRule beginBatch*/
				recog.base.set_state(1522);
				recog.beginBatch()?;

				}
			}

			/*InvokeRule kwDelete*/
			recog.base.set_state(1525);
			recog.kwDelete()?;

			recog.base.set_state(1527);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==OBJECT_NAME {
				{
				/*InvokeRule deleteColumnList*/
				recog.base.set_state(1526);
				recog.deleteColumnList()?;

				}
			}

			/*InvokeRule fromSpec*/
			recog.base.set_state(1529);
			recog.fromSpec()?;

			recog.base.set_state(1531);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_USING {
				{
				/*InvokeRule usingTimestampSpec*/
				recog.base.set_state(1530);
				recog.usingTimestampSpec()?;

				}
			}

			/*InvokeRule whereSpec*/
			recog.base.set_state(1533);
			recog.whereSpec()?;

			recog.base.set_state(1536);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(116,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule ifExist*/
					recog.base.set_state(1534);
					recog.ifExist()?;

					}
				}

				x if x == 2=>{
					{
					/*InvokeRule ifSpec*/
					recog.base.set_state(1535);
					recog.ifSpec()?;

					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- deleteColumnList ----------------
pub type DeleteColumnListContextAll<'input> = DeleteColumnListContext<'input>;


pub type DeleteColumnListContext<'input> = BaseParserRuleContext<'input,DeleteColumnListContextExt<'input>>;

#[derive(Clone)]
pub struct DeleteColumnListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for DeleteColumnListContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for DeleteColumnListContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_deleteColumnList(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_deleteColumnList(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for DeleteColumnListContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_deleteColumnList(self);
	}
}

impl<'input> CustomRuleContext<'input> for DeleteColumnListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_deleteColumnList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_deleteColumnList }
}
antlr_rust::type_id!{DeleteColumnListContextExt<'a>}

impl<'input> DeleteColumnListContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DeleteColumnListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DeleteColumnListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DeleteColumnListContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<DeleteColumnListContextExt<'input>>{

fn deleteColumnItem_all(&self) ->  Vec<Rc<DeleteColumnItemContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn deleteColumnItem(&self, i: usize) -> Option<Rc<DeleteColumnItemContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn syntaxComma_all(&self) ->  Vec<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn syntaxComma(&self, i: usize) -> Option<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> DeleteColumnListContextAttrs<'input> for DeleteColumnListContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn deleteColumnList(&mut self,)
	-> Result<Rc<DeleteColumnListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DeleteColumnListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 212, RULE_deleteColumnList);
        let mut _localctx: Rc<DeleteColumnListContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule deleteColumnItem*/
			recog.base.set_state(1538);
			recog.deleteColumnItem()?;

			}
			recog.base.set_state(1544);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				/*InvokeRule syntaxComma*/
				recog.base.set_state(1539);
				recog.syntaxComma()?;

				/*InvokeRule deleteColumnItem*/
				recog.base.set_state(1540);
				recog.deleteColumnItem()?;

				}
				}
				recog.base.set_state(1546);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- deleteColumnItem ----------------
pub type DeleteColumnItemContextAll<'input> = DeleteColumnItemContext<'input>;


pub type DeleteColumnItemContext<'input> = BaseParserRuleContext<'input,DeleteColumnItemContextExt<'input>>;

#[derive(Clone)]
pub struct DeleteColumnItemContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for DeleteColumnItemContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for DeleteColumnItemContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_deleteColumnItem(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_deleteColumnItem(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for DeleteColumnItemContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_deleteColumnItem(self);
	}
}

impl<'input> CustomRuleContext<'input> for DeleteColumnItemContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_deleteColumnItem }
	//fn type_rule_index() -> usize where Self: Sized { RULE_deleteColumnItem }
}
antlr_rust::type_id!{DeleteColumnItemContextExt<'a>}

impl<'input> DeleteColumnItemContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DeleteColumnItemContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DeleteColumnItemContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DeleteColumnItemContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<DeleteColumnItemContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OBJECT_NAME
/// Returns `None` if there is no child corresponding to token OBJECT_NAME
fn OBJECT_NAME(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OBJECT_NAME, 0)
}
/// Retrieves first TerminalNode corresponding to token LS_BRACKET
/// Returns `None` if there is no child corresponding to token LS_BRACKET
fn LS_BRACKET(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(LS_BRACKET, 0)
}
/// Retrieves first TerminalNode corresponding to token RS_BRACKET
/// Returns `None` if there is no child corresponding to token RS_BRACKET
fn RS_BRACKET(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(RS_BRACKET, 0)
}
fn stringLiteral(&self) -> Option<Rc<StringLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn decimalLiteral(&self) -> Option<Rc<DecimalLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DeleteColumnItemContextAttrs<'input> for DeleteColumnItemContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn deleteColumnItem(&mut self,)
	-> Result<Rc<DeleteColumnItemContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DeleteColumnItemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 214, RULE_deleteColumnItem);
        let mut _localctx: Rc<DeleteColumnItemContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1556);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(119,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1547);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1548);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					recog.base.set_state(1549);
					recog.base.match_token(LS_BRACKET,&mut recog.err_handler)?;

					recog.base.set_state(1552);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 STRING_LITERAL 
						=> {
							{
							/*InvokeRule stringLiteral*/
							recog.base.set_state(1550);
							recog.stringLiteral()?;

							}
						}

					 DECIMAL_LITERAL 
						=> {
							{
							/*InvokeRule decimalLiteral*/
							recog.base.set_state(1551);
							recog.decimalLiteral()?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					recog.base.set_state(1554);
					recog.base.match_token(RS_BRACKET,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- update ----------------
pub type UpdateContextAll<'input> = UpdateContext<'input>;


pub type UpdateContext<'input> = BaseParserRuleContext<'input,UpdateContextExt<'input>>;

#[derive(Clone)]
pub struct UpdateContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for UpdateContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for UpdateContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_update(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_update(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for UpdateContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_update(self);
	}
}

impl<'input> CustomRuleContext<'input> for UpdateContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_update }
	//fn type_rule_index() -> usize where Self: Sized { RULE_update }
}
antlr_rust::type_id!{UpdateContextExt<'a>}

impl<'input> UpdateContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UpdateContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UpdateContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UpdateContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<UpdateContextExt<'input>>{

fn kwUpdate(&self) -> Option<Rc<KwUpdateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn table(&self) -> Option<Rc<TableContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwSet(&self) -> Option<Rc<KwSetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn assignments(&self) -> Option<Rc<AssignmentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn whereSpec(&self) -> Option<Rc<WhereSpecContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn beginBatch(&self) -> Option<Rc<BeginBatchContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn keyspace(&self) -> Option<Rc<KeyspaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
fn usingTtlTimestamp(&self) -> Option<Rc<UsingTtlTimestampContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifExist(&self) -> Option<Rc<IfExistContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifSpec(&self) -> Option<Rc<IfSpecContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UpdateContextAttrs<'input> for UpdateContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn update(&mut self,)
	-> Result<Rc<UpdateContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UpdateContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 216, RULE_update);
        let mut _localctx: Rc<UpdateContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1559);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_BEGIN {
				{
				/*InvokeRule beginBatch*/
				recog.base.set_state(1558);
				recog.beginBatch()?;

				}
			}

			/*InvokeRule kwUpdate*/
			recog.base.set_state(1561);
			recog.kwUpdate()?;

			recog.base.set_state(1565);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(121,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule keyspace*/
					recog.base.set_state(1562);
					recog.keyspace()?;

					recog.base.set_state(1563);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			/*InvokeRule table*/
			recog.base.set_state(1567);
			recog.table()?;

			recog.base.set_state(1569);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_USING {
				{
				/*InvokeRule usingTtlTimestamp*/
				recog.base.set_state(1568);
				recog.usingTtlTimestamp()?;

				}
			}

			/*InvokeRule kwSet*/
			recog.base.set_state(1571);
			recog.kwSet()?;

			/*InvokeRule assignments*/
			recog.base.set_state(1572);
			recog.assignments()?;

			/*InvokeRule whereSpec*/
			recog.base.set_state(1573);
			recog.whereSpec()?;

			recog.base.set_state(1576);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(123,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule ifExist*/
					recog.base.set_state(1574);
					recog.ifExist()?;

					}
				}

				x if x == 2=>{
					{
					/*InvokeRule ifSpec*/
					recog.base.set_state(1575);
					recog.ifSpec()?;

					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ifSpec ----------------
pub type IfSpecContextAll<'input> = IfSpecContext<'input>;


pub type IfSpecContext<'input> = BaseParserRuleContext<'input,IfSpecContextExt<'input>>;

#[derive(Clone)]
pub struct IfSpecContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for IfSpecContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for IfSpecContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_ifSpec(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_ifSpec(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for IfSpecContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_ifSpec(self);
	}
}

impl<'input> CustomRuleContext<'input> for IfSpecContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ifSpec }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ifSpec }
}
antlr_rust::type_id!{IfSpecContextExt<'a>}

impl<'input> IfSpecContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IfSpecContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IfSpecContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IfSpecContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<IfSpecContextExt<'input>>{

fn kwIf(&self) -> Option<Rc<KwIfContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifConditionList(&self) -> Option<Rc<IfConditionListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IfSpecContextAttrs<'input> for IfSpecContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ifSpec(&mut self,)
	-> Result<Rc<IfSpecContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IfSpecContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 218, RULE_ifSpec);
        let mut _localctx: Rc<IfSpecContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwIf*/
			recog.base.set_state(1578);
			recog.kwIf()?;

			/*InvokeRule ifConditionList*/
			recog.base.set_state(1579);
			recog.ifConditionList()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ifConditionList ----------------
pub type IfConditionListContextAll<'input> = IfConditionListContext<'input>;


pub type IfConditionListContext<'input> = BaseParserRuleContext<'input,IfConditionListContextExt<'input>>;

#[derive(Clone)]
pub struct IfConditionListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for IfConditionListContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for IfConditionListContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_ifConditionList(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_ifConditionList(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for IfConditionListContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_ifConditionList(self);
	}
}

impl<'input> CustomRuleContext<'input> for IfConditionListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ifConditionList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ifConditionList }
}
antlr_rust::type_id!{IfConditionListContextExt<'a>}

impl<'input> IfConditionListContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IfConditionListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IfConditionListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IfConditionListContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<IfConditionListContextExt<'input>>{

fn ifCondition_all(&self) ->  Vec<Rc<IfConditionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn ifCondition(&self, i: usize) -> Option<Rc<IfConditionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn kwAnd_all(&self) ->  Vec<Rc<KwAndContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn kwAnd(&self, i: usize) -> Option<Rc<KwAndContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> IfConditionListContextAttrs<'input> for IfConditionListContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ifConditionList(&mut self,)
	-> Result<Rc<IfConditionListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IfConditionListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 220, RULE_ifConditionList);
        let mut _localctx: Rc<IfConditionListContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule ifCondition*/
			recog.base.set_state(1581);
			recog.ifCondition()?;

			}
			recog.base.set_state(1587);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==K_AND {
				{
				{
				/*InvokeRule kwAnd*/
				recog.base.set_state(1582);
				recog.kwAnd()?;

				/*InvokeRule ifCondition*/
				recog.base.set_state(1583);
				recog.ifCondition()?;

				}
				}
				recog.base.set_state(1589);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ifCondition ----------------
pub type IfConditionContextAll<'input> = IfConditionContext<'input>;


pub type IfConditionContext<'input> = BaseParserRuleContext<'input,IfConditionContextExt<'input>>;

#[derive(Clone)]
pub struct IfConditionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for IfConditionContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for IfConditionContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_ifCondition(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_ifCondition(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for IfConditionContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_ifCondition(self);
	}
}

impl<'input> CustomRuleContext<'input> for IfConditionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ifCondition }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ifCondition }
}
antlr_rust::type_id!{IfConditionContextExt<'a>}

impl<'input> IfConditionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IfConditionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IfConditionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IfConditionContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<IfConditionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OBJECT_NAME
/// Returns `None` if there is no child corresponding to token OBJECT_NAME
fn OBJECT_NAME(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OBJECT_NAME, 0)
}
/// Retrieves first TerminalNode corresponding to token OPERATOR_EQ
/// Returns `None` if there is no child corresponding to token OPERATOR_EQ
fn OPERATOR_EQ(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OPERATOR_EQ, 0)
}
fn constant(&self) -> Option<Rc<ConstantContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IfConditionContextAttrs<'input> for IfConditionContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ifCondition(&mut self,)
	-> Result<Rc<IfConditionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IfConditionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 222, RULE_ifCondition);
        let mut _localctx: Rc<IfConditionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1590);
			recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

			recog.base.set_state(1591);
			recog.base.match_token(OPERATOR_EQ,&mut recog.err_handler)?;

			/*InvokeRule constant*/
			recog.base.set_state(1592);
			recog.constant()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- assignments ----------------
pub type AssignmentsContextAll<'input> = AssignmentsContext<'input>;


pub type AssignmentsContext<'input> = BaseParserRuleContext<'input,AssignmentsContextExt<'input>>;

#[derive(Clone)]
pub struct AssignmentsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for AssignmentsContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for AssignmentsContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_assignments(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_assignments(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for AssignmentsContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_assignments(self);
	}
}

impl<'input> CustomRuleContext<'input> for AssignmentsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_assignments }
	//fn type_rule_index() -> usize where Self: Sized { RULE_assignments }
}
antlr_rust::type_id!{AssignmentsContextExt<'a>}

impl<'input> AssignmentsContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AssignmentsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AssignmentsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AssignmentsContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<AssignmentsContextExt<'input>>{

fn assignmentElement_all(&self) ->  Vec<Rc<AssignmentElementContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn assignmentElement(&self, i: usize) -> Option<Rc<AssignmentElementContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn syntaxComma_all(&self) ->  Vec<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn syntaxComma(&self, i: usize) -> Option<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> AssignmentsContextAttrs<'input> for AssignmentsContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn assignments(&mut self,)
	-> Result<Rc<AssignmentsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AssignmentsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 224, RULE_assignments);
        let mut _localctx: Rc<AssignmentsContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule assignmentElement*/
			recog.base.set_state(1594);
			recog.assignmentElement()?;

			}
			recog.base.set_state(1600);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				/*InvokeRule syntaxComma*/
				recog.base.set_state(1595);
				recog.syntaxComma()?;

				/*InvokeRule assignmentElement*/
				recog.base.set_state(1596);
				recog.assignmentElement()?;

				}
				}
				recog.base.set_state(1602);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- assignmentElement ----------------
pub type AssignmentElementContextAll<'input> = AssignmentElementContext<'input>;


pub type AssignmentElementContext<'input> = BaseParserRuleContext<'input,AssignmentElementContextExt<'input>>;

#[derive(Clone)]
pub struct AssignmentElementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for AssignmentElementContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for AssignmentElementContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_assignmentElement(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_assignmentElement(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for AssignmentElementContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_assignmentElement(self);
	}
}

impl<'input> CustomRuleContext<'input> for AssignmentElementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_assignmentElement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_assignmentElement }
}
antlr_rust::type_id!{AssignmentElementContextExt<'a>}

impl<'input> AssignmentElementContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AssignmentElementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AssignmentElementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AssignmentElementContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<AssignmentElementContextExt<'input>>{

/// Retrieves all `TerminalNode`s corresponding to token OBJECT_NAME in current rule
fn OBJECT_NAME_all(&self) -> Vec<Rc<TerminalNode<'input,CqlParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token OBJECT_NAME, starting from 0.
/// Returns `None` if number of children corresponding to token OBJECT_NAME is less or equal than `i`.
fn OBJECT_NAME(&self, i: usize) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OBJECT_NAME, i)
}
/// Retrieves first TerminalNode corresponding to token OPERATOR_EQ
/// Returns `None` if there is no child corresponding to token OPERATOR_EQ
fn OPERATOR_EQ(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OPERATOR_EQ, 0)
}
fn constant(&self) -> Option<Rc<ConstantContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn assignmentMap(&self) -> Option<Rc<AssignmentMapContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn assignmentSet(&self) -> Option<Rc<AssignmentSetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn assignmentList(&self) -> Option<Rc<AssignmentListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn decimalLiteral(&self) -> Option<Rc<DecimalLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token PLUS
/// Returns `None` if there is no child corresponding to token PLUS
fn PLUS(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(PLUS, 0)
}
/// Retrieves first TerminalNode corresponding to token MINUS
/// Returns `None` if there is no child corresponding to token MINUS
fn MINUS(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(MINUS, 0)
}
fn syntaxBracketLs(&self) -> Option<Rc<SyntaxBracketLsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn syntaxBracketRs(&self) -> Option<Rc<SyntaxBracketRsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AssignmentElementContextAttrs<'input> for AssignmentElementContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn assignmentElement(&mut self,)
	-> Result<Rc<AssignmentElementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AssignmentElementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 226, RULE_assignmentElement);
        let mut _localctx: Rc<AssignmentElementContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1656);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(127,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1603);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					recog.base.set_state(1604);
					recog.base.match_token(OPERATOR_EQ,&mut recog.err_handler)?;

					recog.base.set_state(1609);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(126,&mut recog.base)? {
						1 =>{
							{
							/*InvokeRule constant*/
							recog.base.set_state(1605);
							recog.constant()?;

							}
						}
					,
						2 =>{
							{
							/*InvokeRule assignmentMap*/
							recog.base.set_state(1606);
							recog.assignmentMap()?;

							}
						}
					,
						3 =>{
							{
							/*InvokeRule assignmentSet*/
							recog.base.set_state(1607);
							recog.assignmentSet()?;

							}
						}
					,
						4 =>{
							{
							/*InvokeRule assignmentList*/
							recog.base.set_state(1608);
							recog.assignmentList()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1611);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					recog.base.set_state(1612);
					recog.base.match_token(OPERATOR_EQ,&mut recog.err_handler)?;

					recog.base.set_state(1613);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					recog.base.set_state(1614);
					_la = recog.base.input.la(1);
					if { !(_la==PLUS || _la==MINUS) } {
						recog.err_handler.recover_inline(&mut recog.base)?;

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					/*InvokeRule decimalLiteral*/
					recog.base.set_state(1615);
					recog.decimalLiteral()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(1616);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					recog.base.set_state(1617);
					recog.base.match_token(OPERATOR_EQ,&mut recog.err_handler)?;

					recog.base.set_state(1618);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					recog.base.set_state(1619);
					_la = recog.base.input.la(1);
					if { !(_la==PLUS || _la==MINUS) } {
						recog.err_handler.recover_inline(&mut recog.base)?;

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					/*InvokeRule assignmentSet*/
					recog.base.set_state(1620);
					recog.assignmentSet()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(1621);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					recog.base.set_state(1622);
					recog.base.match_token(OPERATOR_EQ,&mut recog.err_handler)?;

					/*InvokeRule assignmentSet*/
					recog.base.set_state(1623);
					recog.assignmentSet()?;

					recog.base.set_state(1624);
					_la = recog.base.input.la(1);
					if { !(_la==PLUS || _la==MINUS) } {
						recog.err_handler.recover_inline(&mut recog.base)?;

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					recog.base.set_state(1625);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(1627);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					recog.base.set_state(1628);
					recog.base.match_token(OPERATOR_EQ,&mut recog.err_handler)?;

					recog.base.set_state(1629);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					recog.base.set_state(1630);
					_la = recog.base.input.la(1);
					if { !(_la==PLUS || _la==MINUS) } {
						recog.err_handler.recover_inline(&mut recog.base)?;

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					/*InvokeRule assignmentMap*/
					recog.base.set_state(1631);
					recog.assignmentMap()?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					recog.base.set_state(1632);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					recog.base.set_state(1633);
					recog.base.match_token(OPERATOR_EQ,&mut recog.err_handler)?;

					/*InvokeRule assignmentMap*/
					recog.base.set_state(1634);
					recog.assignmentMap()?;

					recog.base.set_state(1635);
					_la = recog.base.input.la(1);
					if { !(_la==PLUS || _la==MINUS) } {
						recog.err_handler.recover_inline(&mut recog.base)?;

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					recog.base.set_state(1636);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					}
				}
			,
				7 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					recog.base.set_state(1638);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					recog.base.set_state(1639);
					recog.base.match_token(OPERATOR_EQ,&mut recog.err_handler)?;

					recog.base.set_state(1640);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					recog.base.set_state(1641);
					_la = recog.base.input.la(1);
					if { !(_la==PLUS || _la==MINUS) } {
						recog.err_handler.recover_inline(&mut recog.base)?;

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					/*InvokeRule assignmentList*/
					recog.base.set_state(1642);
					recog.assignmentList()?;

					}
				}
			,
				8 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					recog.base.set_state(1643);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					recog.base.set_state(1644);
					recog.base.match_token(OPERATOR_EQ,&mut recog.err_handler)?;

					/*InvokeRule assignmentList*/
					recog.base.set_state(1645);
					recog.assignmentList()?;

					recog.base.set_state(1646);
					_la = recog.base.input.la(1);
					if { !(_la==PLUS || _la==MINUS) } {
						recog.err_handler.recover_inline(&mut recog.base)?;

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					recog.base.set_state(1647);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					}
				}
			,
				9 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 9);
					recog.base.enter_outer_alt(None, 9);
					{
					recog.base.set_state(1649);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					/*InvokeRule syntaxBracketLs*/
					recog.base.set_state(1650);
					recog.syntaxBracketLs()?;

					/*InvokeRule decimalLiteral*/
					recog.base.set_state(1651);
					recog.decimalLiteral()?;

					/*InvokeRule syntaxBracketRs*/
					recog.base.set_state(1652);
					recog.syntaxBracketRs()?;

					recog.base.set_state(1653);
					recog.base.match_token(OPERATOR_EQ,&mut recog.err_handler)?;

					/*InvokeRule constant*/
					recog.base.set_state(1654);
					recog.constant()?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- assignmentSet ----------------
pub type AssignmentSetContextAll<'input> = AssignmentSetContext<'input>;


pub type AssignmentSetContext<'input> = BaseParserRuleContext<'input,AssignmentSetContextExt<'input>>;

#[derive(Clone)]
pub struct AssignmentSetContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for AssignmentSetContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for AssignmentSetContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_assignmentSet(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_assignmentSet(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for AssignmentSetContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_assignmentSet(self);
	}
}

impl<'input> CustomRuleContext<'input> for AssignmentSetContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_assignmentSet }
	//fn type_rule_index() -> usize where Self: Sized { RULE_assignmentSet }
}
antlr_rust::type_id!{AssignmentSetContextExt<'a>}

impl<'input> AssignmentSetContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AssignmentSetContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AssignmentSetContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AssignmentSetContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<AssignmentSetContextExt<'input>>{

fn syntaxBracketLc(&self) -> Option<Rc<SyntaxBracketLcContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn syntaxBracketRc(&self) -> Option<Rc<SyntaxBracketRcContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn constant_all(&self) ->  Vec<Rc<ConstantContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn constant(&self, i: usize) -> Option<Rc<ConstantContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn syntaxComma_all(&self) ->  Vec<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn syntaxComma(&self, i: usize) -> Option<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> AssignmentSetContextAttrs<'input> for AssignmentSetContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn assignmentSet(&mut self,)
	-> Result<Rc<AssignmentSetContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AssignmentSetContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 228, RULE_assignmentSet);
        let mut _localctx: Rc<AssignmentSetContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule syntaxBracketLc*/
			recog.base.set_state(1658);
			recog.syntaxBracketLc()?;

			recog.base.set_state(1668);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_FALSE || _la==K_NULL || ((((_la - 125)) & !0x3f) == 0 && ((1usize << (_la - 125)) & ((1usize << (K_TRUE - 125)) | (1usize << (CODE_BLOCK - 125)) | (1usize << (STRING_LITERAL - 125)) | (1usize << (DECIMAL_LITERAL - 125)) | (1usize << (FLOAT_LITERAL - 125)) | (1usize << (HEXADECIMAL_LITERAL - 125)) | (1usize << (UUID - 125)))) != 0) {
				{
				/*InvokeRule constant*/
				recog.base.set_state(1659);
				recog.constant()?;

				recog.base.set_state(1665);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				while _la==COMMA {
					{
					{
					/*InvokeRule syntaxComma*/
					recog.base.set_state(1660);
					recog.syntaxComma()?;

					/*InvokeRule constant*/
					recog.base.set_state(1661);
					recog.constant()?;

					}
					}
					recog.base.set_state(1667);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
				}
				}
			}

			/*InvokeRule syntaxBracketRc*/
			recog.base.set_state(1670);
			recog.syntaxBracketRc()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- assignmentMap ----------------
pub type AssignmentMapContextAll<'input> = AssignmentMapContext<'input>;


pub type AssignmentMapContext<'input> = BaseParserRuleContext<'input,AssignmentMapContextExt<'input>>;

#[derive(Clone)]
pub struct AssignmentMapContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for AssignmentMapContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for AssignmentMapContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_assignmentMap(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_assignmentMap(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for AssignmentMapContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_assignmentMap(self);
	}
}

impl<'input> CustomRuleContext<'input> for AssignmentMapContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_assignmentMap }
	//fn type_rule_index() -> usize where Self: Sized { RULE_assignmentMap }
}
antlr_rust::type_id!{AssignmentMapContextExt<'a>}

impl<'input> AssignmentMapContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AssignmentMapContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AssignmentMapContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AssignmentMapContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<AssignmentMapContextExt<'input>>{

fn syntaxBracketLc(&self) -> Option<Rc<SyntaxBracketLcContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn syntaxBracketRc(&self) -> Option<Rc<SyntaxBracketRcContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn constant_all(&self) ->  Vec<Rc<ConstantContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn constant(&self, i: usize) -> Option<Rc<ConstantContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn syntaxColon_all(&self) ->  Vec<Rc<SyntaxColonContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn syntaxColon(&self, i: usize) -> Option<Rc<SyntaxColonContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn syntaxComma_all(&self) ->  Vec<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn syntaxComma(&self, i: usize) -> Option<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> AssignmentMapContextAttrs<'input> for AssignmentMapContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn assignmentMap(&mut self,)
	-> Result<Rc<AssignmentMapContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AssignmentMapContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 230, RULE_assignmentMap);
        let mut _localctx: Rc<AssignmentMapContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule syntaxBracketLc*/
			recog.base.set_state(1672);
			recog.syntaxBracketLc()?;

			{
			/*InvokeRule constant*/
			recog.base.set_state(1673);
			recog.constant()?;

			/*InvokeRule syntaxColon*/
			recog.base.set_state(1674);
			recog.syntaxColon()?;

			/*InvokeRule constant*/
			recog.base.set_state(1675);
			recog.constant()?;

			}
			recog.base.set_state(1684);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				/*InvokeRule syntaxComma*/
				recog.base.set_state(1677);
				recog.syntaxComma()?;

				/*InvokeRule constant*/
				recog.base.set_state(1678);
				recog.constant()?;

				/*InvokeRule syntaxColon*/
				recog.base.set_state(1679);
				recog.syntaxColon()?;

				/*InvokeRule constant*/
				recog.base.set_state(1680);
				recog.constant()?;

				}
				}
				recog.base.set_state(1686);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule syntaxBracketRc*/
			recog.base.set_state(1687);
			recog.syntaxBracketRc()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- assignmentList ----------------
pub type AssignmentListContextAll<'input> = AssignmentListContext<'input>;


pub type AssignmentListContext<'input> = BaseParserRuleContext<'input,AssignmentListContextExt<'input>>;

#[derive(Clone)]
pub struct AssignmentListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for AssignmentListContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for AssignmentListContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_assignmentList(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_assignmentList(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for AssignmentListContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_assignmentList(self);
	}
}

impl<'input> CustomRuleContext<'input> for AssignmentListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_assignmentList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_assignmentList }
}
antlr_rust::type_id!{AssignmentListContextExt<'a>}

impl<'input> AssignmentListContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AssignmentListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AssignmentListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AssignmentListContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<AssignmentListContextExt<'input>>{

fn syntaxBracketLs(&self) -> Option<Rc<SyntaxBracketLsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn constant_all(&self) ->  Vec<Rc<ConstantContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn constant(&self, i: usize) -> Option<Rc<ConstantContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn syntaxBracketRs(&self) -> Option<Rc<SyntaxBracketRsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn syntaxComma_all(&self) ->  Vec<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn syntaxComma(&self, i: usize) -> Option<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> AssignmentListContextAttrs<'input> for AssignmentListContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn assignmentList(&mut self,)
	-> Result<Rc<AssignmentListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AssignmentListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 232, RULE_assignmentList);
        let mut _localctx: Rc<AssignmentListContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule syntaxBracketLs*/
			recog.base.set_state(1689);
			recog.syntaxBracketLs()?;

			/*InvokeRule constant*/
			recog.base.set_state(1690);
			recog.constant()?;

			recog.base.set_state(1696);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				/*InvokeRule syntaxComma*/
				recog.base.set_state(1691);
				recog.syntaxComma()?;

				/*InvokeRule constant*/
				recog.base.set_state(1692);
				recog.constant()?;

				}
				}
				recog.base.set_state(1698);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule syntaxBracketRs*/
			recog.base.set_state(1699);
			recog.syntaxBracketRs()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- assignmentTuple ----------------
pub type AssignmentTupleContextAll<'input> = AssignmentTupleContext<'input>;


pub type AssignmentTupleContext<'input> = BaseParserRuleContext<'input,AssignmentTupleContextExt<'input>>;

#[derive(Clone)]
pub struct AssignmentTupleContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for AssignmentTupleContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for AssignmentTupleContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_assignmentTuple(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_assignmentTuple(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for AssignmentTupleContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_assignmentTuple(self);
	}
}

impl<'input> CustomRuleContext<'input> for AssignmentTupleContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_assignmentTuple }
	//fn type_rule_index() -> usize where Self: Sized { RULE_assignmentTuple }
}
antlr_rust::type_id!{AssignmentTupleContextExt<'a>}

impl<'input> AssignmentTupleContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AssignmentTupleContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AssignmentTupleContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AssignmentTupleContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<AssignmentTupleContextExt<'input>>{

fn syntaxBracketLr(&self) -> Option<Rc<SyntaxBracketLrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn syntaxBracketRr(&self) -> Option<Rc<SyntaxBracketRrContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn constant_all(&self) ->  Vec<Rc<ConstantContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn constant(&self, i: usize) -> Option<Rc<ConstantContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn assignmentTuple_all(&self) ->  Vec<Rc<AssignmentTupleContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn assignmentTuple(&self, i: usize) -> Option<Rc<AssignmentTupleContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn syntaxComma_all(&self) ->  Vec<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn syntaxComma(&self, i: usize) -> Option<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> AssignmentTupleContextAttrs<'input> for AssignmentTupleContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn assignmentTuple(&mut self,)
	-> Result<Rc<AssignmentTupleContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AssignmentTupleContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 234, RULE_assignmentTuple);
        let mut _localctx: Rc<AssignmentTupleContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule syntaxBracketLr*/
			recog.base.set_state(1701);
			recog.syntaxBracketLr()?;

			recog.base.set_state(1730);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 K_FALSE | K_NULL | K_TRUE | CODE_BLOCK | STRING_LITERAL | DECIMAL_LITERAL |
			 FLOAT_LITERAL | HEXADECIMAL_LITERAL | UUID 
				=> {
					{
					/*InvokeRule constant*/
					recog.base.set_state(1702);
					recog.constant()?;

					recog.base.set_state(1719);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(134,&mut recog.base)? {
						1 =>{
							{
							recog.base.set_state(1708);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==COMMA {
								{
								{
								/*InvokeRule syntaxComma*/
								recog.base.set_state(1703);
								recog.syntaxComma()?;

								/*InvokeRule constant*/
								recog.base.set_state(1704);
								recog.constant()?;

								}
								}
								recog.base.set_state(1710);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							}
						}
					,
						2 =>{
							{
							recog.base.set_state(1716);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==COMMA {
								{
								{
								/*InvokeRule syntaxComma*/
								recog.base.set_state(1711);
								recog.syntaxComma()?;

								/*InvokeRule assignmentTuple*/
								recog.base.set_state(1712);
								recog.assignmentTuple()?;

								}
								}
								recog.base.set_state(1718);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							}
						}

						_ => {}
					}
					}
				}

			 LR_BRACKET 
				=> {
					{
					/*InvokeRule assignmentTuple*/
					recog.base.set_state(1721);
					recog.assignmentTuple()?;

					recog.base.set_state(1727);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==COMMA {
						{
						{
						/*InvokeRule syntaxComma*/
						recog.base.set_state(1722);
						recog.syntaxComma()?;

						/*InvokeRule assignmentTuple*/
						recog.base.set_state(1723);
						recog.assignmentTuple()?;

						}
						}
						recog.base.set_state(1729);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			/*InvokeRule syntaxBracketRr*/
			recog.base.set_state(1732);
			recog.syntaxBracketRr()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- insert ----------------
pub type InsertContextAll<'input> = InsertContext<'input>;


pub type InsertContext<'input> = BaseParserRuleContext<'input,InsertContextExt<'input>>;

#[derive(Clone)]
pub struct InsertContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for InsertContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for InsertContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_insert(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_insert(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for InsertContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_insert(self);
	}
}

impl<'input> CustomRuleContext<'input> for InsertContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_insert }
	//fn type_rule_index() -> usize where Self: Sized { RULE_insert }
}
antlr_rust::type_id!{InsertContextExt<'a>}

impl<'input> InsertContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InsertContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InsertContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InsertContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<InsertContextExt<'input>>{

fn kwInsert(&self) -> Option<Rc<KwInsertContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwInto(&self) -> Option<Rc<KwIntoContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn table(&self) -> Option<Rc<TableContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn insertValuesSpec(&self) -> Option<Rc<InsertValuesSpecContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn beginBatch(&self) -> Option<Rc<BeginBatchContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn keyspace(&self) -> Option<Rc<KeyspaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
fn insertColumnSpec(&self) -> Option<Rc<InsertColumnSpecContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifNotExist(&self) -> Option<Rc<IfNotExistContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn usingTtlTimestamp(&self) -> Option<Rc<UsingTtlTimestampContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InsertContextAttrs<'input> for InsertContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn insert(&mut self,)
	-> Result<Rc<InsertContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InsertContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 236, RULE_insert);
        let mut _localctx: Rc<InsertContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1735);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_BEGIN {
				{
				/*InvokeRule beginBatch*/
				recog.base.set_state(1734);
				recog.beginBatch()?;

				}
			}

			/*InvokeRule kwInsert*/
			recog.base.set_state(1737);
			recog.kwInsert()?;

			/*InvokeRule kwInto*/
			recog.base.set_state(1738);
			recog.kwInto()?;

			recog.base.set_state(1742);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(138,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule keyspace*/
					recog.base.set_state(1739);
					recog.keyspace()?;

					recog.base.set_state(1740);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			/*InvokeRule table*/
			recog.base.set_state(1744);
			recog.table()?;

			recog.base.set_state(1746);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LR_BRACKET {
				{
				/*InvokeRule insertColumnSpec*/
				recog.base.set_state(1745);
				recog.insertColumnSpec()?;

				}
			}

			/*InvokeRule insertValuesSpec*/
			recog.base.set_state(1748);
			recog.insertValuesSpec()?;

			recog.base.set_state(1750);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_IF {
				{
				/*InvokeRule ifNotExist*/
				recog.base.set_state(1749);
				recog.ifNotExist()?;

				}
			}

			recog.base.set_state(1753);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_USING {
				{
				/*InvokeRule usingTtlTimestamp*/
				recog.base.set_state(1752);
				recog.usingTtlTimestamp()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- usingTtlTimestamp ----------------
pub type UsingTtlTimestampContextAll<'input> = UsingTtlTimestampContext<'input>;


pub type UsingTtlTimestampContext<'input> = BaseParserRuleContext<'input,UsingTtlTimestampContextExt<'input>>;

#[derive(Clone)]
pub struct UsingTtlTimestampContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for UsingTtlTimestampContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for UsingTtlTimestampContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_usingTtlTimestamp(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_usingTtlTimestamp(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for UsingTtlTimestampContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_usingTtlTimestamp(self);
	}
}

impl<'input> CustomRuleContext<'input> for UsingTtlTimestampContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_usingTtlTimestamp }
	//fn type_rule_index() -> usize where Self: Sized { RULE_usingTtlTimestamp }
}
antlr_rust::type_id!{UsingTtlTimestampContextExt<'a>}

impl<'input> UsingTtlTimestampContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UsingTtlTimestampContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UsingTtlTimestampContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UsingTtlTimestampContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<UsingTtlTimestampContextExt<'input>>{

fn kwUsing(&self) -> Option<Rc<KwUsingContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ttl(&self) -> Option<Rc<TtlContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwAnd(&self) -> Option<Rc<KwAndContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn timestamp(&self) -> Option<Rc<TimestampContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UsingTtlTimestampContextAttrs<'input> for UsingTtlTimestampContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn usingTtlTimestamp(&mut self,)
	-> Result<Rc<UsingTtlTimestampContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UsingTtlTimestampContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 238, RULE_usingTtlTimestamp);
        let mut _localctx: Rc<UsingTtlTimestampContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1771);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(142,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule kwUsing*/
					recog.base.set_state(1755);
					recog.kwUsing()?;

					/*InvokeRule ttl*/
					recog.base.set_state(1756);
					recog.ttl()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule kwUsing*/
					recog.base.set_state(1758);
					recog.kwUsing()?;

					/*InvokeRule ttl*/
					recog.base.set_state(1759);
					recog.ttl()?;

					/*InvokeRule kwAnd*/
					recog.base.set_state(1760);
					recog.kwAnd()?;

					/*InvokeRule timestamp*/
					recog.base.set_state(1761);
					recog.timestamp()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule kwUsing*/
					recog.base.set_state(1763);
					recog.kwUsing()?;

					/*InvokeRule timestamp*/
					recog.base.set_state(1764);
					recog.timestamp()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule kwUsing*/
					recog.base.set_state(1766);
					recog.kwUsing()?;

					/*InvokeRule timestamp*/
					recog.base.set_state(1767);
					recog.timestamp()?;

					/*InvokeRule kwAnd*/
					recog.base.set_state(1768);
					recog.kwAnd()?;

					/*InvokeRule ttl*/
					recog.base.set_state(1769);
					recog.ttl()?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- timestamp ----------------
pub type TimestampContextAll<'input> = TimestampContext<'input>;


pub type TimestampContext<'input> = BaseParserRuleContext<'input,TimestampContextExt<'input>>;

#[derive(Clone)]
pub struct TimestampContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for TimestampContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for TimestampContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_timestamp(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_timestamp(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for TimestampContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_timestamp(self);
	}
}

impl<'input> CustomRuleContext<'input> for TimestampContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_timestamp }
	//fn type_rule_index() -> usize where Self: Sized { RULE_timestamp }
}
antlr_rust::type_id!{TimestampContextExt<'a>}

impl<'input> TimestampContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TimestampContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TimestampContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TimestampContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<TimestampContextExt<'input>>{

fn kwTimestamp(&self) -> Option<Rc<KwTimestampContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn decimalLiteral(&self) -> Option<Rc<DecimalLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TimestampContextAttrs<'input> for TimestampContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn timestamp(&mut self,)
	-> Result<Rc<TimestampContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TimestampContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 240, RULE_timestamp);
        let mut _localctx: Rc<TimestampContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwTimestamp*/
			recog.base.set_state(1773);
			recog.kwTimestamp()?;

			/*InvokeRule decimalLiteral*/
			recog.base.set_state(1774);
			recog.decimalLiteral()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ttl ----------------
pub type TtlContextAll<'input> = TtlContext<'input>;


pub type TtlContext<'input> = BaseParserRuleContext<'input,TtlContextExt<'input>>;

#[derive(Clone)]
pub struct TtlContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for TtlContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for TtlContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_ttl(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_ttl(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for TtlContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_ttl(self);
	}
}

impl<'input> CustomRuleContext<'input> for TtlContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ttl }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ttl }
}
antlr_rust::type_id!{TtlContextExt<'a>}

impl<'input> TtlContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TtlContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TtlContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TtlContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<TtlContextExt<'input>>{

fn kwTtl(&self) -> Option<Rc<KwTtlContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn decimalLiteral(&self) -> Option<Rc<DecimalLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TtlContextAttrs<'input> for TtlContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ttl(&mut self,)
	-> Result<Rc<TtlContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TtlContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 242, RULE_ttl);
        let mut _localctx: Rc<TtlContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwTtl*/
			recog.base.set_state(1776);
			recog.kwTtl()?;

			/*InvokeRule decimalLiteral*/
			recog.base.set_state(1777);
			recog.decimalLiteral()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- usingTimestampSpec ----------------
pub type UsingTimestampSpecContextAll<'input> = UsingTimestampSpecContext<'input>;


pub type UsingTimestampSpecContext<'input> = BaseParserRuleContext<'input,UsingTimestampSpecContextExt<'input>>;

#[derive(Clone)]
pub struct UsingTimestampSpecContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for UsingTimestampSpecContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for UsingTimestampSpecContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_usingTimestampSpec(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_usingTimestampSpec(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for UsingTimestampSpecContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_usingTimestampSpec(self);
	}
}

impl<'input> CustomRuleContext<'input> for UsingTimestampSpecContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_usingTimestampSpec }
	//fn type_rule_index() -> usize where Self: Sized { RULE_usingTimestampSpec }
}
antlr_rust::type_id!{UsingTimestampSpecContextExt<'a>}

impl<'input> UsingTimestampSpecContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UsingTimestampSpecContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UsingTimestampSpecContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UsingTimestampSpecContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<UsingTimestampSpecContextExt<'input>>{

fn kwUsing(&self) -> Option<Rc<KwUsingContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn timestamp(&self) -> Option<Rc<TimestampContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UsingTimestampSpecContextAttrs<'input> for UsingTimestampSpecContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn usingTimestampSpec(&mut self,)
	-> Result<Rc<UsingTimestampSpecContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UsingTimestampSpecContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 244, RULE_usingTimestampSpec);
        let mut _localctx: Rc<UsingTimestampSpecContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwUsing*/
			recog.base.set_state(1779);
			recog.kwUsing()?;

			/*InvokeRule timestamp*/
			recog.base.set_state(1780);
			recog.timestamp()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ifNotExist ----------------
pub type IfNotExistContextAll<'input> = IfNotExistContext<'input>;


pub type IfNotExistContext<'input> = BaseParserRuleContext<'input,IfNotExistContextExt<'input>>;

#[derive(Clone)]
pub struct IfNotExistContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for IfNotExistContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for IfNotExistContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_ifNotExist(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_ifNotExist(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for IfNotExistContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_ifNotExist(self);
	}
}

impl<'input> CustomRuleContext<'input> for IfNotExistContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ifNotExist }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ifNotExist }
}
antlr_rust::type_id!{IfNotExistContextExt<'a>}

impl<'input> IfNotExistContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IfNotExistContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IfNotExistContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IfNotExistContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<IfNotExistContextExt<'input>>{

fn kwIf(&self) -> Option<Rc<KwIfContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwNot(&self) -> Option<Rc<KwNotContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwExists(&self) -> Option<Rc<KwExistsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IfNotExistContextAttrs<'input> for IfNotExistContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ifNotExist(&mut self,)
	-> Result<Rc<IfNotExistContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IfNotExistContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 246, RULE_ifNotExist);
        let mut _localctx: Rc<IfNotExistContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwIf*/
			recog.base.set_state(1782);
			recog.kwIf()?;

			/*InvokeRule kwNot*/
			recog.base.set_state(1783);
			recog.kwNot()?;

			/*InvokeRule kwExists*/
			recog.base.set_state(1784);
			recog.kwExists()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ifExist ----------------
pub type IfExistContextAll<'input> = IfExistContext<'input>;


pub type IfExistContext<'input> = BaseParserRuleContext<'input,IfExistContextExt<'input>>;

#[derive(Clone)]
pub struct IfExistContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for IfExistContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for IfExistContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_ifExist(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_ifExist(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for IfExistContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_ifExist(self);
	}
}

impl<'input> CustomRuleContext<'input> for IfExistContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ifExist }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ifExist }
}
antlr_rust::type_id!{IfExistContextExt<'a>}

impl<'input> IfExistContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IfExistContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IfExistContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IfExistContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<IfExistContextExt<'input>>{

fn kwIf(&self) -> Option<Rc<KwIfContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwExists(&self) -> Option<Rc<KwExistsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IfExistContextAttrs<'input> for IfExistContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ifExist(&mut self,)
	-> Result<Rc<IfExistContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IfExistContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 248, RULE_ifExist);
        let mut _localctx: Rc<IfExistContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwIf*/
			recog.base.set_state(1786);
			recog.kwIf()?;

			/*InvokeRule kwExists*/
			recog.base.set_state(1787);
			recog.kwExists()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- insertValuesSpec ----------------
pub type InsertValuesSpecContextAll<'input> = InsertValuesSpecContext<'input>;


pub type InsertValuesSpecContext<'input> = BaseParserRuleContext<'input,InsertValuesSpecContextExt<'input>>;

#[derive(Clone)]
pub struct InsertValuesSpecContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for InsertValuesSpecContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for InsertValuesSpecContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_insertValuesSpec(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_insertValuesSpec(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for InsertValuesSpecContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_insertValuesSpec(self);
	}
}

impl<'input> CustomRuleContext<'input> for InsertValuesSpecContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_insertValuesSpec }
	//fn type_rule_index() -> usize where Self: Sized { RULE_insertValuesSpec }
}
antlr_rust::type_id!{InsertValuesSpecContextExt<'a>}

impl<'input> InsertValuesSpecContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InsertValuesSpecContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InsertValuesSpecContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InsertValuesSpecContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<InsertValuesSpecContextExt<'input>>{

fn kwValues(&self) -> Option<Rc<KwValuesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LR_BRACKET
/// Returns `None` if there is no child corresponding to token LR_BRACKET
fn LR_BRACKET(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(LR_BRACKET, 0)
}
fn expressionList(&self) -> Option<Rc<ExpressionListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RR_BRACKET
/// Returns `None` if there is no child corresponding to token RR_BRACKET
fn RR_BRACKET(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(RR_BRACKET, 0)
}
fn kwJson(&self) -> Option<Rc<KwJsonContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn constant(&self) -> Option<Rc<ConstantContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InsertValuesSpecContextAttrs<'input> for InsertValuesSpecContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn insertValuesSpec(&mut self,)
	-> Result<Rc<InsertValuesSpecContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InsertValuesSpecContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 250, RULE_insertValuesSpec);
        let mut _localctx: Rc<InsertValuesSpecContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1797);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 K_VALUES 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule kwValues*/
					recog.base.set_state(1789);
					recog.kwValues()?;

					recog.base.set_state(1790);
					recog.base.match_token(LR_BRACKET,&mut recog.err_handler)?;

					/*InvokeRule expressionList*/
					recog.base.set_state(1791);
					recog.expressionList()?;

					recog.base.set_state(1792);
					recog.base.match_token(RR_BRACKET,&mut recog.err_handler)?;

					}
				}

			 K_JSON 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule kwJson*/
					recog.base.set_state(1794);
					recog.kwJson()?;

					/*InvokeRule constant*/
					recog.base.set_state(1795);
					recog.constant()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- insertColumnSpec ----------------
pub type InsertColumnSpecContextAll<'input> = InsertColumnSpecContext<'input>;


pub type InsertColumnSpecContext<'input> = BaseParserRuleContext<'input,InsertColumnSpecContextExt<'input>>;

#[derive(Clone)]
pub struct InsertColumnSpecContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for InsertColumnSpecContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for InsertColumnSpecContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_insertColumnSpec(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_insertColumnSpec(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for InsertColumnSpecContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_insertColumnSpec(self);
	}
}

impl<'input> CustomRuleContext<'input> for InsertColumnSpecContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_insertColumnSpec }
	//fn type_rule_index() -> usize where Self: Sized { RULE_insertColumnSpec }
}
antlr_rust::type_id!{InsertColumnSpecContextExt<'a>}

impl<'input> InsertColumnSpecContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InsertColumnSpecContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InsertColumnSpecContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InsertColumnSpecContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<InsertColumnSpecContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LR_BRACKET
/// Returns `None` if there is no child corresponding to token LR_BRACKET
fn LR_BRACKET(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(LR_BRACKET, 0)
}
fn columnList(&self) -> Option<Rc<ColumnListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RR_BRACKET
/// Returns `None` if there is no child corresponding to token RR_BRACKET
fn RR_BRACKET(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(RR_BRACKET, 0)
}

}

impl<'input> InsertColumnSpecContextAttrs<'input> for InsertColumnSpecContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn insertColumnSpec(&mut self,)
	-> Result<Rc<InsertColumnSpecContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InsertColumnSpecContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 252, RULE_insertColumnSpec);
        let mut _localctx: Rc<InsertColumnSpecContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1799);
			recog.base.match_token(LR_BRACKET,&mut recog.err_handler)?;

			/*InvokeRule columnList*/
			recog.base.set_state(1800);
			recog.columnList()?;

			recog.base.set_state(1801);
			recog.base.match_token(RR_BRACKET,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- columnList ----------------
pub type ColumnListContextAll<'input> = ColumnListContext<'input>;


pub type ColumnListContext<'input> = BaseParserRuleContext<'input,ColumnListContextExt<'input>>;

#[derive(Clone)]
pub struct ColumnListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for ColumnListContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for ColumnListContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_columnList(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_columnList(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for ColumnListContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_columnList(self);
	}
}

impl<'input> CustomRuleContext<'input> for ColumnListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_columnList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_columnList }
}
antlr_rust::type_id!{ColumnListContextExt<'a>}

impl<'input> ColumnListContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ColumnListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ColumnListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ColumnListContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<ColumnListContextExt<'input>>{

fn column_all(&self) ->  Vec<Rc<ColumnContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn column(&self, i: usize) -> Option<Rc<ColumnContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn syntaxComma_all(&self) ->  Vec<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn syntaxComma(&self, i: usize) -> Option<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ColumnListContextAttrs<'input> for ColumnListContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn columnList(&mut self,)
	-> Result<Rc<ColumnListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ColumnListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 254, RULE_columnList);
        let mut _localctx: Rc<ColumnListContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule column*/
			recog.base.set_state(1803);
			recog.column()?;

			recog.base.set_state(1809);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				/*InvokeRule syntaxComma*/
				recog.base.set_state(1804);
				recog.syntaxComma()?;

				/*InvokeRule column*/
				recog.base.set_state(1805);
				recog.column()?;

				}
				}
				recog.base.set_state(1811);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- expressionList ----------------
pub type ExpressionListContextAll<'input> = ExpressionListContext<'input>;


pub type ExpressionListContext<'input> = BaseParserRuleContext<'input,ExpressionListContextExt<'input>>;

#[derive(Clone)]
pub struct ExpressionListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for ExpressionListContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for ExpressionListContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_expressionList(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_expressionList(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for ExpressionListContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_expressionList(self);
	}
}

impl<'input> CustomRuleContext<'input> for ExpressionListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_expressionList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_expressionList }
}
antlr_rust::type_id!{ExpressionListContextExt<'a>}

impl<'input> ExpressionListContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExpressionListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExpressionListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExpressionListContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<ExpressionListContextExt<'input>>{

fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn syntaxComma_all(&self) ->  Vec<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn syntaxComma(&self, i: usize) -> Option<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ExpressionListContextAttrs<'input> for ExpressionListContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn expressionList(&mut self,)
	-> Result<Rc<ExpressionListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExpressionListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 256, RULE_expressionList);
        let mut _localctx: Rc<ExpressionListContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule expression*/
			recog.base.set_state(1812);
			recog.expression()?;

			recog.base.set_state(1818);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				/*InvokeRule syntaxComma*/
				recog.base.set_state(1813);
				recog.syntaxComma()?;

				/*InvokeRule expression*/
				recog.base.set_state(1814);
				recog.expression()?;

				}
				}
				recog.base.set_state(1820);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- expression ----------------
pub type ExpressionContextAll<'input> = ExpressionContext<'input>;


pub type ExpressionContext<'input> = BaseParserRuleContext<'input,ExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for ExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for ExpressionContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_expression(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_expression(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for ExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_expression(self);
	}
}

impl<'input> CustomRuleContext<'input> for ExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_expression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}
antlr_rust::type_id!{ExpressionContextExt<'a>}

impl<'input> ExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExpressionContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<ExpressionContextExt<'input>>{

fn constant(&self) -> Option<Rc<ConstantContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn assignmentMap(&self) -> Option<Rc<AssignmentMapContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn assignmentSet(&self) -> Option<Rc<AssignmentSetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn assignmentList(&self) -> Option<Rc<AssignmentListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn assignmentTuple(&self) -> Option<Rc<AssignmentTupleContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ExpressionContextAttrs<'input> for ExpressionContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn expression(&mut self,)
	-> Result<Rc<ExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 258, RULE_expression);
        let mut _localctx: Rc<ExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1826);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(146,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule constant*/
					recog.base.set_state(1821);
					recog.constant()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule assignmentMap*/
					recog.base.set_state(1822);
					recog.assignmentMap()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule assignmentSet*/
					recog.base.set_state(1823);
					recog.assignmentSet()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule assignmentList*/
					recog.base.set_state(1824);
					recog.assignmentList()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule assignmentTuple*/
					recog.base.set_state(1825);
					recog.assignmentTuple()?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- select_ ----------------
pub type Select_ContextAll<'input> = Select_Context<'input>;


pub type Select_Context<'input> = BaseParserRuleContext<'input,Select_ContextExt<'input>>;

#[derive(Clone)]
pub struct Select_ContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for Select_Context<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for Select_Context<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_select_(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_select_(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for Select_Context<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_select_(self);
	}
}

impl<'input> CustomRuleContext<'input> for Select_ContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_select_ }
	//fn type_rule_index() -> usize where Self: Sized { RULE_select_ }
}
antlr_rust::type_id!{Select_ContextExt<'a>}

impl<'input> Select_ContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Select_ContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Select_ContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Select_ContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<Select_ContextExt<'input>>{

fn kwSelect(&self) -> Option<Rc<KwSelectContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn selectElements(&self) -> Option<Rc<SelectElementsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn fromSpec(&self) -> Option<Rc<FromSpecContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn distinctSpec(&self) -> Option<Rc<DistinctSpecContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwJson(&self) -> Option<Rc<KwJsonContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn whereSpec(&self) -> Option<Rc<WhereSpecContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn orderSpec(&self) -> Option<Rc<OrderSpecContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn limitSpec(&self) -> Option<Rc<LimitSpecContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn allowFilteringSpec(&self) -> Option<Rc<AllowFilteringSpecContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> Select_ContextAttrs<'input> for Select_Context<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn select_(&mut self,)
	-> Result<Rc<Select_ContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Select_ContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 260, RULE_select_);
        let mut _localctx: Rc<Select_ContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwSelect*/
			recog.base.set_state(1828);
			recog.kwSelect()?;

			recog.base.set_state(1830);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_DISTINCT {
				{
				/*InvokeRule distinctSpec*/
				recog.base.set_state(1829);
				recog.distinctSpec()?;

				}
			}

			recog.base.set_state(1833);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_JSON {
				{
				/*InvokeRule kwJson*/
				recog.base.set_state(1832);
				recog.kwJson()?;

				}
			}

			/*InvokeRule selectElements*/
			recog.base.set_state(1835);
			recog.selectElements()?;

			/*InvokeRule fromSpec*/
			recog.base.set_state(1836);
			recog.fromSpec()?;

			recog.base.set_state(1838);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_WHERE {
				{
				/*InvokeRule whereSpec*/
				recog.base.set_state(1837);
				recog.whereSpec()?;

				}
			}

			recog.base.set_state(1841);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_ORDER {
				{
				/*InvokeRule orderSpec*/
				recog.base.set_state(1840);
				recog.orderSpec()?;

				}
			}

			recog.base.set_state(1844);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_LIMIT {
				{
				/*InvokeRule limitSpec*/
				recog.base.set_state(1843);
				recog.limitSpec()?;

				}
			}

			recog.base.set_state(1847);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==K_ALLOW {
				{
				/*InvokeRule allowFilteringSpec*/
				recog.base.set_state(1846);
				recog.allowFilteringSpec()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- allowFilteringSpec ----------------
pub type AllowFilteringSpecContextAll<'input> = AllowFilteringSpecContext<'input>;


pub type AllowFilteringSpecContext<'input> = BaseParserRuleContext<'input,AllowFilteringSpecContextExt<'input>>;

#[derive(Clone)]
pub struct AllowFilteringSpecContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for AllowFilteringSpecContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for AllowFilteringSpecContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_allowFilteringSpec(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_allowFilteringSpec(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for AllowFilteringSpecContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_allowFilteringSpec(self);
	}
}

impl<'input> CustomRuleContext<'input> for AllowFilteringSpecContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_allowFilteringSpec }
	//fn type_rule_index() -> usize where Self: Sized { RULE_allowFilteringSpec }
}
antlr_rust::type_id!{AllowFilteringSpecContextExt<'a>}

impl<'input> AllowFilteringSpecContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AllowFilteringSpecContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AllowFilteringSpecContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AllowFilteringSpecContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<AllowFilteringSpecContextExt<'input>>{

fn kwAllow(&self) -> Option<Rc<KwAllowContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwFiltering(&self) -> Option<Rc<KwFilteringContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AllowFilteringSpecContextAttrs<'input> for AllowFilteringSpecContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn allowFilteringSpec(&mut self,)
	-> Result<Rc<AllowFilteringSpecContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AllowFilteringSpecContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 262, RULE_allowFilteringSpec);
        let mut _localctx: Rc<AllowFilteringSpecContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwAllow*/
			recog.base.set_state(1849);
			recog.kwAllow()?;

			/*InvokeRule kwFiltering*/
			recog.base.set_state(1850);
			recog.kwFiltering()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- limitSpec ----------------
pub type LimitSpecContextAll<'input> = LimitSpecContext<'input>;


pub type LimitSpecContext<'input> = BaseParserRuleContext<'input,LimitSpecContextExt<'input>>;

#[derive(Clone)]
pub struct LimitSpecContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for LimitSpecContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for LimitSpecContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_limitSpec(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_limitSpec(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for LimitSpecContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_limitSpec(self);
	}
}

impl<'input> CustomRuleContext<'input> for LimitSpecContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_limitSpec }
	//fn type_rule_index() -> usize where Self: Sized { RULE_limitSpec }
}
antlr_rust::type_id!{LimitSpecContextExt<'a>}

impl<'input> LimitSpecContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LimitSpecContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LimitSpecContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LimitSpecContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<LimitSpecContextExt<'input>>{

fn kwLimit(&self) -> Option<Rc<KwLimitContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn decimalLiteral(&self) -> Option<Rc<DecimalLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LimitSpecContextAttrs<'input> for LimitSpecContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn limitSpec(&mut self,)
	-> Result<Rc<LimitSpecContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LimitSpecContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 264, RULE_limitSpec);
        let mut _localctx: Rc<LimitSpecContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwLimit*/
			recog.base.set_state(1852);
			recog.kwLimit()?;

			/*InvokeRule decimalLiteral*/
			recog.base.set_state(1853);
			recog.decimalLiteral()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- fromSpec ----------------
pub type FromSpecContextAll<'input> = FromSpecContext<'input>;


pub type FromSpecContext<'input> = BaseParserRuleContext<'input,FromSpecContextExt<'input>>;

#[derive(Clone)]
pub struct FromSpecContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for FromSpecContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for FromSpecContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_fromSpec(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_fromSpec(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for FromSpecContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_fromSpec(self);
	}
}

impl<'input> CustomRuleContext<'input> for FromSpecContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_fromSpec }
	//fn type_rule_index() -> usize where Self: Sized { RULE_fromSpec }
}
antlr_rust::type_id!{FromSpecContextExt<'a>}

impl<'input> FromSpecContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FromSpecContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FromSpecContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FromSpecContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<FromSpecContextExt<'input>>{

fn kwFrom(&self) -> Option<Rc<KwFromContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn fromSpecElement(&self) -> Option<Rc<FromSpecElementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FromSpecContextAttrs<'input> for FromSpecContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn fromSpec(&mut self,)
	-> Result<Rc<FromSpecContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FromSpecContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 266, RULE_fromSpec);
        let mut _localctx: Rc<FromSpecContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwFrom*/
			recog.base.set_state(1855);
			recog.kwFrom()?;

			/*InvokeRule fromSpecElement*/
			recog.base.set_state(1856);
			recog.fromSpecElement()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- fromSpecElement ----------------
pub type FromSpecElementContextAll<'input> = FromSpecElementContext<'input>;


pub type FromSpecElementContext<'input> = BaseParserRuleContext<'input,FromSpecElementContextExt<'input>>;

#[derive(Clone)]
pub struct FromSpecElementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for FromSpecElementContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for FromSpecElementContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_fromSpecElement(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_fromSpecElement(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for FromSpecElementContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_fromSpecElement(self);
	}
}

impl<'input> CustomRuleContext<'input> for FromSpecElementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_fromSpecElement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_fromSpecElement }
}
antlr_rust::type_id!{FromSpecElementContextExt<'a>}

impl<'input> FromSpecElementContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FromSpecElementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FromSpecElementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FromSpecElementContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<FromSpecElementContextExt<'input>>{

/// Retrieves all `TerminalNode`s corresponding to token OBJECT_NAME in current rule
fn OBJECT_NAME_all(&self) -> Vec<Rc<TerminalNode<'input,CqlParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token OBJECT_NAME, starting from 0.
/// Returns `None` if number of children corresponding to token OBJECT_NAME is less or equal than `i`.
fn OBJECT_NAME(&self, i: usize) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OBJECT_NAME, i)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}

}

impl<'input> FromSpecElementContextAttrs<'input> for FromSpecElementContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn fromSpecElement(&mut self,)
	-> Result<Rc<FromSpecElementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FromSpecElementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 268, RULE_fromSpecElement);
        let mut _localctx: Rc<FromSpecElementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1862);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(153,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1858);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1859);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					recog.base.set_state(1860);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(1861);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- orderSpec ----------------
pub type OrderSpecContextAll<'input> = OrderSpecContext<'input>;


pub type OrderSpecContext<'input> = BaseParserRuleContext<'input,OrderSpecContextExt<'input>>;

#[derive(Clone)]
pub struct OrderSpecContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for OrderSpecContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for OrderSpecContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_orderSpec(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_orderSpec(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for OrderSpecContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_orderSpec(self);
	}
}

impl<'input> CustomRuleContext<'input> for OrderSpecContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_orderSpec }
	//fn type_rule_index() -> usize where Self: Sized { RULE_orderSpec }
}
antlr_rust::type_id!{OrderSpecContextExt<'a>}

impl<'input> OrderSpecContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<OrderSpecContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,OrderSpecContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait OrderSpecContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<OrderSpecContextExt<'input>>{

fn kwOrder(&self) -> Option<Rc<KwOrderContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwBy(&self) -> Option<Rc<KwByContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn orderSpecElement(&self) -> Option<Rc<OrderSpecElementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> OrderSpecContextAttrs<'input> for OrderSpecContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn orderSpec(&mut self,)
	-> Result<Rc<OrderSpecContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = OrderSpecContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 270, RULE_orderSpec);
        let mut _localctx: Rc<OrderSpecContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwOrder*/
			recog.base.set_state(1864);
			recog.kwOrder()?;

			/*InvokeRule kwBy*/
			recog.base.set_state(1865);
			recog.kwBy()?;

			/*InvokeRule orderSpecElement*/
			recog.base.set_state(1866);
			recog.orderSpecElement()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- orderSpecElement ----------------
pub type OrderSpecElementContextAll<'input> = OrderSpecElementContext<'input>;


pub type OrderSpecElementContext<'input> = BaseParserRuleContext<'input,OrderSpecElementContextExt<'input>>;

#[derive(Clone)]
pub struct OrderSpecElementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for OrderSpecElementContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for OrderSpecElementContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_orderSpecElement(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_orderSpecElement(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for OrderSpecElementContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_orderSpecElement(self);
	}
}

impl<'input> CustomRuleContext<'input> for OrderSpecElementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_orderSpecElement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_orderSpecElement }
}
antlr_rust::type_id!{OrderSpecElementContextExt<'a>}

impl<'input> OrderSpecElementContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<OrderSpecElementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,OrderSpecElementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait OrderSpecElementContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<OrderSpecElementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OBJECT_NAME
/// Returns `None` if there is no child corresponding to token OBJECT_NAME
fn OBJECT_NAME(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OBJECT_NAME, 0)
}
fn kwAsc(&self) -> Option<Rc<KwAscContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwDesc(&self) -> Option<Rc<KwDescContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> OrderSpecElementContextAttrs<'input> for OrderSpecElementContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn orderSpecElement(&mut self,)
	-> Result<Rc<OrderSpecElementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = OrderSpecElementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 272, RULE_orderSpecElement);
        let mut _localctx: Rc<OrderSpecElementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1868);
			recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

			recog.base.set_state(1871);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 K_ASC 
				=> {
			    	{
			    	/*InvokeRule kwAsc*/
			    	recog.base.set_state(1869);
			    	recog.kwAsc()?;

			    	}
			    }

			 K_DESC 
				=> {
			    	{
			    	/*InvokeRule kwDesc*/
			    	recog.base.set_state(1870);
			    	recog.kwDesc()?;

			    	}
			    }

			 EOF | SEMI | MINUSMINUS | K_ALLOW | K_LIMIT 
				=> {
			    }

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- whereSpec ----------------
pub type WhereSpecContextAll<'input> = WhereSpecContext<'input>;


pub type WhereSpecContext<'input> = BaseParserRuleContext<'input,WhereSpecContextExt<'input>>;

#[derive(Clone)]
pub struct WhereSpecContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for WhereSpecContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for WhereSpecContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_whereSpec(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_whereSpec(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for WhereSpecContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_whereSpec(self);
	}
}

impl<'input> CustomRuleContext<'input> for WhereSpecContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_whereSpec }
	//fn type_rule_index() -> usize where Self: Sized { RULE_whereSpec }
}
antlr_rust::type_id!{WhereSpecContextExt<'a>}

impl<'input> WhereSpecContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<WhereSpecContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,WhereSpecContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait WhereSpecContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<WhereSpecContextExt<'input>>{

fn kwWhere(&self) -> Option<Rc<KwWhereContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn relationElements(&self) -> Option<Rc<RelationElementsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> WhereSpecContextAttrs<'input> for WhereSpecContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn whereSpec(&mut self,)
	-> Result<Rc<WhereSpecContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = WhereSpecContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 274, RULE_whereSpec);
        let mut _localctx: Rc<WhereSpecContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwWhere*/
			recog.base.set_state(1873);
			recog.kwWhere()?;

			/*InvokeRule relationElements*/
			recog.base.set_state(1874);
			recog.relationElements()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- distinctSpec ----------------
pub type DistinctSpecContextAll<'input> = DistinctSpecContext<'input>;


pub type DistinctSpecContext<'input> = BaseParserRuleContext<'input,DistinctSpecContextExt<'input>>;

#[derive(Clone)]
pub struct DistinctSpecContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for DistinctSpecContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for DistinctSpecContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_distinctSpec(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_distinctSpec(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for DistinctSpecContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_distinctSpec(self);
	}
}

impl<'input> CustomRuleContext<'input> for DistinctSpecContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_distinctSpec }
	//fn type_rule_index() -> usize where Self: Sized { RULE_distinctSpec }
}
antlr_rust::type_id!{DistinctSpecContextExt<'a>}

impl<'input> DistinctSpecContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DistinctSpecContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DistinctSpecContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DistinctSpecContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<DistinctSpecContextExt<'input>>{

fn kwDistinct(&self) -> Option<Rc<KwDistinctContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DistinctSpecContextAttrs<'input> for DistinctSpecContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn distinctSpec(&mut self,)
	-> Result<Rc<DistinctSpecContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DistinctSpecContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 276, RULE_distinctSpec);
        let mut _localctx: Rc<DistinctSpecContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule kwDistinct*/
			recog.base.set_state(1876);
			recog.kwDistinct()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- selectElements ----------------
pub type SelectElementsContextAll<'input> = SelectElementsContext<'input>;


pub type SelectElementsContext<'input> = BaseParserRuleContext<'input,SelectElementsContextExt<'input>>;

#[derive(Clone)]
pub struct SelectElementsContextExt<'input>{
	pub star: Option<TokenType<'input>>,
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for SelectElementsContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for SelectElementsContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_selectElements(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_selectElements(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for SelectElementsContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_selectElements(self);
	}
}

impl<'input> CustomRuleContext<'input> for SelectElementsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_selectElements }
	//fn type_rule_index() -> usize where Self: Sized { RULE_selectElements }
}
antlr_rust::type_id!{SelectElementsContextExt<'a>}

impl<'input> SelectElementsContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SelectElementsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SelectElementsContextExt{
				star: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait SelectElementsContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<SelectElementsContextExt<'input>>{

fn selectElement_all(&self) ->  Vec<Rc<SelectElementContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn selectElement(&self, i: usize) -> Option<Rc<SelectElementContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token STAR
/// Returns `None` if there is no child corresponding to token STAR
fn STAR(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(STAR, 0)
}
fn syntaxComma_all(&self) ->  Vec<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn syntaxComma(&self, i: usize) -> Option<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> SelectElementsContextAttrs<'input> for SelectElementsContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn selectElements(&mut self,)
	-> Result<Rc<SelectElementsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SelectElementsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 278, RULE_selectElements);
        let mut _localctx: Rc<SelectElementsContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1880);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 STAR 
				=> {
					{
					recog.base.set_state(1878);
					let tmp = recog.base.match_token(STAR,&mut recog.err_handler)?;
					 cast_mut::<_,SelectElementsContext >(&mut _localctx).star = Some(tmp.clone());
					  

					}
				}

			 OBJECT_NAME 
				=> {
					{
					/*InvokeRule selectElement*/
					recog.base.set_state(1879);
					recog.selectElement()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			recog.base.set_state(1887);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				/*InvokeRule syntaxComma*/
				recog.base.set_state(1882);
				recog.syntaxComma()?;

				/*InvokeRule selectElement*/
				recog.base.set_state(1883);
				recog.selectElement()?;

				}
				}
				recog.base.set_state(1889);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- selectElement ----------------
pub type SelectElementContextAll<'input> = SelectElementContext<'input>;


pub type SelectElementContext<'input> = BaseParserRuleContext<'input,SelectElementContextExt<'input>>;

#[derive(Clone)]
pub struct SelectElementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for SelectElementContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for SelectElementContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_selectElement(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_selectElement(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for SelectElementContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_selectElement(self);
	}
}

impl<'input> CustomRuleContext<'input> for SelectElementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_selectElement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_selectElement }
}
antlr_rust::type_id!{SelectElementContextExt<'a>}

impl<'input> SelectElementContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SelectElementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SelectElementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SelectElementContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<SelectElementContextExt<'input>>{

/// Retrieves all `TerminalNode`s corresponding to token OBJECT_NAME in current rule
fn OBJECT_NAME_all(&self) -> Vec<Rc<TerminalNode<'input,CqlParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token OBJECT_NAME, starting from 0.
/// Returns `None` if number of children corresponding to token OBJECT_NAME is less or equal than `i`.
fn OBJECT_NAME(&self, i: usize) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OBJECT_NAME, i)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
/// Retrieves first TerminalNode corresponding to token STAR
/// Returns `None` if there is no child corresponding to token STAR
fn STAR(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(STAR, 0)
}
fn kwAs(&self) -> Option<Rc<KwAsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn functionCall(&self) -> Option<Rc<FunctionCallContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SelectElementContextAttrs<'input> for SelectElementContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn selectElement(&mut self,)
	-> Result<Rc<SelectElementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SelectElementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 280, RULE_selectElement);
        let mut _localctx: Rc<SelectElementContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1905);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(159,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1890);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					recog.base.set_state(1891);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(1892);
					recog.base.match_token(STAR,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1893);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					recog.base.set_state(1897);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==K_AS {
						{
						/*InvokeRule kwAs*/
						recog.base.set_state(1894);
						recog.kwAs()?;

						recog.base.set_state(1895);
						recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

						}
					}

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule functionCall*/
					recog.base.set_state(1899);
					recog.functionCall()?;

					recog.base.set_state(1903);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==K_AS {
						{
						/*InvokeRule kwAs*/
						recog.base.set_state(1900);
						recog.kwAs()?;

						recog.base.set_state(1901);
						recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

						}
					}

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- relationElements ----------------
pub type RelationElementsContextAll<'input> = RelationElementsContext<'input>;


pub type RelationElementsContext<'input> = BaseParserRuleContext<'input,RelationElementsContextExt<'input>>;

#[derive(Clone)]
pub struct RelationElementsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for RelationElementsContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for RelationElementsContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_relationElements(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_relationElements(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for RelationElementsContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_relationElements(self);
	}
}

impl<'input> CustomRuleContext<'input> for RelationElementsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_relationElements }
	//fn type_rule_index() -> usize where Self: Sized { RULE_relationElements }
}
antlr_rust::type_id!{RelationElementsContextExt<'a>}

impl<'input> RelationElementsContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RelationElementsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RelationElementsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RelationElementsContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<RelationElementsContextExt<'input>>{

fn relationElement_all(&self) ->  Vec<Rc<RelationElementContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn relationElement(&self, i: usize) -> Option<Rc<RelationElementContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn kwAnd_all(&self) ->  Vec<Rc<KwAndContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn kwAnd(&self, i: usize) -> Option<Rc<KwAndContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> RelationElementsContextAttrs<'input> for RelationElementsContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn relationElements(&mut self,)
	-> Result<Rc<RelationElementsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RelationElementsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 282, RULE_relationElements);
        let mut _localctx: Rc<RelationElementsContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule relationElement*/
			recog.base.set_state(1907);
			recog.relationElement()?;

			}
			recog.base.set_state(1913);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==K_AND {
				{
				{
				/*InvokeRule kwAnd*/
				recog.base.set_state(1908);
				recog.kwAnd()?;

				/*InvokeRule relationElement*/
				recog.base.set_state(1909);
				recog.relationElement()?;

				}
				}
				recog.base.set_state(1915);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- relationElement ----------------
pub type RelationElementContextAll<'input> = RelationElementContext<'input>;


pub type RelationElementContext<'input> = BaseParserRuleContext<'input,RelationElementContextExt<'input>>;

#[derive(Clone)]
pub struct RelationElementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for RelationElementContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for RelationElementContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_relationElement(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_relationElement(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for RelationElementContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_relationElement(self);
	}
}

impl<'input> CustomRuleContext<'input> for RelationElementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_relationElement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_relationElement }
}
antlr_rust::type_id!{RelationElementContextExt<'a>}

impl<'input> RelationElementContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RelationElementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RelationElementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RelationElementContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<RelationElementContextExt<'input>>{

/// Retrieves all `TerminalNode`s corresponding to token OBJECT_NAME in current rule
fn OBJECT_NAME_all(&self) -> Vec<Rc<TerminalNode<'input,CqlParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token OBJECT_NAME, starting from 0.
/// Returns `None` if number of children corresponding to token OBJECT_NAME is less or equal than `i`.
fn OBJECT_NAME(&self, i: usize) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OBJECT_NAME, i)
}
fn constant(&self) -> Option<Rc<ConstantContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token OPERATOR_EQ
/// Returns `None` if there is no child corresponding to token OPERATOR_EQ
fn OPERATOR_EQ(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OPERATOR_EQ, 0)
}
/// Retrieves first TerminalNode corresponding to token OPERATOR_LT
/// Returns `None` if there is no child corresponding to token OPERATOR_LT
fn OPERATOR_LT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OPERATOR_LT, 0)
}
/// Retrieves first TerminalNode corresponding to token OPERATOR_GT
/// Returns `None` if there is no child corresponding to token OPERATOR_GT
fn OPERATOR_GT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OPERATOR_GT, 0)
}
/// Retrieves first TerminalNode corresponding to token OPERATOR_LTE
/// Returns `None` if there is no child corresponding to token OPERATOR_LTE
fn OPERATOR_LTE(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OPERATOR_LTE, 0)
}
/// Retrieves first TerminalNode corresponding to token OPERATOR_GTE
/// Returns `None` if there is no child corresponding to token OPERATOR_GTE
fn OPERATOR_GTE(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OPERATOR_GTE, 0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
fn functionCall_all(&self) ->  Vec<Rc<FunctionCallContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn functionCall(&self, i: usize) -> Option<Rc<FunctionCallContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn kwIn(&self) -> Option<Rc<KwInContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token LR_BRACKET in current rule
fn LR_BRACKET_all(&self) -> Vec<Rc<TerminalNode<'input,CqlParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token LR_BRACKET, starting from 0.
/// Returns `None` if number of children corresponding to token LR_BRACKET is less or equal than `i`.
fn LR_BRACKET(&self, i: usize) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(LR_BRACKET, i)
}
/// Retrieves all `TerminalNode`s corresponding to token RR_BRACKET in current rule
fn RR_BRACKET_all(&self) -> Vec<Rc<TerminalNode<'input,CqlParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token RR_BRACKET, starting from 0.
/// Returns `None` if number of children corresponding to token RR_BRACKET is less or equal than `i`.
fn RR_BRACKET(&self, i: usize) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(RR_BRACKET, i)
}
fn functionArgs(&self) -> Option<Rc<FunctionArgsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn assignmentTuple_all(&self) ->  Vec<Rc<AssignmentTupleContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn assignmentTuple(&self, i: usize) -> Option<Rc<AssignmentTupleContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn syntaxComma_all(&self) ->  Vec<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn syntaxComma(&self, i: usize) -> Option<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn relalationContainsKey(&self) -> Option<Rc<RelalationContainsKeyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn relalationContains(&self) -> Option<Rc<RelalationContainsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RelationElementContextAttrs<'input> for RelationElementContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn relationElement(&mut self,)
	-> Result<Rc<RelationElementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RelationElementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 284, RULE_relationElement);
        let mut _localctx: Rc<RelationElementContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1987);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(166,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1916);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					recog.base.set_state(1917);
					_la = recog.base.input.la(1);
					if { !(((((_la - 171)) & !0x3f) == 0 && ((1usize << (_la - 171)) & ((1usize << (OPERATOR_EQ - 171)) | (1usize << (OPERATOR_LT - 171)) | (1usize << (OPERATOR_GT - 171)) | (1usize << (OPERATOR_LTE - 171)) | (1usize << (OPERATOR_GTE - 171)))) != 0)) } {
						recog.err_handler.recover_inline(&mut recog.base)?;

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					/*InvokeRule constant*/
					recog.base.set_state(1918);
					recog.constant()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1919);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					recog.base.set_state(1920);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(1921);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					recog.base.set_state(1922);
					_la = recog.base.input.la(1);
					if { !(((((_la - 171)) & !0x3f) == 0 && ((1usize << (_la - 171)) & ((1usize << (OPERATOR_EQ - 171)) | (1usize << (OPERATOR_LT - 171)) | (1usize << (OPERATOR_GT - 171)) | (1usize << (OPERATOR_LTE - 171)) | (1usize << (OPERATOR_GTE - 171)))) != 0)) } {
						recog.err_handler.recover_inline(&mut recog.base)?;

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					/*InvokeRule constant*/
					recog.base.set_state(1923);
					recog.constant()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule functionCall*/
					recog.base.set_state(1924);
					recog.functionCall()?;

					recog.base.set_state(1925);
					_la = recog.base.input.la(1);
					if { !(((((_la - 171)) & !0x3f) == 0 && ((1usize << (_la - 171)) & ((1usize << (OPERATOR_EQ - 171)) | (1usize << (OPERATOR_LT - 171)) | (1usize << (OPERATOR_GT - 171)) | (1usize << (OPERATOR_LTE - 171)) | (1usize << (OPERATOR_GTE - 171)))) != 0)) } {
						recog.err_handler.recover_inline(&mut recog.base)?;

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					/*InvokeRule constant*/
					recog.base.set_state(1926);
					recog.constant()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule functionCall*/
					recog.base.set_state(1928);
					recog.functionCall()?;

					recog.base.set_state(1929);
					_la = recog.base.input.la(1);
					if { !(((((_la - 171)) & !0x3f) == 0 && ((1usize << (_la - 171)) & ((1usize << (OPERATOR_EQ - 171)) | (1usize << (OPERATOR_LT - 171)) | (1usize << (OPERATOR_GT - 171)) | (1usize << (OPERATOR_LTE - 171)) | (1usize << (OPERATOR_GTE - 171)))) != 0)) } {
						recog.err_handler.recover_inline(&mut recog.base)?;

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					/*InvokeRule functionCall*/
					recog.base.set_state(1930);
					recog.functionCall()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(1932);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					/*InvokeRule kwIn*/
					recog.base.set_state(1933);
					recog.kwIn()?;

					recog.base.set_state(1934);
					recog.base.match_token(LR_BRACKET,&mut recog.err_handler)?;

					recog.base.set_state(1936);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==K_FALSE || _la==K_NULL || ((((_la - 125)) & !0x3f) == 0 && ((1usize << (_la - 125)) & ((1usize << (K_TRUE - 125)) | (1usize << (CODE_BLOCK - 125)) | (1usize << (STRING_LITERAL - 125)) | (1usize << (DECIMAL_LITERAL - 125)) | (1usize << (FLOAT_LITERAL - 125)) | (1usize << (HEXADECIMAL_LITERAL - 125)) | (1usize << (OBJECT_NAME - 125)) | (1usize << (UUID - 125)))) != 0) {
						{
						/*InvokeRule functionArgs*/
						recog.base.set_state(1935);
						recog.functionArgs()?;

						}
					}

					recog.base.set_state(1938);
					recog.base.match_token(RR_BRACKET,&mut recog.err_handler)?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					recog.base.set_state(1940);
					recog.base.match_token(LR_BRACKET,&mut recog.err_handler)?;

					recog.base.set_state(1941);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					recog.base.set_state(1947);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==COMMA {
						{
						{
						/*InvokeRule syntaxComma*/
						recog.base.set_state(1942);
						recog.syntaxComma()?;

						recog.base.set_state(1943);
						recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1949);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1950);
					recog.base.match_token(RR_BRACKET,&mut recog.err_handler)?;

					/*InvokeRule kwIn*/
					recog.base.set_state(1951);
					recog.kwIn()?;

					recog.base.set_state(1952);
					recog.base.match_token(LR_BRACKET,&mut recog.err_handler)?;

					/*InvokeRule assignmentTuple*/
					recog.base.set_state(1953);
					recog.assignmentTuple()?;

					recog.base.set_state(1959);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==COMMA {
						{
						{
						/*InvokeRule syntaxComma*/
						recog.base.set_state(1954);
						recog.syntaxComma()?;

						/*InvokeRule assignmentTuple*/
						recog.base.set_state(1955);
						recog.assignmentTuple()?;

						}
						}
						recog.base.set_state(1961);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1962);
					recog.base.match_token(RR_BRACKET,&mut recog.err_handler)?;

					}
				}
			,
				7 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					recog.base.set_state(1964);
					recog.base.match_token(LR_BRACKET,&mut recog.err_handler)?;

					recog.base.set_state(1965);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					recog.base.set_state(1971);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==COMMA {
						{
						{
						/*InvokeRule syntaxComma*/
						recog.base.set_state(1966);
						recog.syntaxComma()?;

						recog.base.set_state(1967);
						recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1973);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1974);
					recog.base.match_token(RR_BRACKET,&mut recog.err_handler)?;

					recog.base.set_state(1975);
					_la = recog.base.input.la(1);
					if { !(((((_la - 171)) & !0x3f) == 0 && ((1usize << (_la - 171)) & ((1usize << (OPERATOR_EQ - 171)) | (1usize << (OPERATOR_LT - 171)) | (1usize << (OPERATOR_GT - 171)) | (1usize << (OPERATOR_LTE - 171)) | (1usize << (OPERATOR_GTE - 171)))) != 0)) } {
						recog.err_handler.recover_inline(&mut recog.base)?;

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					{
					/*InvokeRule assignmentTuple*/
					recog.base.set_state(1976);
					recog.assignmentTuple()?;

					recog.base.set_state(1982);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==COMMA {
						{
						{
						/*InvokeRule syntaxComma*/
						recog.base.set_state(1977);
						recog.syntaxComma()?;

						/*InvokeRule assignmentTuple*/
						recog.base.set_state(1978);
						recog.assignmentTuple()?;

						}
						}
						recog.base.set_state(1984);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
					}
				}
			,
				8 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					/*InvokeRule relalationContainsKey*/
					recog.base.set_state(1985);
					recog.relalationContainsKey()?;

					}
				}
			,
				9 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 9);
					recog.base.enter_outer_alt(None, 9);
					{
					/*InvokeRule relalationContains*/
					recog.base.set_state(1986);
					recog.relalationContains()?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- relalationContains ----------------
pub type RelalationContainsContextAll<'input> = RelalationContainsContext<'input>;


pub type RelalationContainsContext<'input> = BaseParserRuleContext<'input,RelalationContainsContextExt<'input>>;

#[derive(Clone)]
pub struct RelalationContainsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for RelalationContainsContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for RelalationContainsContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_relalationContains(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_relalationContains(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for RelalationContainsContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_relalationContains(self);
	}
}

impl<'input> CustomRuleContext<'input> for RelalationContainsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_relalationContains }
	//fn type_rule_index() -> usize where Self: Sized { RULE_relalationContains }
}
antlr_rust::type_id!{RelalationContainsContextExt<'a>}

impl<'input> RelalationContainsContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RelalationContainsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RelalationContainsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RelalationContainsContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<RelalationContainsContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OBJECT_NAME
/// Returns `None` if there is no child corresponding to token OBJECT_NAME
fn OBJECT_NAME(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OBJECT_NAME, 0)
}
fn kwContains(&self) -> Option<Rc<KwContainsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn constant(&self) -> Option<Rc<ConstantContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RelalationContainsContextAttrs<'input> for RelalationContainsContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn relalationContains(&mut self,)
	-> Result<Rc<RelalationContainsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RelalationContainsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 286, RULE_relalationContains);
        let mut _localctx: Rc<RelalationContainsContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1989);
			recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

			/*InvokeRule kwContains*/
			recog.base.set_state(1990);
			recog.kwContains()?;

			/*InvokeRule constant*/
			recog.base.set_state(1991);
			recog.constant()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- relalationContainsKey ----------------
pub type RelalationContainsKeyContextAll<'input> = RelalationContainsKeyContext<'input>;


pub type RelalationContainsKeyContext<'input> = BaseParserRuleContext<'input,RelalationContainsKeyContextExt<'input>>;

#[derive(Clone)]
pub struct RelalationContainsKeyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for RelalationContainsKeyContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for RelalationContainsKeyContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_relalationContainsKey(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_relalationContainsKey(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for RelalationContainsKeyContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_relalationContainsKey(self);
	}
}

impl<'input> CustomRuleContext<'input> for RelalationContainsKeyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_relalationContainsKey }
	//fn type_rule_index() -> usize where Self: Sized { RULE_relalationContainsKey }
}
antlr_rust::type_id!{RelalationContainsKeyContextExt<'a>}

impl<'input> RelalationContainsKeyContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RelalationContainsKeyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RelalationContainsKeyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RelalationContainsKeyContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<RelalationContainsKeyContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OBJECT_NAME
/// Returns `None` if there is no child corresponding to token OBJECT_NAME
fn OBJECT_NAME(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OBJECT_NAME, 0)
}
fn constant(&self) -> Option<Rc<ConstantContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwContains(&self) -> Option<Rc<KwContainsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwKey(&self) -> Option<Rc<KwKeyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RelalationContainsKeyContextAttrs<'input> for RelalationContainsKeyContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn relalationContainsKey(&mut self,)
	-> Result<Rc<RelalationContainsKeyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RelalationContainsKeyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 288, RULE_relalationContainsKey);
        let mut _localctx: Rc<RelalationContainsKeyContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1993);
			recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

			{
			/*InvokeRule kwContains*/
			recog.base.set_state(1994);
			recog.kwContains()?;

			/*InvokeRule kwKey*/
			recog.base.set_state(1995);
			recog.kwKey()?;

			}
			/*InvokeRule constant*/
			recog.base.set_state(1997);
			recog.constant()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- functionCall ----------------
pub type FunctionCallContextAll<'input> = FunctionCallContext<'input>;


pub type FunctionCallContext<'input> = BaseParserRuleContext<'input,FunctionCallContextExt<'input>>;

#[derive(Clone)]
pub struct FunctionCallContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for FunctionCallContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for FunctionCallContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_functionCall(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_functionCall(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for FunctionCallContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_functionCall(self);
	}
}

impl<'input> CustomRuleContext<'input> for FunctionCallContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_functionCall }
	//fn type_rule_index() -> usize where Self: Sized { RULE_functionCall }
}
antlr_rust::type_id!{FunctionCallContextExt<'a>}

impl<'input> FunctionCallContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FunctionCallContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FunctionCallContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FunctionCallContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<FunctionCallContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OBJECT_NAME
/// Returns `None` if there is no child corresponding to token OBJECT_NAME
fn OBJECT_NAME(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OBJECT_NAME, 0)
}
/// Retrieves first TerminalNode corresponding to token LR_BRACKET
/// Returns `None` if there is no child corresponding to token LR_BRACKET
fn LR_BRACKET(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(LR_BRACKET, 0)
}
/// Retrieves first TerminalNode corresponding to token STAR
/// Returns `None` if there is no child corresponding to token STAR
fn STAR(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(STAR, 0)
}
/// Retrieves first TerminalNode corresponding to token RR_BRACKET
/// Returns `None` if there is no child corresponding to token RR_BRACKET
fn RR_BRACKET(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(RR_BRACKET, 0)
}
fn functionArgs(&self) -> Option<Rc<FunctionArgsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FunctionCallContextAttrs<'input> for FunctionCallContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn functionCall(&mut self,)
	-> Result<Rc<FunctionCallContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FunctionCallContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 290, RULE_functionCall);
        let mut _localctx: Rc<FunctionCallContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(2009);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(168,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1999);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					recog.base.set_state(2000);
					recog.base.match_token(LR_BRACKET,&mut recog.err_handler)?;

					recog.base.set_state(2001);
					recog.base.match_token(STAR,&mut recog.err_handler)?;

					recog.base.set_state(2002);
					recog.base.match_token(RR_BRACKET,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2003);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					recog.base.set_state(2004);
					recog.base.match_token(LR_BRACKET,&mut recog.err_handler)?;

					recog.base.set_state(2006);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==K_FALSE || _la==K_NULL || ((((_la - 125)) & !0x3f) == 0 && ((1usize << (_la - 125)) & ((1usize << (K_TRUE - 125)) | (1usize << (CODE_BLOCK - 125)) | (1usize << (STRING_LITERAL - 125)) | (1usize << (DECIMAL_LITERAL - 125)) | (1usize << (FLOAT_LITERAL - 125)) | (1usize << (HEXADECIMAL_LITERAL - 125)) | (1usize << (OBJECT_NAME - 125)) | (1usize << (UUID - 125)))) != 0) {
						{
						/*InvokeRule functionArgs*/
						recog.base.set_state(2005);
						recog.functionArgs()?;

						}
					}

					recog.base.set_state(2008);
					recog.base.match_token(RR_BRACKET,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- functionArgs ----------------
pub type FunctionArgsContextAll<'input> = FunctionArgsContext<'input>;


pub type FunctionArgsContext<'input> = BaseParserRuleContext<'input,FunctionArgsContextExt<'input>>;

#[derive(Clone)]
pub struct FunctionArgsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for FunctionArgsContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for FunctionArgsContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_functionArgs(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_functionArgs(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for FunctionArgsContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_functionArgs(self);
	}
}

impl<'input> CustomRuleContext<'input> for FunctionArgsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_functionArgs }
	//fn type_rule_index() -> usize where Self: Sized { RULE_functionArgs }
}
antlr_rust::type_id!{FunctionArgsContextExt<'a>}

impl<'input> FunctionArgsContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FunctionArgsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FunctionArgsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FunctionArgsContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<FunctionArgsContextExt<'input>>{

fn constant_all(&self) ->  Vec<Rc<ConstantContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn constant(&self, i: usize) -> Option<Rc<ConstantContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token OBJECT_NAME in current rule
fn OBJECT_NAME_all(&self) -> Vec<Rc<TerminalNode<'input,CqlParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token OBJECT_NAME, starting from 0.
/// Returns `None` if number of children corresponding to token OBJECT_NAME is less or equal than `i`.
fn OBJECT_NAME(&self, i: usize) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OBJECT_NAME, i)
}
fn functionCall_all(&self) ->  Vec<Rc<FunctionCallContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn functionCall(&self, i: usize) -> Option<Rc<FunctionCallContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn syntaxComma_all(&self) ->  Vec<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn syntaxComma(&self, i: usize) -> Option<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> FunctionArgsContextAttrs<'input> for FunctionArgsContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn functionArgs(&mut self,)
	-> Result<Rc<FunctionArgsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FunctionArgsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 292, RULE_functionArgs);
        let mut _localctx: Rc<FunctionArgsContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2014);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(169,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule constant*/
					recog.base.set_state(2011);
					recog.constant()?;

					}
				}
			,
				2 =>{
					{
					recog.base.set_state(2012);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					}
				}
			,
				3 =>{
					{
					/*InvokeRule functionCall*/
					recog.base.set_state(2013);
					recog.functionCall()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(2024);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				/*InvokeRule syntaxComma*/
				recog.base.set_state(2016);
				recog.syntaxComma()?;

				recog.base.set_state(2020);
				recog.err_handler.sync(&mut recog.base)?;
				match  recog.interpreter.adaptive_predict(170,&mut recog.base)? {
					1 =>{
						{
						/*InvokeRule constant*/
						recog.base.set_state(2017);
						recog.constant()?;

						}
					}
				,
					2 =>{
						{
						recog.base.set_state(2018);
						recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

						}
					}
				,
					3 =>{
						{
						/*InvokeRule functionCall*/
						recog.base.set_state(2019);
						recog.functionCall()?;

						}
					}

					_ => {}
				}
				}
				}
				recog.base.set_state(2026);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- constant ----------------
pub type ConstantContextAll<'input> = ConstantContext<'input>;


pub type ConstantContext<'input> = BaseParserRuleContext<'input,ConstantContextExt<'input>>;

#[derive(Clone)]
pub struct ConstantContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for ConstantContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for ConstantContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_constant(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_constant(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for ConstantContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_constant(self);
	}
}

impl<'input> CustomRuleContext<'input> for ConstantContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constant }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constant }
}
antlr_rust::type_id!{ConstantContextExt<'a>}

impl<'input> ConstantContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConstantContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConstantContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConstantContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<ConstantContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token UUID
/// Returns `None` if there is no child corresponding to token UUID
fn UUID(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(UUID, 0)
}
fn stringLiteral(&self) -> Option<Rc<StringLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn decimalLiteral(&self) -> Option<Rc<DecimalLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn floatLiteral(&self) -> Option<Rc<FloatLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn hexadecimalLiteral(&self) -> Option<Rc<HexadecimalLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn booleanLiteral(&self) -> Option<Rc<BooleanLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn codeBlock(&self) -> Option<Rc<CodeBlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwNull(&self) -> Option<Rc<KwNullContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ConstantContextAttrs<'input> for ConstantContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn constant(&mut self,)
	-> Result<Rc<ConstantContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConstantContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 294, RULE_constant);
        let mut _localctx: Rc<ConstantContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(2035);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(172,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(2027);
					recog.base.match_token(UUID,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule stringLiteral*/
					recog.base.set_state(2028);
					recog.stringLiteral()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule decimalLiteral*/
					recog.base.set_state(2029);
					recog.decimalLiteral()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule floatLiteral*/
					recog.base.set_state(2030);
					recog.floatLiteral()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule hexadecimalLiteral*/
					recog.base.set_state(2031);
					recog.hexadecimalLiteral()?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule booleanLiteral*/
					recog.base.set_state(2032);
					recog.booleanLiteral()?;

					}
				}
			,
				7 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					/*InvokeRule codeBlock*/
					recog.base.set_state(2033);
					recog.codeBlock()?;

					}
				}
			,
				8 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					/*InvokeRule kwNull*/
					recog.base.set_state(2034);
					recog.kwNull()?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- decimalLiteral ----------------
pub type DecimalLiteralContextAll<'input> = DecimalLiteralContext<'input>;


pub type DecimalLiteralContext<'input> = BaseParserRuleContext<'input,DecimalLiteralContextExt<'input>>;

#[derive(Clone)]
pub struct DecimalLiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for DecimalLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for DecimalLiteralContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_decimalLiteral(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_decimalLiteral(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for DecimalLiteralContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_decimalLiteral(self);
	}
}

impl<'input> CustomRuleContext<'input> for DecimalLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_decimalLiteral }
	//fn type_rule_index() -> usize where Self: Sized { RULE_decimalLiteral }
}
antlr_rust::type_id!{DecimalLiteralContextExt<'a>}

impl<'input> DecimalLiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DecimalLiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DecimalLiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DecimalLiteralContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<DecimalLiteralContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token DECIMAL_LITERAL
/// Returns `None` if there is no child corresponding to token DECIMAL_LITERAL
fn DECIMAL_LITERAL(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(DECIMAL_LITERAL, 0)
}

}

impl<'input> DecimalLiteralContextAttrs<'input> for DecimalLiteralContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn decimalLiteral(&mut self,)
	-> Result<Rc<DecimalLiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DecimalLiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 296, RULE_decimalLiteral);
        let mut _localctx: Rc<DecimalLiteralContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2037);
			recog.base.match_token(DECIMAL_LITERAL,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- floatLiteral ----------------
pub type FloatLiteralContextAll<'input> = FloatLiteralContext<'input>;


pub type FloatLiteralContext<'input> = BaseParserRuleContext<'input,FloatLiteralContextExt<'input>>;

#[derive(Clone)]
pub struct FloatLiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for FloatLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for FloatLiteralContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_floatLiteral(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_floatLiteral(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for FloatLiteralContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_floatLiteral(self);
	}
}

impl<'input> CustomRuleContext<'input> for FloatLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_floatLiteral }
	//fn type_rule_index() -> usize where Self: Sized { RULE_floatLiteral }
}
antlr_rust::type_id!{FloatLiteralContextExt<'a>}

impl<'input> FloatLiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FloatLiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FloatLiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FloatLiteralContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<FloatLiteralContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token DECIMAL_LITERAL
/// Returns `None` if there is no child corresponding to token DECIMAL_LITERAL
fn DECIMAL_LITERAL(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(DECIMAL_LITERAL, 0)
}
/// Retrieves first TerminalNode corresponding to token FLOAT_LITERAL
/// Returns `None` if there is no child corresponding to token FLOAT_LITERAL
fn FLOAT_LITERAL(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(FLOAT_LITERAL, 0)
}

}

impl<'input> FloatLiteralContextAttrs<'input> for FloatLiteralContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn floatLiteral(&mut self,)
	-> Result<Rc<FloatLiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FloatLiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 298, RULE_floatLiteral);
        let mut _localctx: Rc<FloatLiteralContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2039);
			_la = recog.base.input.la(1);
			if { !(_la==DECIMAL_LITERAL || _la==FLOAT_LITERAL) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- stringLiteral ----------------
pub type StringLiteralContextAll<'input> = StringLiteralContext<'input>;


pub type StringLiteralContext<'input> = BaseParserRuleContext<'input,StringLiteralContextExt<'input>>;

#[derive(Clone)]
pub struct StringLiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for StringLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for StringLiteralContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_stringLiteral(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_stringLiteral(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for StringLiteralContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_stringLiteral(self);
	}
}

impl<'input> CustomRuleContext<'input> for StringLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_stringLiteral }
	//fn type_rule_index() -> usize where Self: Sized { RULE_stringLiteral }
}
antlr_rust::type_id!{StringLiteralContextExt<'a>}

impl<'input> StringLiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StringLiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StringLiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StringLiteralContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<StringLiteralContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token STRING_LITERAL
/// Returns `None` if there is no child corresponding to token STRING_LITERAL
fn STRING_LITERAL(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(STRING_LITERAL, 0)
}

}

impl<'input> StringLiteralContextAttrs<'input> for StringLiteralContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn stringLiteral(&mut self,)
	-> Result<Rc<StringLiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StringLiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 300, RULE_stringLiteral);
        let mut _localctx: Rc<StringLiteralContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2041);
			recog.base.match_token(STRING_LITERAL,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- booleanLiteral ----------------
pub type BooleanLiteralContextAll<'input> = BooleanLiteralContext<'input>;


pub type BooleanLiteralContext<'input> = BaseParserRuleContext<'input,BooleanLiteralContextExt<'input>>;

#[derive(Clone)]
pub struct BooleanLiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for BooleanLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for BooleanLiteralContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_booleanLiteral(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_booleanLiteral(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for BooleanLiteralContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_booleanLiteral(self);
	}
}

impl<'input> CustomRuleContext<'input> for BooleanLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_booleanLiteral }
	//fn type_rule_index() -> usize where Self: Sized { RULE_booleanLiteral }
}
antlr_rust::type_id!{BooleanLiteralContextExt<'a>}

impl<'input> BooleanLiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BooleanLiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BooleanLiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BooleanLiteralContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<BooleanLiteralContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_TRUE
/// Returns `None` if there is no child corresponding to token K_TRUE
fn K_TRUE(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_TRUE, 0)
}
/// Retrieves first TerminalNode corresponding to token K_FALSE
/// Returns `None` if there is no child corresponding to token K_FALSE
fn K_FALSE(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_FALSE, 0)
}

}

impl<'input> BooleanLiteralContextAttrs<'input> for BooleanLiteralContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn booleanLiteral(&mut self,)
	-> Result<Rc<BooleanLiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BooleanLiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 302, RULE_booleanLiteral);
        let mut _localctx: Rc<BooleanLiteralContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2043);
			_la = recog.base.input.la(1);
			if { !(_la==K_FALSE || _la==K_TRUE) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- hexadecimalLiteral ----------------
pub type HexadecimalLiteralContextAll<'input> = HexadecimalLiteralContext<'input>;


pub type HexadecimalLiteralContext<'input> = BaseParserRuleContext<'input,HexadecimalLiteralContextExt<'input>>;

#[derive(Clone)]
pub struct HexadecimalLiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for HexadecimalLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for HexadecimalLiteralContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_hexadecimalLiteral(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_hexadecimalLiteral(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for HexadecimalLiteralContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_hexadecimalLiteral(self);
	}
}

impl<'input> CustomRuleContext<'input> for HexadecimalLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_hexadecimalLiteral }
	//fn type_rule_index() -> usize where Self: Sized { RULE_hexadecimalLiteral }
}
antlr_rust::type_id!{HexadecimalLiteralContextExt<'a>}

impl<'input> HexadecimalLiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<HexadecimalLiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,HexadecimalLiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait HexadecimalLiteralContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<HexadecimalLiteralContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token HEXADECIMAL_LITERAL
/// Returns `None` if there is no child corresponding to token HEXADECIMAL_LITERAL
fn HEXADECIMAL_LITERAL(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(HEXADECIMAL_LITERAL, 0)
}

}

impl<'input> HexadecimalLiteralContextAttrs<'input> for HexadecimalLiteralContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn hexadecimalLiteral(&mut self,)
	-> Result<Rc<HexadecimalLiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = HexadecimalLiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 304, RULE_hexadecimalLiteral);
        let mut _localctx: Rc<HexadecimalLiteralContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2045);
			recog.base.match_token(HEXADECIMAL_LITERAL,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- keyspace ----------------
pub type KeyspaceContextAll<'input> = KeyspaceContext<'input>;


pub type KeyspaceContext<'input> = BaseParserRuleContext<'input,KeyspaceContextExt<'input>>;

#[derive(Clone)]
pub struct KeyspaceContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KeyspaceContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KeyspaceContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_keyspace(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_keyspace(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KeyspaceContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_keyspace(self);
	}
}

impl<'input> CustomRuleContext<'input> for KeyspaceContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_keyspace }
	//fn type_rule_index() -> usize where Self: Sized { RULE_keyspace }
}
antlr_rust::type_id!{KeyspaceContextExt<'a>}

impl<'input> KeyspaceContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KeyspaceContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KeyspaceContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KeyspaceContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KeyspaceContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OBJECT_NAME
/// Returns `None` if there is no child corresponding to token OBJECT_NAME
fn OBJECT_NAME(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OBJECT_NAME, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token DQUOTE in current rule
fn DQUOTE_all(&self) -> Vec<Rc<TerminalNode<'input,CqlParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token DQUOTE, starting from 0.
/// Returns `None` if number of children corresponding to token DQUOTE is less or equal than `i`.
fn DQUOTE(&self, i: usize) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(DQUOTE, i)
}

}

impl<'input> KeyspaceContextAttrs<'input> for KeyspaceContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn keyspace(&mut self,)
	-> Result<Rc<KeyspaceContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KeyspaceContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 306, RULE_keyspace);
        let mut _localctx: Rc<KeyspaceContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(2051);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 OBJECT_NAME 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(2047);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					}
				}

			 DQUOTE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2048);
					recog.base.match_token(DQUOTE,&mut recog.err_handler)?;

					recog.base.set_state(2049);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					recog.base.set_state(2050);
					recog.base.match_token(DQUOTE,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- table ----------------
pub type TableContextAll<'input> = TableContext<'input>;


pub type TableContext<'input> = BaseParserRuleContext<'input,TableContextExt<'input>>;

#[derive(Clone)]
pub struct TableContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for TableContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for TableContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_table(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_table(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for TableContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_table(self);
	}
}

impl<'input> CustomRuleContext<'input> for TableContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_table }
	//fn type_rule_index() -> usize where Self: Sized { RULE_table }
}
antlr_rust::type_id!{TableContextExt<'a>}

impl<'input> TableContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TableContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TableContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TableContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<TableContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OBJECT_NAME
/// Returns `None` if there is no child corresponding to token OBJECT_NAME
fn OBJECT_NAME(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OBJECT_NAME, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token DQUOTE in current rule
fn DQUOTE_all(&self) -> Vec<Rc<TerminalNode<'input,CqlParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token DQUOTE, starting from 0.
/// Returns `None` if number of children corresponding to token DQUOTE is less or equal than `i`.
fn DQUOTE(&self, i: usize) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(DQUOTE, i)
}

}

impl<'input> TableContextAttrs<'input> for TableContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn table(&mut self,)
	-> Result<Rc<TableContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TableContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 308, RULE_table);
        let mut _localctx: Rc<TableContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(2057);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 OBJECT_NAME 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(2053);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					}
				}

			 DQUOTE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2054);
					recog.base.match_token(DQUOTE,&mut recog.err_handler)?;

					recog.base.set_state(2055);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					recog.base.set_state(2056);
					recog.base.match_token(DQUOTE,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- column ----------------
pub type ColumnContextAll<'input> = ColumnContext<'input>;


pub type ColumnContext<'input> = BaseParserRuleContext<'input,ColumnContextExt<'input>>;

#[derive(Clone)]
pub struct ColumnContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for ColumnContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for ColumnContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_column(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_column(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for ColumnContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_column(self);
	}
}

impl<'input> CustomRuleContext<'input> for ColumnContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_column }
	//fn type_rule_index() -> usize where Self: Sized { RULE_column }
}
antlr_rust::type_id!{ColumnContextExt<'a>}

impl<'input> ColumnContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ColumnContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ColumnContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ColumnContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<ColumnContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OBJECT_NAME
/// Returns `None` if there is no child corresponding to token OBJECT_NAME
fn OBJECT_NAME(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OBJECT_NAME, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token DQUOTE in current rule
fn DQUOTE_all(&self) -> Vec<Rc<TerminalNode<'input,CqlParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token DQUOTE, starting from 0.
/// Returns `None` if number of children corresponding to token DQUOTE is less or equal than `i`.
fn DQUOTE(&self, i: usize) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(DQUOTE, i)
}

}

impl<'input> ColumnContextAttrs<'input> for ColumnContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn column(&mut self,)
	-> Result<Rc<ColumnContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ColumnContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 310, RULE_column);
        let mut _localctx: Rc<ColumnContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(2063);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 OBJECT_NAME 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(2059);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					}
				}

			 DQUOTE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2060);
					recog.base.match_token(DQUOTE,&mut recog.err_handler)?;

					recog.base.set_state(2061);
					recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

					recog.base.set_state(2062);
					recog.base.match_token(DQUOTE,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- dataType ----------------
pub type DataTypeContextAll<'input> = DataTypeContext<'input>;


pub type DataTypeContext<'input> = BaseParserRuleContext<'input,DataTypeContextExt<'input>>;

#[derive(Clone)]
pub struct DataTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for DataTypeContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for DataTypeContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_dataType(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_dataType(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for DataTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_dataType(self);
	}
}

impl<'input> CustomRuleContext<'input> for DataTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_dataType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_dataType }
}
antlr_rust::type_id!{DataTypeContextExt<'a>}

impl<'input> DataTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DataTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DataTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DataTypeContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<DataTypeContextExt<'input>>{

fn dataTypeName(&self) -> Option<Rc<DataTypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn dataTypeDefinition(&self) -> Option<Rc<DataTypeDefinitionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DataTypeContextAttrs<'input> for DataTypeContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn dataType(&mut self,)
	-> Result<Rc<DataTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DataTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 312, RULE_dataType);
        let mut _localctx: Rc<DataTypeContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule dataTypeName*/
			recog.base.set_state(2065);
			recog.dataTypeName()?;

			recog.base.set_state(2067);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==OPERATOR_LT {
				{
				/*InvokeRule dataTypeDefinition*/
				recog.base.set_state(2066);
				recog.dataTypeDefinition()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- dataTypeName ----------------
pub type DataTypeNameContextAll<'input> = DataTypeNameContext<'input>;


pub type DataTypeNameContext<'input> = BaseParserRuleContext<'input,DataTypeNameContextExt<'input>>;

#[derive(Clone)]
pub struct DataTypeNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for DataTypeNameContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for DataTypeNameContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_dataTypeName(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_dataTypeName(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for DataTypeNameContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_dataTypeName(self);
	}
}

impl<'input> CustomRuleContext<'input> for DataTypeNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_dataTypeName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_dataTypeName }
}
antlr_rust::type_id!{DataTypeNameContextExt<'a>}

impl<'input> DataTypeNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DataTypeNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DataTypeNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DataTypeNameContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<DataTypeNameContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OBJECT_NAME
/// Returns `None` if there is no child corresponding to token OBJECT_NAME
fn OBJECT_NAME(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OBJECT_NAME, 0)
}
/// Retrieves first TerminalNode corresponding to token K_TIMESTAMP
/// Returns `None` if there is no child corresponding to token K_TIMESTAMP
fn K_TIMESTAMP(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_TIMESTAMP, 0)
}
/// Retrieves first TerminalNode corresponding to token K_SET
/// Returns `None` if there is no child corresponding to token K_SET
fn K_SET(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_SET, 0)
}
/// Retrieves first TerminalNode corresponding to token K_ASCII
/// Returns `None` if there is no child corresponding to token K_ASCII
fn K_ASCII(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_ASCII, 0)
}
/// Retrieves first TerminalNode corresponding to token K_BIGINT
/// Returns `None` if there is no child corresponding to token K_BIGINT
fn K_BIGINT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_BIGINT, 0)
}
/// Retrieves first TerminalNode corresponding to token K_BLOB
/// Returns `None` if there is no child corresponding to token K_BLOB
fn K_BLOB(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_BLOB, 0)
}
/// Retrieves first TerminalNode corresponding to token K_BOOLEAN
/// Returns `None` if there is no child corresponding to token K_BOOLEAN
fn K_BOOLEAN(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_BOOLEAN, 0)
}
/// Retrieves first TerminalNode corresponding to token K_COUNTER
/// Returns `None` if there is no child corresponding to token K_COUNTER
fn K_COUNTER(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_COUNTER, 0)
}
/// Retrieves first TerminalNode corresponding to token K_DATE
/// Returns `None` if there is no child corresponding to token K_DATE
fn K_DATE(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_DATE, 0)
}
/// Retrieves first TerminalNode corresponding to token K_DECIMAL
/// Returns `None` if there is no child corresponding to token K_DECIMAL
fn K_DECIMAL(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_DECIMAL, 0)
}
/// Retrieves first TerminalNode corresponding to token K_DOUBLE
/// Returns `None` if there is no child corresponding to token K_DOUBLE
fn K_DOUBLE(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_DOUBLE, 0)
}
/// Retrieves first TerminalNode corresponding to token K_FLOAT
/// Returns `None` if there is no child corresponding to token K_FLOAT
fn K_FLOAT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_FLOAT, 0)
}
/// Retrieves first TerminalNode corresponding to token K_FROZEN
/// Returns `None` if there is no child corresponding to token K_FROZEN
fn K_FROZEN(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_FROZEN, 0)
}
/// Retrieves first TerminalNode corresponding to token K_INET
/// Returns `None` if there is no child corresponding to token K_INET
fn K_INET(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_INET, 0)
}
/// Retrieves first TerminalNode corresponding to token K_INT
/// Returns `None` if there is no child corresponding to token K_INT
fn K_INT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_INT, 0)
}
/// Retrieves first TerminalNode corresponding to token K_LIST
/// Returns `None` if there is no child corresponding to token K_LIST
fn K_LIST(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_LIST, 0)
}
/// Retrieves first TerminalNode corresponding to token K_MAP
/// Returns `None` if there is no child corresponding to token K_MAP
fn K_MAP(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_MAP, 0)
}
/// Retrieves first TerminalNode corresponding to token K_SMALLINT
/// Returns `None` if there is no child corresponding to token K_SMALLINT
fn K_SMALLINT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_SMALLINT, 0)
}
/// Retrieves first TerminalNode corresponding to token K_TEXT
/// Returns `None` if there is no child corresponding to token K_TEXT
fn K_TEXT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_TEXT, 0)
}
/// Retrieves first TerminalNode corresponding to token K_TIME
/// Returns `None` if there is no child corresponding to token K_TIME
fn K_TIME(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_TIME, 0)
}
/// Retrieves first TerminalNode corresponding to token K_TIMEUUID
/// Returns `None` if there is no child corresponding to token K_TIMEUUID
fn K_TIMEUUID(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_TIMEUUID, 0)
}
/// Retrieves first TerminalNode corresponding to token K_TINYINT
/// Returns `None` if there is no child corresponding to token K_TINYINT
fn K_TINYINT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_TINYINT, 0)
}
/// Retrieves first TerminalNode corresponding to token K_TUPLE
/// Returns `None` if there is no child corresponding to token K_TUPLE
fn K_TUPLE(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_TUPLE, 0)
}
/// Retrieves first TerminalNode corresponding to token K_VARCHAR
/// Returns `None` if there is no child corresponding to token K_VARCHAR
fn K_VARCHAR(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_VARCHAR, 0)
}
/// Retrieves first TerminalNode corresponding to token K_VARINT
/// Returns `None` if there is no child corresponding to token K_VARINT
fn K_VARINT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_VARINT, 0)
}
/// Retrieves first TerminalNode corresponding to token K_UUID
/// Returns `None` if there is no child corresponding to token K_UUID
fn K_UUID(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_UUID, 0)
}

}

impl<'input> DataTypeNameContextAttrs<'input> for DataTypeNameContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn dataTypeName(&mut self,)
	-> Result<Rc<DataTypeNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DataTypeNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 314, RULE_dataTypeName);
        let mut _localctx: Rc<DataTypeNameContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2069);
			_la = recog.base.input.la(1);
			if { !(((((_la - 113)) & !0x3f) == 0 && ((1usize << (_la - 113)) & ((1usize << (K_SET - 113)) | (1usize << (K_TIMESTAMP - 113)) | (1usize << (K_UUID - 113)) | (1usize << (K_ASCII - 113)) | (1usize << (K_BIGINT - 113)) | (1usize << (K_BLOB - 113)) | (1usize << (K_BOOLEAN - 113)) | (1usize << (K_COUNTER - 113)) | (1usize << (K_DATE - 113)) | (1usize << (K_DECIMAL - 113)) | (1usize << (K_DOUBLE - 113)) | (1usize << (K_FLOAT - 113)) | (1usize << (K_FROZEN - 113)) | (1usize << (K_INET - 113)) | (1usize << (K_INT - 113)) | (1usize << (K_LIST - 113)) | (1usize << (K_MAP - 113)) | (1usize << (K_SMALLINT - 113)) | (1usize << (K_TEXT - 113)) | (1usize << (K_TIMEUUID - 113)) | (1usize << (K_TIME - 113)) | (1usize << (K_TINYINT - 113)) | (1usize << (K_TUPLE - 113)) | (1usize << (K_VARCHAR - 113)) | (1usize << (K_VARINT - 113)) | (1usize << (OBJECT_NAME - 113)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- dataTypeDefinition ----------------
pub type DataTypeDefinitionContextAll<'input> = DataTypeDefinitionContext<'input>;


pub type DataTypeDefinitionContext<'input> = BaseParserRuleContext<'input,DataTypeDefinitionContextExt<'input>>;

#[derive(Clone)]
pub struct DataTypeDefinitionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for DataTypeDefinitionContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for DataTypeDefinitionContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_dataTypeDefinition(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_dataTypeDefinition(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for DataTypeDefinitionContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_dataTypeDefinition(self);
	}
}

impl<'input> CustomRuleContext<'input> for DataTypeDefinitionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_dataTypeDefinition }
	//fn type_rule_index() -> usize where Self: Sized { RULE_dataTypeDefinition }
}
antlr_rust::type_id!{DataTypeDefinitionContextExt<'a>}

impl<'input> DataTypeDefinitionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DataTypeDefinitionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DataTypeDefinitionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DataTypeDefinitionContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<DataTypeDefinitionContextExt<'input>>{

fn syntaxBracketLa(&self) -> Option<Rc<SyntaxBracketLaContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn dataTypeName_all(&self) ->  Vec<Rc<DataTypeNameContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn dataTypeName(&self, i: usize) -> Option<Rc<DataTypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn syntaxBracketRa(&self) -> Option<Rc<SyntaxBracketRaContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn syntaxComma_all(&self) ->  Vec<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn syntaxComma(&self, i: usize) -> Option<Rc<SyntaxCommaContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> DataTypeDefinitionContextAttrs<'input> for DataTypeDefinitionContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn dataTypeDefinition(&mut self,)
	-> Result<Rc<DataTypeDefinitionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DataTypeDefinitionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 316, RULE_dataTypeDefinition);
        let mut _localctx: Rc<DataTypeDefinitionContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule syntaxBracketLa*/
			recog.base.set_state(2071);
			recog.syntaxBracketLa()?;

			/*InvokeRule dataTypeName*/
			recog.base.set_state(2072);
			recog.dataTypeName()?;

			recog.base.set_state(2078);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				/*InvokeRule syntaxComma*/
				recog.base.set_state(2073);
				recog.syntaxComma()?;

				/*InvokeRule dataTypeName*/
				recog.base.set_state(2074);
				recog.dataTypeName()?;

				}
				}
				recog.base.set_state(2080);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule syntaxBracketRa*/
			recog.base.set_state(2081);
			recog.syntaxBracketRa()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- orderDirection ----------------
pub type OrderDirectionContextAll<'input> = OrderDirectionContext<'input>;


pub type OrderDirectionContext<'input> = BaseParserRuleContext<'input,OrderDirectionContextExt<'input>>;

#[derive(Clone)]
pub struct OrderDirectionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for OrderDirectionContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for OrderDirectionContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_orderDirection(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_orderDirection(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for OrderDirectionContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_orderDirection(self);
	}
}

impl<'input> CustomRuleContext<'input> for OrderDirectionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_orderDirection }
	//fn type_rule_index() -> usize where Self: Sized { RULE_orderDirection }
}
antlr_rust::type_id!{OrderDirectionContextExt<'a>}

impl<'input> OrderDirectionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<OrderDirectionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,OrderDirectionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait OrderDirectionContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<OrderDirectionContextExt<'input>>{

fn kwAsc(&self) -> Option<Rc<KwAscContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn kwDesc(&self) -> Option<Rc<KwDescContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> OrderDirectionContextAttrs<'input> for OrderDirectionContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn orderDirection(&mut self,)
	-> Result<Rc<OrderDirectionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = OrderDirectionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 318, RULE_orderDirection);
        let mut _localctx: Rc<OrderDirectionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(2085);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 K_ASC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule kwAsc*/
					recog.base.set_state(2083);
					recog.kwAsc()?;

					}
				}

			 K_DESC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule kwDesc*/
					recog.base.set_state(2084);
					recog.kwDesc()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- role ----------------
pub type RoleContextAll<'input> = RoleContext<'input>;


pub type RoleContext<'input> = BaseParserRuleContext<'input,RoleContextExt<'input>>;

#[derive(Clone)]
pub struct RoleContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for RoleContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for RoleContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_role(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_role(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for RoleContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_role(self);
	}
}

impl<'input> CustomRuleContext<'input> for RoleContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_role }
	//fn type_rule_index() -> usize where Self: Sized { RULE_role }
}
antlr_rust::type_id!{RoleContextExt<'a>}

impl<'input> RoleContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RoleContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RoleContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RoleContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<RoleContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OBJECT_NAME
/// Returns `None` if there is no child corresponding to token OBJECT_NAME
fn OBJECT_NAME(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OBJECT_NAME, 0)
}

}

impl<'input> RoleContextAttrs<'input> for RoleContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn role(&mut self,)
	-> Result<Rc<RoleContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RoleContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 320, RULE_role);
        let mut _localctx: Rc<RoleContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2087);
			recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- trigger ----------------
pub type TriggerContextAll<'input> = TriggerContext<'input>;


pub type TriggerContext<'input> = BaseParserRuleContext<'input,TriggerContextExt<'input>>;

#[derive(Clone)]
pub struct TriggerContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for TriggerContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for TriggerContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_trigger(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_trigger(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for TriggerContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_trigger(self);
	}
}

impl<'input> CustomRuleContext<'input> for TriggerContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_trigger }
	//fn type_rule_index() -> usize where Self: Sized { RULE_trigger }
}
antlr_rust::type_id!{TriggerContextExt<'a>}

impl<'input> TriggerContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TriggerContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TriggerContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TriggerContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<TriggerContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OBJECT_NAME
/// Returns `None` if there is no child corresponding to token OBJECT_NAME
fn OBJECT_NAME(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OBJECT_NAME, 0)
}

}

impl<'input> TriggerContextAttrs<'input> for TriggerContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn trigger(&mut self,)
	-> Result<Rc<TriggerContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TriggerContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 322, RULE_trigger);
        let mut _localctx: Rc<TriggerContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2089);
			recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- triggerClass ----------------
pub type TriggerClassContextAll<'input> = TriggerClassContext<'input>;


pub type TriggerClassContext<'input> = BaseParserRuleContext<'input,TriggerClassContextExt<'input>>;

#[derive(Clone)]
pub struct TriggerClassContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for TriggerClassContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for TriggerClassContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_triggerClass(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_triggerClass(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for TriggerClassContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_triggerClass(self);
	}
}

impl<'input> CustomRuleContext<'input> for TriggerClassContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_triggerClass }
	//fn type_rule_index() -> usize where Self: Sized { RULE_triggerClass }
}
antlr_rust::type_id!{TriggerClassContextExt<'a>}

impl<'input> TriggerClassContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TriggerClassContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TriggerClassContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TriggerClassContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<TriggerClassContextExt<'input>>{

fn stringLiteral(&self) -> Option<Rc<StringLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TriggerClassContextAttrs<'input> for TriggerClassContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn triggerClass(&mut self,)
	-> Result<Rc<TriggerClassContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TriggerClassContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 324, RULE_triggerClass);
        let mut _localctx: Rc<TriggerClassContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule stringLiteral*/
			recog.base.set_state(2091);
			recog.stringLiteral()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- materializedView ----------------
pub type MaterializedViewContextAll<'input> = MaterializedViewContext<'input>;


pub type MaterializedViewContext<'input> = BaseParserRuleContext<'input,MaterializedViewContextExt<'input>>;

#[derive(Clone)]
pub struct MaterializedViewContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for MaterializedViewContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for MaterializedViewContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_materializedView(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_materializedView(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for MaterializedViewContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_materializedView(self);
	}
}

impl<'input> CustomRuleContext<'input> for MaterializedViewContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_materializedView }
	//fn type_rule_index() -> usize where Self: Sized { RULE_materializedView }
}
antlr_rust::type_id!{MaterializedViewContextExt<'a>}

impl<'input> MaterializedViewContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MaterializedViewContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MaterializedViewContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MaterializedViewContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<MaterializedViewContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OBJECT_NAME
/// Returns `None` if there is no child corresponding to token OBJECT_NAME
fn OBJECT_NAME(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OBJECT_NAME, 0)
}

}

impl<'input> MaterializedViewContextAttrs<'input> for MaterializedViewContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn materializedView(&mut self,)
	-> Result<Rc<MaterializedViewContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MaterializedViewContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 326, RULE_materializedView);
        let mut _localctx: Rc<MaterializedViewContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2093);
			recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- type_ ----------------
pub type Type_ContextAll<'input> = Type_Context<'input>;


pub type Type_Context<'input> = BaseParserRuleContext<'input,Type_ContextExt<'input>>;

#[derive(Clone)]
pub struct Type_ContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for Type_Context<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for Type_Context<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_type_(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_type_(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for Type_Context<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_type_(self);
	}
}

impl<'input> CustomRuleContext<'input> for Type_ContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_type_ }
	//fn type_rule_index() -> usize where Self: Sized { RULE_type_ }
}
antlr_rust::type_id!{Type_ContextExt<'a>}

impl<'input> Type_ContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Type_ContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Type_ContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Type_ContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<Type_ContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OBJECT_NAME
/// Returns `None` if there is no child corresponding to token OBJECT_NAME
fn OBJECT_NAME(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OBJECT_NAME, 0)
}

}

impl<'input> Type_ContextAttrs<'input> for Type_Context<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn type_(&mut self,)
	-> Result<Rc<Type_ContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Type_ContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 328, RULE_type_);
        let mut _localctx: Rc<Type_ContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2095);
			recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- aggregate ----------------
pub type AggregateContextAll<'input> = AggregateContext<'input>;


pub type AggregateContext<'input> = BaseParserRuleContext<'input,AggregateContextExt<'input>>;

#[derive(Clone)]
pub struct AggregateContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for AggregateContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for AggregateContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_aggregate(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_aggregate(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for AggregateContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_aggregate(self);
	}
}

impl<'input> CustomRuleContext<'input> for AggregateContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_aggregate }
	//fn type_rule_index() -> usize where Self: Sized { RULE_aggregate }
}
antlr_rust::type_id!{AggregateContextExt<'a>}

impl<'input> AggregateContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AggregateContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AggregateContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AggregateContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<AggregateContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OBJECT_NAME
/// Returns `None` if there is no child corresponding to token OBJECT_NAME
fn OBJECT_NAME(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OBJECT_NAME, 0)
}

}

impl<'input> AggregateContextAttrs<'input> for AggregateContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn aggregate(&mut self,)
	-> Result<Rc<AggregateContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AggregateContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 330, RULE_aggregate);
        let mut _localctx: Rc<AggregateContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2097);
			recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- function_ ----------------
pub type Function_ContextAll<'input> = Function_Context<'input>;


pub type Function_Context<'input> = BaseParserRuleContext<'input,Function_ContextExt<'input>>;

#[derive(Clone)]
pub struct Function_ContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for Function_Context<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for Function_Context<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_function_(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_function_(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for Function_Context<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_function_(self);
	}
}

impl<'input> CustomRuleContext<'input> for Function_ContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_function_ }
	//fn type_rule_index() -> usize where Self: Sized { RULE_function_ }
}
antlr_rust::type_id!{Function_ContextExt<'a>}

impl<'input> Function_ContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Function_ContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Function_ContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Function_ContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<Function_ContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OBJECT_NAME
/// Returns `None` if there is no child corresponding to token OBJECT_NAME
fn OBJECT_NAME(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OBJECT_NAME, 0)
}

}

impl<'input> Function_ContextAttrs<'input> for Function_Context<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn function_(&mut self,)
	-> Result<Rc<Function_ContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Function_ContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 332, RULE_function_);
        let mut _localctx: Rc<Function_ContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2099);
			recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- language ----------------
pub type LanguageContextAll<'input> = LanguageContext<'input>;


pub type LanguageContext<'input> = BaseParserRuleContext<'input,LanguageContextExt<'input>>;

#[derive(Clone)]
pub struct LanguageContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for LanguageContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for LanguageContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_language(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_language(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for LanguageContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_language(self);
	}
}

impl<'input> CustomRuleContext<'input> for LanguageContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_language }
	//fn type_rule_index() -> usize where Self: Sized { RULE_language }
}
antlr_rust::type_id!{LanguageContextExt<'a>}

impl<'input> LanguageContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LanguageContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LanguageContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LanguageContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<LanguageContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OBJECT_NAME
/// Returns `None` if there is no child corresponding to token OBJECT_NAME
fn OBJECT_NAME(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OBJECT_NAME, 0)
}

}

impl<'input> LanguageContextAttrs<'input> for LanguageContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn language(&mut self,)
	-> Result<Rc<LanguageContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LanguageContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 334, RULE_language);
        let mut _localctx: Rc<LanguageContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2101);
			recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- user ----------------
pub type UserContextAll<'input> = UserContext<'input>;


pub type UserContext<'input> = BaseParserRuleContext<'input,UserContextExt<'input>>;

#[derive(Clone)]
pub struct UserContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for UserContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for UserContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_user(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_user(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for UserContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_user(self);
	}
}

impl<'input> CustomRuleContext<'input> for UserContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_user }
	//fn type_rule_index() -> usize where Self: Sized { RULE_user }
}
antlr_rust::type_id!{UserContextExt<'a>}

impl<'input> UserContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UserContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UserContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UserContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<UserContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OBJECT_NAME
/// Returns `None` if there is no child corresponding to token OBJECT_NAME
fn OBJECT_NAME(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OBJECT_NAME, 0)
}

}

impl<'input> UserContextAttrs<'input> for UserContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn user(&mut self,)
	-> Result<Rc<UserContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UserContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 336, RULE_user);
        let mut _localctx: Rc<UserContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2103);
			recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- password ----------------
pub type PasswordContextAll<'input> = PasswordContext<'input>;


pub type PasswordContext<'input> = BaseParserRuleContext<'input,PasswordContextExt<'input>>;

#[derive(Clone)]
pub struct PasswordContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for PasswordContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for PasswordContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_password(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_password(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for PasswordContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_password(self);
	}
}

impl<'input> CustomRuleContext<'input> for PasswordContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_password }
	//fn type_rule_index() -> usize where Self: Sized { RULE_password }
}
antlr_rust::type_id!{PasswordContextExt<'a>}

impl<'input> PasswordContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PasswordContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PasswordContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PasswordContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<PasswordContextExt<'input>>{

fn stringLiteral(&self) -> Option<Rc<StringLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PasswordContextAttrs<'input> for PasswordContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn password(&mut self,)
	-> Result<Rc<PasswordContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PasswordContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 338, RULE_password);
        let mut _localctx: Rc<PasswordContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule stringLiteral*/
			recog.base.set_state(2105);
			recog.stringLiteral()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- hashKey ----------------
pub type HashKeyContextAll<'input> = HashKeyContext<'input>;


pub type HashKeyContext<'input> = BaseParserRuleContext<'input,HashKeyContextExt<'input>>;

#[derive(Clone)]
pub struct HashKeyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for HashKeyContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for HashKeyContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_hashKey(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_hashKey(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for HashKeyContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_hashKey(self);
	}
}

impl<'input> CustomRuleContext<'input> for HashKeyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_hashKey }
	//fn type_rule_index() -> usize where Self: Sized { RULE_hashKey }
}
antlr_rust::type_id!{HashKeyContextExt<'a>}

impl<'input> HashKeyContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<HashKeyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,HashKeyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait HashKeyContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<HashKeyContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OBJECT_NAME
/// Returns `None` if there is no child corresponding to token OBJECT_NAME
fn OBJECT_NAME(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OBJECT_NAME, 0)
}

}

impl<'input> HashKeyContextAttrs<'input> for HashKeyContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn hashKey(&mut self,)
	-> Result<Rc<HashKeyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = HashKeyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 340, RULE_hashKey);
        let mut _localctx: Rc<HashKeyContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2107);
			recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- param ----------------
pub type ParamContextAll<'input> = ParamContext<'input>;


pub type ParamContext<'input> = BaseParserRuleContext<'input,ParamContextExt<'input>>;

#[derive(Clone)]
pub struct ParamContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for ParamContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for ParamContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_param(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_param(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for ParamContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_param(self);
	}
}

impl<'input> CustomRuleContext<'input> for ParamContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_param }
	//fn type_rule_index() -> usize where Self: Sized { RULE_param }
}
antlr_rust::type_id!{ParamContextExt<'a>}

impl<'input> ParamContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ParamContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ParamContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ParamContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<ParamContextExt<'input>>{

fn paramName(&self) -> Option<Rc<ParamNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn dataType(&self) -> Option<Rc<DataTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ParamContextAttrs<'input> for ParamContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn param(&mut self,)
	-> Result<Rc<ParamContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ParamContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 342, RULE_param);
        let mut _localctx: Rc<ParamContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule paramName*/
			recog.base.set_state(2109);
			recog.paramName()?;

			/*InvokeRule dataType*/
			recog.base.set_state(2110);
			recog.dataType()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- paramName ----------------
pub type ParamNameContextAll<'input> = ParamNameContext<'input>;


pub type ParamNameContext<'input> = BaseParserRuleContext<'input,ParamNameContextExt<'input>>;

#[derive(Clone)]
pub struct ParamNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for ParamNameContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for ParamNameContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_paramName(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_paramName(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for ParamNameContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_paramName(self);
	}
}

impl<'input> CustomRuleContext<'input> for ParamNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_paramName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_paramName }
}
antlr_rust::type_id!{ParamNameContextExt<'a>}

impl<'input> ParamNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ParamNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ParamNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ParamNameContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<ParamNameContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OBJECT_NAME
/// Returns `None` if there is no child corresponding to token OBJECT_NAME
fn OBJECT_NAME(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OBJECT_NAME, 0)
}

}

impl<'input> ParamNameContextAttrs<'input> for ParamNameContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn paramName(&mut self,)
	-> Result<Rc<ParamNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ParamNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 344, RULE_paramName);
        let mut _localctx: Rc<ParamNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2112);
			recog.base.match_token(OBJECT_NAME,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwAdd ----------------
pub type KwAddContextAll<'input> = KwAddContext<'input>;


pub type KwAddContext<'input> = BaseParserRuleContext<'input,KwAddContextExt<'input>>;

#[derive(Clone)]
pub struct KwAddContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwAddContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwAddContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwAdd(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwAdd(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwAddContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwAdd(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwAddContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwAdd }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwAdd }
}
antlr_rust::type_id!{KwAddContextExt<'a>}

impl<'input> KwAddContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwAddContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwAddContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwAddContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwAddContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_ADD
/// Returns `None` if there is no child corresponding to token K_ADD
fn K_ADD(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_ADD, 0)
}

}

impl<'input> KwAddContextAttrs<'input> for KwAddContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwAdd(&mut self,)
	-> Result<Rc<KwAddContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwAddContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 346, RULE_kwAdd);
        let mut _localctx: Rc<KwAddContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2114);
			recog.base.match_token(K_ADD,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwAggregate ----------------
pub type KwAggregateContextAll<'input> = KwAggregateContext<'input>;


pub type KwAggregateContext<'input> = BaseParserRuleContext<'input,KwAggregateContextExt<'input>>;

#[derive(Clone)]
pub struct KwAggregateContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwAggregateContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwAggregateContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwAggregate(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwAggregate(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwAggregateContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwAggregate(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwAggregateContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwAggregate }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwAggregate }
}
antlr_rust::type_id!{KwAggregateContextExt<'a>}

impl<'input> KwAggregateContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwAggregateContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwAggregateContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwAggregateContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwAggregateContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_AGGREGATE
/// Returns `None` if there is no child corresponding to token K_AGGREGATE
fn K_AGGREGATE(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_AGGREGATE, 0)
}

}

impl<'input> KwAggregateContextAttrs<'input> for KwAggregateContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwAggregate(&mut self,)
	-> Result<Rc<KwAggregateContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwAggregateContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 348, RULE_kwAggregate);
        let mut _localctx: Rc<KwAggregateContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2116);
			recog.base.match_token(K_AGGREGATE,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwAll ----------------
pub type KwAllContextAll<'input> = KwAllContext<'input>;


pub type KwAllContext<'input> = BaseParserRuleContext<'input,KwAllContextExt<'input>>;

#[derive(Clone)]
pub struct KwAllContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwAllContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwAllContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwAll(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwAll(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwAllContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwAll(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwAllContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwAll }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwAll }
}
antlr_rust::type_id!{KwAllContextExt<'a>}

impl<'input> KwAllContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwAllContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwAllContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwAllContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwAllContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_ALL
/// Returns `None` if there is no child corresponding to token K_ALL
fn K_ALL(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_ALL, 0)
}

}

impl<'input> KwAllContextAttrs<'input> for KwAllContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwAll(&mut self,)
	-> Result<Rc<KwAllContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwAllContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 350, RULE_kwAll);
        let mut _localctx: Rc<KwAllContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2118);
			recog.base.match_token(K_ALL,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwAllPermissions ----------------
pub type KwAllPermissionsContextAll<'input> = KwAllPermissionsContext<'input>;


pub type KwAllPermissionsContext<'input> = BaseParserRuleContext<'input,KwAllPermissionsContextExt<'input>>;

#[derive(Clone)]
pub struct KwAllPermissionsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwAllPermissionsContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwAllPermissionsContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwAllPermissions(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwAllPermissions(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwAllPermissionsContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwAllPermissions(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwAllPermissionsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwAllPermissions }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwAllPermissions }
}
antlr_rust::type_id!{KwAllPermissionsContextExt<'a>}

impl<'input> KwAllPermissionsContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwAllPermissionsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwAllPermissionsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwAllPermissionsContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwAllPermissionsContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_ALL
/// Returns `None` if there is no child corresponding to token K_ALL
fn K_ALL(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_ALL, 0)
}
/// Retrieves first TerminalNode corresponding to token K_PERMISSIONS
/// Returns `None` if there is no child corresponding to token K_PERMISSIONS
fn K_PERMISSIONS(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_PERMISSIONS, 0)
}

}

impl<'input> KwAllPermissionsContextAttrs<'input> for KwAllPermissionsContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwAllPermissions(&mut self,)
	-> Result<Rc<KwAllPermissionsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwAllPermissionsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 352, RULE_kwAllPermissions);
        let mut _localctx: Rc<KwAllPermissionsContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2120);
			recog.base.match_token(K_ALL,&mut recog.err_handler)?;

			recog.base.set_state(2121);
			recog.base.match_token(K_PERMISSIONS,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwAllow ----------------
pub type KwAllowContextAll<'input> = KwAllowContext<'input>;


pub type KwAllowContext<'input> = BaseParserRuleContext<'input,KwAllowContextExt<'input>>;

#[derive(Clone)]
pub struct KwAllowContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwAllowContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwAllowContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwAllow(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwAllow(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwAllowContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwAllow(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwAllowContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwAllow }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwAllow }
}
antlr_rust::type_id!{KwAllowContextExt<'a>}

impl<'input> KwAllowContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwAllowContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwAllowContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwAllowContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwAllowContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_ALLOW
/// Returns `None` if there is no child corresponding to token K_ALLOW
fn K_ALLOW(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_ALLOW, 0)
}

}

impl<'input> KwAllowContextAttrs<'input> for KwAllowContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwAllow(&mut self,)
	-> Result<Rc<KwAllowContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwAllowContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 354, RULE_kwAllow);
        let mut _localctx: Rc<KwAllowContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2123);
			recog.base.match_token(K_ALLOW,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwAlter ----------------
pub type KwAlterContextAll<'input> = KwAlterContext<'input>;


pub type KwAlterContext<'input> = BaseParserRuleContext<'input,KwAlterContextExt<'input>>;

#[derive(Clone)]
pub struct KwAlterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwAlterContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwAlterContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwAlter(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwAlter(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwAlterContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwAlter(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwAlterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwAlter }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwAlter }
}
antlr_rust::type_id!{KwAlterContextExt<'a>}

impl<'input> KwAlterContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwAlterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwAlterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwAlterContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwAlterContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_ALTER
/// Returns `None` if there is no child corresponding to token K_ALTER
fn K_ALTER(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_ALTER, 0)
}

}

impl<'input> KwAlterContextAttrs<'input> for KwAlterContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwAlter(&mut self,)
	-> Result<Rc<KwAlterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwAlterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 356, RULE_kwAlter);
        let mut _localctx: Rc<KwAlterContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2125);
			recog.base.match_token(K_ALTER,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwAnd ----------------
pub type KwAndContextAll<'input> = KwAndContext<'input>;


pub type KwAndContext<'input> = BaseParserRuleContext<'input,KwAndContextExt<'input>>;

#[derive(Clone)]
pub struct KwAndContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwAndContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwAndContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwAnd(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwAnd(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwAndContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwAnd(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwAndContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwAnd }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwAnd }
}
antlr_rust::type_id!{KwAndContextExt<'a>}

impl<'input> KwAndContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwAndContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwAndContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwAndContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwAndContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_AND
/// Returns `None` if there is no child corresponding to token K_AND
fn K_AND(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_AND, 0)
}

}

impl<'input> KwAndContextAttrs<'input> for KwAndContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwAnd(&mut self,)
	-> Result<Rc<KwAndContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwAndContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 358, RULE_kwAnd);
        let mut _localctx: Rc<KwAndContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2127);
			recog.base.match_token(K_AND,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwApply ----------------
pub type KwApplyContextAll<'input> = KwApplyContext<'input>;


pub type KwApplyContext<'input> = BaseParserRuleContext<'input,KwApplyContextExt<'input>>;

#[derive(Clone)]
pub struct KwApplyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwApplyContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwApplyContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwApply(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwApply(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwApplyContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwApply(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwApplyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwApply }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwApply }
}
antlr_rust::type_id!{KwApplyContextExt<'a>}

impl<'input> KwApplyContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwApplyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwApplyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwApplyContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwApplyContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_APPLY
/// Returns `None` if there is no child corresponding to token K_APPLY
fn K_APPLY(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_APPLY, 0)
}

}

impl<'input> KwApplyContextAttrs<'input> for KwApplyContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwApply(&mut self,)
	-> Result<Rc<KwApplyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwApplyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 360, RULE_kwApply);
        let mut _localctx: Rc<KwApplyContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2129);
			recog.base.match_token(K_APPLY,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwAs ----------------
pub type KwAsContextAll<'input> = KwAsContext<'input>;


pub type KwAsContext<'input> = BaseParserRuleContext<'input,KwAsContextExt<'input>>;

#[derive(Clone)]
pub struct KwAsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwAsContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwAsContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwAs(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwAs(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwAsContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwAs(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwAsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwAs }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwAs }
}
antlr_rust::type_id!{KwAsContextExt<'a>}

impl<'input> KwAsContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwAsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwAsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwAsContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwAsContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_AS
/// Returns `None` if there is no child corresponding to token K_AS
fn K_AS(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_AS, 0)
}

}

impl<'input> KwAsContextAttrs<'input> for KwAsContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwAs(&mut self,)
	-> Result<Rc<KwAsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwAsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 362, RULE_kwAs);
        let mut _localctx: Rc<KwAsContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2131);
			recog.base.match_token(K_AS,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwAsc ----------------
pub type KwAscContextAll<'input> = KwAscContext<'input>;


pub type KwAscContext<'input> = BaseParserRuleContext<'input,KwAscContextExt<'input>>;

#[derive(Clone)]
pub struct KwAscContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwAscContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwAscContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwAsc(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwAsc(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwAscContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwAsc(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwAscContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwAsc }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwAsc }
}
antlr_rust::type_id!{KwAscContextExt<'a>}

impl<'input> KwAscContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwAscContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwAscContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwAscContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwAscContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_ASC
/// Returns `None` if there is no child corresponding to token K_ASC
fn K_ASC(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_ASC, 0)
}

}

impl<'input> KwAscContextAttrs<'input> for KwAscContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwAsc(&mut self,)
	-> Result<Rc<KwAscContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwAscContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 364, RULE_kwAsc);
        let mut _localctx: Rc<KwAscContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2133);
			recog.base.match_token(K_ASC,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwAuthorize ----------------
pub type KwAuthorizeContextAll<'input> = KwAuthorizeContext<'input>;


pub type KwAuthorizeContext<'input> = BaseParserRuleContext<'input,KwAuthorizeContextExt<'input>>;

#[derive(Clone)]
pub struct KwAuthorizeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwAuthorizeContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwAuthorizeContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwAuthorize(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwAuthorize(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwAuthorizeContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwAuthorize(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwAuthorizeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwAuthorize }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwAuthorize }
}
antlr_rust::type_id!{KwAuthorizeContextExt<'a>}

impl<'input> KwAuthorizeContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwAuthorizeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwAuthorizeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwAuthorizeContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwAuthorizeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_AUTHORIZE
/// Returns `None` if there is no child corresponding to token K_AUTHORIZE
fn K_AUTHORIZE(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_AUTHORIZE, 0)
}

}

impl<'input> KwAuthorizeContextAttrs<'input> for KwAuthorizeContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwAuthorize(&mut self,)
	-> Result<Rc<KwAuthorizeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwAuthorizeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 366, RULE_kwAuthorize);
        let mut _localctx: Rc<KwAuthorizeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2135);
			recog.base.match_token(K_AUTHORIZE,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwBatch ----------------
pub type KwBatchContextAll<'input> = KwBatchContext<'input>;


pub type KwBatchContext<'input> = BaseParserRuleContext<'input,KwBatchContextExt<'input>>;

#[derive(Clone)]
pub struct KwBatchContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwBatchContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwBatchContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwBatch(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwBatch(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwBatchContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwBatch(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwBatchContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwBatch }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwBatch }
}
antlr_rust::type_id!{KwBatchContextExt<'a>}

impl<'input> KwBatchContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwBatchContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwBatchContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwBatchContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwBatchContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_BATCH
/// Returns `None` if there is no child corresponding to token K_BATCH
fn K_BATCH(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_BATCH, 0)
}

}

impl<'input> KwBatchContextAttrs<'input> for KwBatchContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwBatch(&mut self,)
	-> Result<Rc<KwBatchContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwBatchContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 368, RULE_kwBatch);
        let mut _localctx: Rc<KwBatchContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2137);
			recog.base.match_token(K_BATCH,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwBegin ----------------
pub type KwBeginContextAll<'input> = KwBeginContext<'input>;


pub type KwBeginContext<'input> = BaseParserRuleContext<'input,KwBeginContextExt<'input>>;

#[derive(Clone)]
pub struct KwBeginContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwBeginContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwBeginContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwBegin(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwBegin(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwBeginContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwBegin(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwBeginContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwBegin }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwBegin }
}
antlr_rust::type_id!{KwBeginContextExt<'a>}

impl<'input> KwBeginContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwBeginContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwBeginContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwBeginContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwBeginContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_BEGIN
/// Returns `None` if there is no child corresponding to token K_BEGIN
fn K_BEGIN(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_BEGIN, 0)
}

}

impl<'input> KwBeginContextAttrs<'input> for KwBeginContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwBegin(&mut self,)
	-> Result<Rc<KwBeginContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwBeginContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 370, RULE_kwBegin);
        let mut _localctx: Rc<KwBeginContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2139);
			recog.base.match_token(K_BEGIN,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwBy ----------------
pub type KwByContextAll<'input> = KwByContext<'input>;


pub type KwByContext<'input> = BaseParserRuleContext<'input,KwByContextExt<'input>>;

#[derive(Clone)]
pub struct KwByContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwByContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwByContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwBy(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwBy(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwByContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwBy(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwByContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwBy }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwBy }
}
antlr_rust::type_id!{KwByContextExt<'a>}

impl<'input> KwByContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwByContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwByContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwByContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwByContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_BY
/// Returns `None` if there is no child corresponding to token K_BY
fn K_BY(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_BY, 0)
}

}

impl<'input> KwByContextAttrs<'input> for KwByContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwBy(&mut self,)
	-> Result<Rc<KwByContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwByContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 372, RULE_kwBy);
        let mut _localctx: Rc<KwByContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2141);
			recog.base.match_token(K_BY,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwCalled ----------------
pub type KwCalledContextAll<'input> = KwCalledContext<'input>;


pub type KwCalledContext<'input> = BaseParserRuleContext<'input,KwCalledContextExt<'input>>;

#[derive(Clone)]
pub struct KwCalledContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwCalledContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwCalledContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwCalled(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwCalled(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwCalledContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwCalled(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwCalledContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwCalled }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwCalled }
}
antlr_rust::type_id!{KwCalledContextExt<'a>}

impl<'input> KwCalledContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwCalledContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwCalledContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwCalledContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwCalledContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_CALLED
/// Returns `None` if there is no child corresponding to token K_CALLED
fn K_CALLED(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_CALLED, 0)
}

}

impl<'input> KwCalledContextAttrs<'input> for KwCalledContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwCalled(&mut self,)
	-> Result<Rc<KwCalledContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwCalledContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 374, RULE_kwCalled);
        let mut _localctx: Rc<KwCalledContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2143);
			recog.base.match_token(K_CALLED,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwClustering ----------------
pub type KwClusteringContextAll<'input> = KwClusteringContext<'input>;


pub type KwClusteringContext<'input> = BaseParserRuleContext<'input,KwClusteringContextExt<'input>>;

#[derive(Clone)]
pub struct KwClusteringContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwClusteringContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwClusteringContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwClustering(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwClustering(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwClusteringContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwClustering(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwClusteringContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwClustering }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwClustering }
}
antlr_rust::type_id!{KwClusteringContextExt<'a>}

impl<'input> KwClusteringContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwClusteringContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwClusteringContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwClusteringContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwClusteringContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_CLUSTERING
/// Returns `None` if there is no child corresponding to token K_CLUSTERING
fn K_CLUSTERING(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_CLUSTERING, 0)
}

}

impl<'input> KwClusteringContextAttrs<'input> for KwClusteringContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwClustering(&mut self,)
	-> Result<Rc<KwClusteringContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwClusteringContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 376, RULE_kwClustering);
        let mut _localctx: Rc<KwClusteringContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2145);
			recog.base.match_token(K_CLUSTERING,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwCompact ----------------
pub type KwCompactContextAll<'input> = KwCompactContext<'input>;


pub type KwCompactContext<'input> = BaseParserRuleContext<'input,KwCompactContextExt<'input>>;

#[derive(Clone)]
pub struct KwCompactContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwCompactContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwCompactContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwCompact(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwCompact(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwCompactContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwCompact(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwCompactContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwCompact }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwCompact }
}
antlr_rust::type_id!{KwCompactContextExt<'a>}

impl<'input> KwCompactContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwCompactContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwCompactContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwCompactContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwCompactContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_COMPACT
/// Returns `None` if there is no child corresponding to token K_COMPACT
fn K_COMPACT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_COMPACT, 0)
}

}

impl<'input> KwCompactContextAttrs<'input> for KwCompactContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwCompact(&mut self,)
	-> Result<Rc<KwCompactContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwCompactContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 378, RULE_kwCompact);
        let mut _localctx: Rc<KwCompactContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2147);
			recog.base.match_token(K_COMPACT,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwContains ----------------
pub type KwContainsContextAll<'input> = KwContainsContext<'input>;


pub type KwContainsContext<'input> = BaseParserRuleContext<'input,KwContainsContextExt<'input>>;

#[derive(Clone)]
pub struct KwContainsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwContainsContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwContainsContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwContains(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwContains(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwContainsContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwContains(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwContainsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwContains }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwContains }
}
antlr_rust::type_id!{KwContainsContextExt<'a>}

impl<'input> KwContainsContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwContainsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwContainsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwContainsContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwContainsContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_CONTAINS
/// Returns `None` if there is no child corresponding to token K_CONTAINS
fn K_CONTAINS(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_CONTAINS, 0)
}

}

impl<'input> KwContainsContextAttrs<'input> for KwContainsContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwContains(&mut self,)
	-> Result<Rc<KwContainsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwContainsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 380, RULE_kwContains);
        let mut _localctx: Rc<KwContainsContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2149);
			recog.base.match_token(K_CONTAINS,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwCreate ----------------
pub type KwCreateContextAll<'input> = KwCreateContext<'input>;


pub type KwCreateContext<'input> = BaseParserRuleContext<'input,KwCreateContextExt<'input>>;

#[derive(Clone)]
pub struct KwCreateContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwCreateContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwCreateContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwCreate(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwCreate(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwCreateContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwCreate(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwCreateContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwCreate }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwCreate }
}
antlr_rust::type_id!{KwCreateContextExt<'a>}

impl<'input> KwCreateContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwCreateContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwCreateContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwCreateContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwCreateContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_CREATE
/// Returns `None` if there is no child corresponding to token K_CREATE
fn K_CREATE(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_CREATE, 0)
}

}

impl<'input> KwCreateContextAttrs<'input> for KwCreateContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwCreate(&mut self,)
	-> Result<Rc<KwCreateContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwCreateContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 382, RULE_kwCreate);
        let mut _localctx: Rc<KwCreateContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2151);
			recog.base.match_token(K_CREATE,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwDelete ----------------
pub type KwDeleteContextAll<'input> = KwDeleteContext<'input>;


pub type KwDeleteContext<'input> = BaseParserRuleContext<'input,KwDeleteContextExt<'input>>;

#[derive(Clone)]
pub struct KwDeleteContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwDeleteContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwDeleteContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwDelete(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwDelete(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwDeleteContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwDelete(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwDeleteContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwDelete }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwDelete }
}
antlr_rust::type_id!{KwDeleteContextExt<'a>}

impl<'input> KwDeleteContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwDeleteContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwDeleteContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwDeleteContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwDeleteContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_DELETE
/// Returns `None` if there is no child corresponding to token K_DELETE
fn K_DELETE(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_DELETE, 0)
}

}

impl<'input> KwDeleteContextAttrs<'input> for KwDeleteContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwDelete(&mut self,)
	-> Result<Rc<KwDeleteContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwDeleteContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 384, RULE_kwDelete);
        let mut _localctx: Rc<KwDeleteContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2153);
			recog.base.match_token(K_DELETE,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwDesc ----------------
pub type KwDescContextAll<'input> = KwDescContext<'input>;


pub type KwDescContext<'input> = BaseParserRuleContext<'input,KwDescContextExt<'input>>;

#[derive(Clone)]
pub struct KwDescContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwDescContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwDescContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwDesc(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwDesc(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwDescContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwDesc(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwDescContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwDesc }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwDesc }
}
antlr_rust::type_id!{KwDescContextExt<'a>}

impl<'input> KwDescContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwDescContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwDescContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwDescContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwDescContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_DESC
/// Returns `None` if there is no child corresponding to token K_DESC
fn K_DESC(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_DESC, 0)
}

}

impl<'input> KwDescContextAttrs<'input> for KwDescContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwDesc(&mut self,)
	-> Result<Rc<KwDescContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwDescContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 386, RULE_kwDesc);
        let mut _localctx: Rc<KwDescContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2155);
			recog.base.match_token(K_DESC,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwDescibe ----------------
pub type KwDescibeContextAll<'input> = KwDescibeContext<'input>;


pub type KwDescibeContext<'input> = BaseParserRuleContext<'input,KwDescibeContextExt<'input>>;

#[derive(Clone)]
pub struct KwDescibeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwDescibeContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwDescibeContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwDescibe(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwDescibe(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwDescibeContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwDescibe(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwDescibeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwDescibe }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwDescibe }
}
antlr_rust::type_id!{KwDescibeContextExt<'a>}

impl<'input> KwDescibeContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwDescibeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwDescibeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwDescibeContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwDescibeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_DESCRIBE
/// Returns `None` if there is no child corresponding to token K_DESCRIBE
fn K_DESCRIBE(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_DESCRIBE, 0)
}

}

impl<'input> KwDescibeContextAttrs<'input> for KwDescibeContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwDescibe(&mut self,)
	-> Result<Rc<KwDescibeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwDescibeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 388, RULE_kwDescibe);
        let mut _localctx: Rc<KwDescibeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2157);
			recog.base.match_token(K_DESCRIBE,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwDistinct ----------------
pub type KwDistinctContextAll<'input> = KwDistinctContext<'input>;


pub type KwDistinctContext<'input> = BaseParserRuleContext<'input,KwDistinctContextExt<'input>>;

#[derive(Clone)]
pub struct KwDistinctContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwDistinctContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwDistinctContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwDistinct(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwDistinct(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwDistinctContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwDistinct(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwDistinctContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwDistinct }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwDistinct }
}
antlr_rust::type_id!{KwDistinctContextExt<'a>}

impl<'input> KwDistinctContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwDistinctContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwDistinctContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwDistinctContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwDistinctContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_DISTINCT
/// Returns `None` if there is no child corresponding to token K_DISTINCT
fn K_DISTINCT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_DISTINCT, 0)
}

}

impl<'input> KwDistinctContextAttrs<'input> for KwDistinctContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwDistinct(&mut self,)
	-> Result<Rc<KwDistinctContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwDistinctContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 390, RULE_kwDistinct);
        let mut _localctx: Rc<KwDistinctContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2159);
			recog.base.match_token(K_DISTINCT,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwDrop ----------------
pub type KwDropContextAll<'input> = KwDropContext<'input>;


pub type KwDropContext<'input> = BaseParserRuleContext<'input,KwDropContextExt<'input>>;

#[derive(Clone)]
pub struct KwDropContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwDropContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwDropContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwDrop(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwDrop(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwDropContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwDrop(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwDropContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwDrop }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwDrop }
}
antlr_rust::type_id!{KwDropContextExt<'a>}

impl<'input> KwDropContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwDropContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwDropContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwDropContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwDropContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_DROP
/// Returns `None` if there is no child corresponding to token K_DROP
fn K_DROP(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_DROP, 0)
}

}

impl<'input> KwDropContextAttrs<'input> for KwDropContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwDrop(&mut self,)
	-> Result<Rc<KwDropContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwDropContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 392, RULE_kwDrop);
        let mut _localctx: Rc<KwDropContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2161);
			recog.base.match_token(K_DROP,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwDurableWrites ----------------
pub type KwDurableWritesContextAll<'input> = KwDurableWritesContext<'input>;


pub type KwDurableWritesContext<'input> = BaseParserRuleContext<'input,KwDurableWritesContextExt<'input>>;

#[derive(Clone)]
pub struct KwDurableWritesContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwDurableWritesContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwDurableWritesContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwDurableWrites(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwDurableWrites(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwDurableWritesContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwDurableWrites(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwDurableWritesContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwDurableWrites }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwDurableWrites }
}
antlr_rust::type_id!{KwDurableWritesContextExt<'a>}

impl<'input> KwDurableWritesContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwDurableWritesContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwDurableWritesContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwDurableWritesContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwDurableWritesContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_DURABLE_WRITES
/// Returns `None` if there is no child corresponding to token K_DURABLE_WRITES
fn K_DURABLE_WRITES(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_DURABLE_WRITES, 0)
}

}

impl<'input> KwDurableWritesContextAttrs<'input> for KwDurableWritesContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwDurableWrites(&mut self,)
	-> Result<Rc<KwDurableWritesContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwDurableWritesContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 394, RULE_kwDurableWrites);
        let mut _localctx: Rc<KwDurableWritesContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2163);
			recog.base.match_token(K_DURABLE_WRITES,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwEntries ----------------
pub type KwEntriesContextAll<'input> = KwEntriesContext<'input>;


pub type KwEntriesContext<'input> = BaseParserRuleContext<'input,KwEntriesContextExt<'input>>;

#[derive(Clone)]
pub struct KwEntriesContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwEntriesContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwEntriesContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwEntries(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwEntries(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwEntriesContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwEntries(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwEntriesContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwEntries }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwEntries }
}
antlr_rust::type_id!{KwEntriesContextExt<'a>}

impl<'input> KwEntriesContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwEntriesContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwEntriesContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwEntriesContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwEntriesContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_ENTRIES
/// Returns `None` if there is no child corresponding to token K_ENTRIES
fn K_ENTRIES(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_ENTRIES, 0)
}

}

impl<'input> KwEntriesContextAttrs<'input> for KwEntriesContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwEntries(&mut self,)
	-> Result<Rc<KwEntriesContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwEntriesContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 396, RULE_kwEntries);
        let mut _localctx: Rc<KwEntriesContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2165);
			recog.base.match_token(K_ENTRIES,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwExecute ----------------
pub type KwExecuteContextAll<'input> = KwExecuteContext<'input>;


pub type KwExecuteContext<'input> = BaseParserRuleContext<'input,KwExecuteContextExt<'input>>;

#[derive(Clone)]
pub struct KwExecuteContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwExecuteContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwExecuteContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwExecute(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwExecute(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwExecuteContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwExecute(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwExecuteContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwExecute }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwExecute }
}
antlr_rust::type_id!{KwExecuteContextExt<'a>}

impl<'input> KwExecuteContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwExecuteContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwExecuteContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwExecuteContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwExecuteContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_EXECUTE
/// Returns `None` if there is no child corresponding to token K_EXECUTE
fn K_EXECUTE(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_EXECUTE, 0)
}

}

impl<'input> KwExecuteContextAttrs<'input> for KwExecuteContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwExecute(&mut self,)
	-> Result<Rc<KwExecuteContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwExecuteContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 398, RULE_kwExecute);
        let mut _localctx: Rc<KwExecuteContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2167);
			recog.base.match_token(K_EXECUTE,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwExists ----------------
pub type KwExistsContextAll<'input> = KwExistsContext<'input>;


pub type KwExistsContext<'input> = BaseParserRuleContext<'input,KwExistsContextExt<'input>>;

#[derive(Clone)]
pub struct KwExistsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwExistsContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwExistsContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwExists(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwExists(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwExistsContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwExists(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwExistsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwExists }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwExists }
}
antlr_rust::type_id!{KwExistsContextExt<'a>}

impl<'input> KwExistsContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwExistsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwExistsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwExistsContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwExistsContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_EXISTS
/// Returns `None` if there is no child corresponding to token K_EXISTS
fn K_EXISTS(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_EXISTS, 0)
}

}

impl<'input> KwExistsContextAttrs<'input> for KwExistsContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwExists(&mut self,)
	-> Result<Rc<KwExistsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwExistsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 400, RULE_kwExists);
        let mut _localctx: Rc<KwExistsContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2169);
			recog.base.match_token(K_EXISTS,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwFiltering ----------------
pub type KwFilteringContextAll<'input> = KwFilteringContext<'input>;


pub type KwFilteringContext<'input> = BaseParserRuleContext<'input,KwFilteringContextExt<'input>>;

#[derive(Clone)]
pub struct KwFilteringContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwFilteringContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwFilteringContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwFiltering(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwFiltering(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwFilteringContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwFiltering(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwFilteringContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwFiltering }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwFiltering }
}
antlr_rust::type_id!{KwFilteringContextExt<'a>}

impl<'input> KwFilteringContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwFilteringContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwFilteringContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwFilteringContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwFilteringContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_FILTERING
/// Returns `None` if there is no child corresponding to token K_FILTERING
fn K_FILTERING(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_FILTERING, 0)
}

}

impl<'input> KwFilteringContextAttrs<'input> for KwFilteringContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwFiltering(&mut self,)
	-> Result<Rc<KwFilteringContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwFilteringContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 402, RULE_kwFiltering);
        let mut _localctx: Rc<KwFilteringContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2171);
			recog.base.match_token(K_FILTERING,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwFinalfunc ----------------
pub type KwFinalfuncContextAll<'input> = KwFinalfuncContext<'input>;


pub type KwFinalfuncContext<'input> = BaseParserRuleContext<'input,KwFinalfuncContextExt<'input>>;

#[derive(Clone)]
pub struct KwFinalfuncContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwFinalfuncContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwFinalfuncContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwFinalfunc(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwFinalfunc(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwFinalfuncContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwFinalfunc(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwFinalfuncContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwFinalfunc }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwFinalfunc }
}
antlr_rust::type_id!{KwFinalfuncContextExt<'a>}

impl<'input> KwFinalfuncContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwFinalfuncContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwFinalfuncContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwFinalfuncContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwFinalfuncContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_FINALFUNC
/// Returns `None` if there is no child corresponding to token K_FINALFUNC
fn K_FINALFUNC(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_FINALFUNC, 0)
}

}

impl<'input> KwFinalfuncContextAttrs<'input> for KwFinalfuncContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwFinalfunc(&mut self,)
	-> Result<Rc<KwFinalfuncContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwFinalfuncContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 404, RULE_kwFinalfunc);
        let mut _localctx: Rc<KwFinalfuncContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2173);
			recog.base.match_token(K_FINALFUNC,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwFrom ----------------
pub type KwFromContextAll<'input> = KwFromContext<'input>;


pub type KwFromContext<'input> = BaseParserRuleContext<'input,KwFromContextExt<'input>>;

#[derive(Clone)]
pub struct KwFromContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwFromContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwFromContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwFrom(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwFrom(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwFromContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwFrom(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwFromContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwFrom }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwFrom }
}
antlr_rust::type_id!{KwFromContextExt<'a>}

impl<'input> KwFromContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwFromContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwFromContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwFromContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwFromContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_FROM
/// Returns `None` if there is no child corresponding to token K_FROM
fn K_FROM(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_FROM, 0)
}

}

impl<'input> KwFromContextAttrs<'input> for KwFromContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwFrom(&mut self,)
	-> Result<Rc<KwFromContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwFromContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 406, RULE_kwFrom);
        let mut _localctx: Rc<KwFromContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2175);
			recog.base.match_token(K_FROM,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwFull ----------------
pub type KwFullContextAll<'input> = KwFullContext<'input>;


pub type KwFullContext<'input> = BaseParserRuleContext<'input,KwFullContextExt<'input>>;

#[derive(Clone)]
pub struct KwFullContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwFullContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwFullContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwFull(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwFull(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwFullContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwFull(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwFullContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwFull }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwFull }
}
antlr_rust::type_id!{KwFullContextExt<'a>}

impl<'input> KwFullContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwFullContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwFullContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwFullContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwFullContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_FULL
/// Returns `None` if there is no child corresponding to token K_FULL
fn K_FULL(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_FULL, 0)
}

}

impl<'input> KwFullContextAttrs<'input> for KwFullContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwFull(&mut self,)
	-> Result<Rc<KwFullContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwFullContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 408, RULE_kwFull);
        let mut _localctx: Rc<KwFullContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2177);
			recog.base.match_token(K_FULL,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwFunction ----------------
pub type KwFunctionContextAll<'input> = KwFunctionContext<'input>;


pub type KwFunctionContext<'input> = BaseParserRuleContext<'input,KwFunctionContextExt<'input>>;

#[derive(Clone)]
pub struct KwFunctionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwFunctionContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwFunctionContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwFunction(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwFunction(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwFunctionContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwFunction(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwFunctionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwFunction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwFunction }
}
antlr_rust::type_id!{KwFunctionContextExt<'a>}

impl<'input> KwFunctionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwFunctionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwFunctionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwFunctionContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwFunctionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_FUNCTION
/// Returns `None` if there is no child corresponding to token K_FUNCTION
fn K_FUNCTION(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_FUNCTION, 0)
}

}

impl<'input> KwFunctionContextAttrs<'input> for KwFunctionContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwFunction(&mut self,)
	-> Result<Rc<KwFunctionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwFunctionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 410, RULE_kwFunction);
        let mut _localctx: Rc<KwFunctionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2179);
			recog.base.match_token(K_FUNCTION,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwFunctions ----------------
pub type KwFunctionsContextAll<'input> = KwFunctionsContext<'input>;


pub type KwFunctionsContext<'input> = BaseParserRuleContext<'input,KwFunctionsContextExt<'input>>;

#[derive(Clone)]
pub struct KwFunctionsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwFunctionsContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwFunctionsContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwFunctions(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwFunctions(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwFunctionsContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwFunctions(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwFunctionsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwFunctions }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwFunctions }
}
antlr_rust::type_id!{KwFunctionsContextExt<'a>}

impl<'input> KwFunctionsContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwFunctionsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwFunctionsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwFunctionsContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwFunctionsContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_FUNCTIONS
/// Returns `None` if there is no child corresponding to token K_FUNCTIONS
fn K_FUNCTIONS(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_FUNCTIONS, 0)
}

}

impl<'input> KwFunctionsContextAttrs<'input> for KwFunctionsContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwFunctions(&mut self,)
	-> Result<Rc<KwFunctionsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwFunctionsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 412, RULE_kwFunctions);
        let mut _localctx: Rc<KwFunctionsContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2181);
			recog.base.match_token(K_FUNCTIONS,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwGrant ----------------
pub type KwGrantContextAll<'input> = KwGrantContext<'input>;


pub type KwGrantContext<'input> = BaseParserRuleContext<'input,KwGrantContextExt<'input>>;

#[derive(Clone)]
pub struct KwGrantContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwGrantContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwGrantContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwGrant(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwGrant(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwGrantContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwGrant(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwGrantContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwGrant }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwGrant }
}
antlr_rust::type_id!{KwGrantContextExt<'a>}

impl<'input> KwGrantContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwGrantContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwGrantContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwGrantContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwGrantContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_GRANT
/// Returns `None` if there is no child corresponding to token K_GRANT
fn K_GRANT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_GRANT, 0)
}

}

impl<'input> KwGrantContextAttrs<'input> for KwGrantContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwGrant(&mut self,)
	-> Result<Rc<KwGrantContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwGrantContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 414, RULE_kwGrant);
        let mut _localctx: Rc<KwGrantContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2183);
			recog.base.match_token(K_GRANT,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwIf ----------------
pub type KwIfContextAll<'input> = KwIfContext<'input>;


pub type KwIfContext<'input> = BaseParserRuleContext<'input,KwIfContextExt<'input>>;

#[derive(Clone)]
pub struct KwIfContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwIfContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwIfContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwIf(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwIf(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwIfContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwIf(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwIfContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwIf }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwIf }
}
antlr_rust::type_id!{KwIfContextExt<'a>}

impl<'input> KwIfContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwIfContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwIfContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwIfContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwIfContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_IF
/// Returns `None` if there is no child corresponding to token K_IF
fn K_IF(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_IF, 0)
}

}

impl<'input> KwIfContextAttrs<'input> for KwIfContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwIf(&mut self,)
	-> Result<Rc<KwIfContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwIfContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 416, RULE_kwIf);
        let mut _localctx: Rc<KwIfContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2185);
			recog.base.match_token(K_IF,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwIn ----------------
pub type KwInContextAll<'input> = KwInContext<'input>;


pub type KwInContext<'input> = BaseParserRuleContext<'input,KwInContextExt<'input>>;

#[derive(Clone)]
pub struct KwInContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwInContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwInContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwIn(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwIn(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwInContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwIn(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwInContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwIn }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwIn }
}
antlr_rust::type_id!{KwInContextExt<'a>}

impl<'input> KwInContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwInContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwInContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwInContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwInContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_IN
/// Returns `None` if there is no child corresponding to token K_IN
fn K_IN(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_IN, 0)
}

}

impl<'input> KwInContextAttrs<'input> for KwInContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwIn(&mut self,)
	-> Result<Rc<KwInContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwInContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 418, RULE_kwIn);
        let mut _localctx: Rc<KwInContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2187);
			recog.base.match_token(K_IN,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwIndex ----------------
pub type KwIndexContextAll<'input> = KwIndexContext<'input>;


pub type KwIndexContext<'input> = BaseParserRuleContext<'input,KwIndexContextExt<'input>>;

#[derive(Clone)]
pub struct KwIndexContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwIndexContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwIndexContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwIndex(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwIndex(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwIndexContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwIndex(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwIndexContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwIndex }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwIndex }
}
antlr_rust::type_id!{KwIndexContextExt<'a>}

impl<'input> KwIndexContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwIndexContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwIndexContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwIndexContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwIndexContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_INDEX
/// Returns `None` if there is no child corresponding to token K_INDEX
fn K_INDEX(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_INDEX, 0)
}

}

impl<'input> KwIndexContextAttrs<'input> for KwIndexContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwIndex(&mut self,)
	-> Result<Rc<KwIndexContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwIndexContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 420, RULE_kwIndex);
        let mut _localctx: Rc<KwIndexContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2189);
			recog.base.match_token(K_INDEX,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwInitcond ----------------
pub type KwInitcondContextAll<'input> = KwInitcondContext<'input>;


pub type KwInitcondContext<'input> = BaseParserRuleContext<'input,KwInitcondContextExt<'input>>;

#[derive(Clone)]
pub struct KwInitcondContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwInitcondContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwInitcondContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwInitcond(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwInitcond(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwInitcondContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwInitcond(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwInitcondContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwInitcond }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwInitcond }
}
antlr_rust::type_id!{KwInitcondContextExt<'a>}

impl<'input> KwInitcondContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwInitcondContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwInitcondContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwInitcondContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwInitcondContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_INITCOND
/// Returns `None` if there is no child corresponding to token K_INITCOND
fn K_INITCOND(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_INITCOND, 0)
}

}

impl<'input> KwInitcondContextAttrs<'input> for KwInitcondContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwInitcond(&mut self,)
	-> Result<Rc<KwInitcondContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwInitcondContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 422, RULE_kwInitcond);
        let mut _localctx: Rc<KwInitcondContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2191);
			recog.base.match_token(K_INITCOND,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwInput ----------------
pub type KwInputContextAll<'input> = KwInputContext<'input>;


pub type KwInputContext<'input> = BaseParserRuleContext<'input,KwInputContextExt<'input>>;

#[derive(Clone)]
pub struct KwInputContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwInputContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwInputContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwInput(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwInput(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwInputContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwInput(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwInputContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwInput }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwInput }
}
antlr_rust::type_id!{KwInputContextExt<'a>}

impl<'input> KwInputContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwInputContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwInputContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwInputContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwInputContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_INPUT
/// Returns `None` if there is no child corresponding to token K_INPUT
fn K_INPUT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_INPUT, 0)
}

}

impl<'input> KwInputContextAttrs<'input> for KwInputContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwInput(&mut self,)
	-> Result<Rc<KwInputContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwInputContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 424, RULE_kwInput);
        let mut _localctx: Rc<KwInputContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2193);
			recog.base.match_token(K_INPUT,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwInsert ----------------
pub type KwInsertContextAll<'input> = KwInsertContext<'input>;


pub type KwInsertContext<'input> = BaseParserRuleContext<'input,KwInsertContextExt<'input>>;

#[derive(Clone)]
pub struct KwInsertContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwInsertContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwInsertContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwInsert(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwInsert(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwInsertContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwInsert(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwInsertContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwInsert }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwInsert }
}
antlr_rust::type_id!{KwInsertContextExt<'a>}

impl<'input> KwInsertContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwInsertContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwInsertContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwInsertContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwInsertContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_INSERT
/// Returns `None` if there is no child corresponding to token K_INSERT
fn K_INSERT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_INSERT, 0)
}

}

impl<'input> KwInsertContextAttrs<'input> for KwInsertContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwInsert(&mut self,)
	-> Result<Rc<KwInsertContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwInsertContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 426, RULE_kwInsert);
        let mut _localctx: Rc<KwInsertContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2195);
			recog.base.match_token(K_INSERT,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwInto ----------------
pub type KwIntoContextAll<'input> = KwIntoContext<'input>;


pub type KwIntoContext<'input> = BaseParserRuleContext<'input,KwIntoContextExt<'input>>;

#[derive(Clone)]
pub struct KwIntoContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwIntoContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwIntoContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwInto(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwInto(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwIntoContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwInto(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwIntoContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwInto }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwInto }
}
antlr_rust::type_id!{KwIntoContextExt<'a>}

impl<'input> KwIntoContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwIntoContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwIntoContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwIntoContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwIntoContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_INTO
/// Returns `None` if there is no child corresponding to token K_INTO
fn K_INTO(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_INTO, 0)
}

}

impl<'input> KwIntoContextAttrs<'input> for KwIntoContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwInto(&mut self,)
	-> Result<Rc<KwIntoContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwIntoContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 428, RULE_kwInto);
        let mut _localctx: Rc<KwIntoContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2197);
			recog.base.match_token(K_INTO,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwIs ----------------
pub type KwIsContextAll<'input> = KwIsContext<'input>;


pub type KwIsContext<'input> = BaseParserRuleContext<'input,KwIsContextExt<'input>>;

#[derive(Clone)]
pub struct KwIsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwIsContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwIsContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwIs(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwIs(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwIsContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwIs(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwIsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwIs }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwIs }
}
antlr_rust::type_id!{KwIsContextExt<'a>}

impl<'input> KwIsContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwIsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwIsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwIsContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwIsContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_IS
/// Returns `None` if there is no child corresponding to token K_IS
fn K_IS(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_IS, 0)
}

}

impl<'input> KwIsContextAttrs<'input> for KwIsContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwIs(&mut self,)
	-> Result<Rc<KwIsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwIsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 430, RULE_kwIs);
        let mut _localctx: Rc<KwIsContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2199);
			recog.base.match_token(K_IS,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwJson ----------------
pub type KwJsonContextAll<'input> = KwJsonContext<'input>;


pub type KwJsonContext<'input> = BaseParserRuleContext<'input,KwJsonContextExt<'input>>;

#[derive(Clone)]
pub struct KwJsonContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwJsonContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwJsonContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwJson(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwJson(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwJsonContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwJson(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwJsonContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwJson }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwJson }
}
antlr_rust::type_id!{KwJsonContextExt<'a>}

impl<'input> KwJsonContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwJsonContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwJsonContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwJsonContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwJsonContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_JSON
/// Returns `None` if there is no child corresponding to token K_JSON
fn K_JSON(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_JSON, 0)
}

}

impl<'input> KwJsonContextAttrs<'input> for KwJsonContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwJson(&mut self,)
	-> Result<Rc<KwJsonContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwJsonContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 432, RULE_kwJson);
        let mut _localctx: Rc<KwJsonContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2201);
			recog.base.match_token(K_JSON,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwKey ----------------
pub type KwKeyContextAll<'input> = KwKeyContext<'input>;


pub type KwKeyContext<'input> = BaseParserRuleContext<'input,KwKeyContextExt<'input>>;

#[derive(Clone)]
pub struct KwKeyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwKeyContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwKeyContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwKey(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwKey(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwKeyContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwKey(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwKeyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwKey }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwKey }
}
antlr_rust::type_id!{KwKeyContextExt<'a>}

impl<'input> KwKeyContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwKeyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwKeyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwKeyContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwKeyContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_KEY
/// Returns `None` if there is no child corresponding to token K_KEY
fn K_KEY(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_KEY, 0)
}

}

impl<'input> KwKeyContextAttrs<'input> for KwKeyContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwKey(&mut self,)
	-> Result<Rc<KwKeyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwKeyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 434, RULE_kwKey);
        let mut _localctx: Rc<KwKeyContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2203);
			recog.base.match_token(K_KEY,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwKeys ----------------
pub type KwKeysContextAll<'input> = KwKeysContext<'input>;


pub type KwKeysContext<'input> = BaseParserRuleContext<'input,KwKeysContextExt<'input>>;

#[derive(Clone)]
pub struct KwKeysContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwKeysContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwKeysContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwKeys(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwKeys(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwKeysContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwKeys(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwKeysContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwKeys }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwKeys }
}
antlr_rust::type_id!{KwKeysContextExt<'a>}

impl<'input> KwKeysContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwKeysContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwKeysContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwKeysContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwKeysContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_KEYS
/// Returns `None` if there is no child corresponding to token K_KEYS
fn K_KEYS(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_KEYS, 0)
}

}

impl<'input> KwKeysContextAttrs<'input> for KwKeysContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwKeys(&mut self,)
	-> Result<Rc<KwKeysContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwKeysContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 436, RULE_kwKeys);
        let mut _localctx: Rc<KwKeysContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2205);
			recog.base.match_token(K_KEYS,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwKeyspace ----------------
pub type KwKeyspaceContextAll<'input> = KwKeyspaceContext<'input>;


pub type KwKeyspaceContext<'input> = BaseParserRuleContext<'input,KwKeyspaceContextExt<'input>>;

#[derive(Clone)]
pub struct KwKeyspaceContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwKeyspaceContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwKeyspaceContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwKeyspace(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwKeyspace(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwKeyspaceContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwKeyspace(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwKeyspaceContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwKeyspace }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwKeyspace }
}
antlr_rust::type_id!{KwKeyspaceContextExt<'a>}

impl<'input> KwKeyspaceContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwKeyspaceContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwKeyspaceContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwKeyspaceContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwKeyspaceContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_KEYSPACE
/// Returns `None` if there is no child corresponding to token K_KEYSPACE
fn K_KEYSPACE(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_KEYSPACE, 0)
}

}

impl<'input> KwKeyspaceContextAttrs<'input> for KwKeyspaceContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwKeyspace(&mut self,)
	-> Result<Rc<KwKeyspaceContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwKeyspaceContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 438, RULE_kwKeyspace);
        let mut _localctx: Rc<KwKeyspaceContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2207);
			recog.base.match_token(K_KEYSPACE,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwKeyspaces ----------------
pub type KwKeyspacesContextAll<'input> = KwKeyspacesContext<'input>;


pub type KwKeyspacesContext<'input> = BaseParserRuleContext<'input,KwKeyspacesContextExt<'input>>;

#[derive(Clone)]
pub struct KwKeyspacesContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwKeyspacesContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwKeyspacesContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwKeyspaces(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwKeyspaces(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwKeyspacesContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwKeyspaces(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwKeyspacesContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwKeyspaces }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwKeyspaces }
}
antlr_rust::type_id!{KwKeyspacesContextExt<'a>}

impl<'input> KwKeyspacesContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwKeyspacesContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwKeyspacesContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwKeyspacesContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwKeyspacesContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_KEYSPACES
/// Returns `None` if there is no child corresponding to token K_KEYSPACES
fn K_KEYSPACES(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_KEYSPACES, 0)
}

}

impl<'input> KwKeyspacesContextAttrs<'input> for KwKeyspacesContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwKeyspaces(&mut self,)
	-> Result<Rc<KwKeyspacesContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwKeyspacesContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 440, RULE_kwKeyspaces);
        let mut _localctx: Rc<KwKeyspacesContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2209);
			recog.base.match_token(K_KEYSPACES,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwLanguage ----------------
pub type KwLanguageContextAll<'input> = KwLanguageContext<'input>;


pub type KwLanguageContext<'input> = BaseParserRuleContext<'input,KwLanguageContextExt<'input>>;

#[derive(Clone)]
pub struct KwLanguageContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwLanguageContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwLanguageContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwLanguage(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwLanguage(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwLanguageContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwLanguage(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwLanguageContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwLanguage }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwLanguage }
}
antlr_rust::type_id!{KwLanguageContextExt<'a>}

impl<'input> KwLanguageContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwLanguageContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwLanguageContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwLanguageContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwLanguageContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_LANGUAGE
/// Returns `None` if there is no child corresponding to token K_LANGUAGE
fn K_LANGUAGE(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_LANGUAGE, 0)
}

}

impl<'input> KwLanguageContextAttrs<'input> for KwLanguageContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwLanguage(&mut self,)
	-> Result<Rc<KwLanguageContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwLanguageContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 442, RULE_kwLanguage);
        let mut _localctx: Rc<KwLanguageContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2211);
			recog.base.match_token(K_LANGUAGE,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwLimit ----------------
pub type KwLimitContextAll<'input> = KwLimitContext<'input>;


pub type KwLimitContext<'input> = BaseParserRuleContext<'input,KwLimitContextExt<'input>>;

#[derive(Clone)]
pub struct KwLimitContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwLimitContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwLimitContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwLimit(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwLimit(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwLimitContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwLimit(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwLimitContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwLimit }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwLimit }
}
antlr_rust::type_id!{KwLimitContextExt<'a>}

impl<'input> KwLimitContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwLimitContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwLimitContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwLimitContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwLimitContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_LIMIT
/// Returns `None` if there is no child corresponding to token K_LIMIT
fn K_LIMIT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_LIMIT, 0)
}

}

impl<'input> KwLimitContextAttrs<'input> for KwLimitContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwLimit(&mut self,)
	-> Result<Rc<KwLimitContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwLimitContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 444, RULE_kwLimit);
        let mut _localctx: Rc<KwLimitContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2213);
			recog.base.match_token(K_LIMIT,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwList ----------------
pub type KwListContextAll<'input> = KwListContext<'input>;


pub type KwListContext<'input> = BaseParserRuleContext<'input,KwListContextExt<'input>>;

#[derive(Clone)]
pub struct KwListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwListContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwListContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwList(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwList(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwListContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwList(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwList }
}
antlr_rust::type_id!{KwListContextExt<'a>}

impl<'input> KwListContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwListContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwListContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_LIST
/// Returns `None` if there is no child corresponding to token K_LIST
fn K_LIST(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_LIST, 0)
}

}

impl<'input> KwListContextAttrs<'input> for KwListContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwList(&mut self,)
	-> Result<Rc<KwListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 446, RULE_kwList);
        let mut _localctx: Rc<KwListContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2215);
			recog.base.match_token(K_LIST,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwLogged ----------------
pub type KwLoggedContextAll<'input> = KwLoggedContext<'input>;


pub type KwLoggedContext<'input> = BaseParserRuleContext<'input,KwLoggedContextExt<'input>>;

#[derive(Clone)]
pub struct KwLoggedContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwLoggedContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwLoggedContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwLogged(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwLogged(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwLoggedContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwLogged(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwLoggedContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwLogged }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwLogged }
}
antlr_rust::type_id!{KwLoggedContextExt<'a>}

impl<'input> KwLoggedContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwLoggedContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwLoggedContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwLoggedContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwLoggedContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_LOGGED
/// Returns `None` if there is no child corresponding to token K_LOGGED
fn K_LOGGED(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_LOGGED, 0)
}

}

impl<'input> KwLoggedContextAttrs<'input> for KwLoggedContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwLogged(&mut self,)
	-> Result<Rc<KwLoggedContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwLoggedContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 448, RULE_kwLogged);
        let mut _localctx: Rc<KwLoggedContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2217);
			recog.base.match_token(K_LOGGED,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwLogin ----------------
pub type KwLoginContextAll<'input> = KwLoginContext<'input>;


pub type KwLoginContext<'input> = BaseParserRuleContext<'input,KwLoginContextExt<'input>>;

#[derive(Clone)]
pub struct KwLoginContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwLoginContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwLoginContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwLogin(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwLogin(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwLoginContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwLogin(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwLoginContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwLogin }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwLogin }
}
antlr_rust::type_id!{KwLoginContextExt<'a>}

impl<'input> KwLoginContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwLoginContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwLoginContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwLoginContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwLoginContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_LOGIN
/// Returns `None` if there is no child corresponding to token K_LOGIN
fn K_LOGIN(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_LOGIN, 0)
}

}

impl<'input> KwLoginContextAttrs<'input> for KwLoginContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwLogin(&mut self,)
	-> Result<Rc<KwLoginContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwLoginContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 450, RULE_kwLogin);
        let mut _localctx: Rc<KwLoginContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2219);
			recog.base.match_token(K_LOGIN,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwMaterialized ----------------
pub type KwMaterializedContextAll<'input> = KwMaterializedContext<'input>;


pub type KwMaterializedContext<'input> = BaseParserRuleContext<'input,KwMaterializedContextExt<'input>>;

#[derive(Clone)]
pub struct KwMaterializedContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwMaterializedContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwMaterializedContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwMaterialized(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwMaterialized(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwMaterializedContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwMaterialized(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwMaterializedContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwMaterialized }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwMaterialized }
}
antlr_rust::type_id!{KwMaterializedContextExt<'a>}

impl<'input> KwMaterializedContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwMaterializedContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwMaterializedContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwMaterializedContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwMaterializedContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_MATERIALIZED
/// Returns `None` if there is no child corresponding to token K_MATERIALIZED
fn K_MATERIALIZED(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_MATERIALIZED, 0)
}

}

impl<'input> KwMaterializedContextAttrs<'input> for KwMaterializedContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwMaterialized(&mut self,)
	-> Result<Rc<KwMaterializedContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwMaterializedContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 452, RULE_kwMaterialized);
        let mut _localctx: Rc<KwMaterializedContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2221);
			recog.base.match_token(K_MATERIALIZED,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwModify ----------------
pub type KwModifyContextAll<'input> = KwModifyContext<'input>;


pub type KwModifyContext<'input> = BaseParserRuleContext<'input,KwModifyContextExt<'input>>;

#[derive(Clone)]
pub struct KwModifyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwModifyContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwModifyContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwModify(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwModify(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwModifyContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwModify(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwModifyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwModify }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwModify }
}
antlr_rust::type_id!{KwModifyContextExt<'a>}

impl<'input> KwModifyContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwModifyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwModifyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwModifyContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwModifyContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_MODIFY
/// Returns `None` if there is no child corresponding to token K_MODIFY
fn K_MODIFY(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_MODIFY, 0)
}

}

impl<'input> KwModifyContextAttrs<'input> for KwModifyContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwModify(&mut self,)
	-> Result<Rc<KwModifyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwModifyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 454, RULE_kwModify);
        let mut _localctx: Rc<KwModifyContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2223);
			recog.base.match_token(K_MODIFY,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwNosuperuser ----------------
pub type KwNosuperuserContextAll<'input> = KwNosuperuserContext<'input>;


pub type KwNosuperuserContext<'input> = BaseParserRuleContext<'input,KwNosuperuserContextExt<'input>>;

#[derive(Clone)]
pub struct KwNosuperuserContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwNosuperuserContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwNosuperuserContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwNosuperuser(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwNosuperuser(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwNosuperuserContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwNosuperuser(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwNosuperuserContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwNosuperuser }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwNosuperuser }
}
antlr_rust::type_id!{KwNosuperuserContextExt<'a>}

impl<'input> KwNosuperuserContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwNosuperuserContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwNosuperuserContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwNosuperuserContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwNosuperuserContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_NOSUPERUSER
/// Returns `None` if there is no child corresponding to token K_NOSUPERUSER
fn K_NOSUPERUSER(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_NOSUPERUSER, 0)
}

}

impl<'input> KwNosuperuserContextAttrs<'input> for KwNosuperuserContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwNosuperuser(&mut self,)
	-> Result<Rc<KwNosuperuserContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwNosuperuserContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 456, RULE_kwNosuperuser);
        let mut _localctx: Rc<KwNosuperuserContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2225);
			recog.base.match_token(K_NOSUPERUSER,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwNorecursive ----------------
pub type KwNorecursiveContextAll<'input> = KwNorecursiveContext<'input>;


pub type KwNorecursiveContext<'input> = BaseParserRuleContext<'input,KwNorecursiveContextExt<'input>>;

#[derive(Clone)]
pub struct KwNorecursiveContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwNorecursiveContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwNorecursiveContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwNorecursive(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwNorecursive(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwNorecursiveContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwNorecursive(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwNorecursiveContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwNorecursive }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwNorecursive }
}
antlr_rust::type_id!{KwNorecursiveContextExt<'a>}

impl<'input> KwNorecursiveContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwNorecursiveContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwNorecursiveContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwNorecursiveContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwNorecursiveContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_NORECURSIVE
/// Returns `None` if there is no child corresponding to token K_NORECURSIVE
fn K_NORECURSIVE(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_NORECURSIVE, 0)
}

}

impl<'input> KwNorecursiveContextAttrs<'input> for KwNorecursiveContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwNorecursive(&mut self,)
	-> Result<Rc<KwNorecursiveContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwNorecursiveContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 458, RULE_kwNorecursive);
        let mut _localctx: Rc<KwNorecursiveContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2227);
			recog.base.match_token(K_NORECURSIVE,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwNot ----------------
pub type KwNotContextAll<'input> = KwNotContext<'input>;


pub type KwNotContext<'input> = BaseParserRuleContext<'input,KwNotContextExt<'input>>;

#[derive(Clone)]
pub struct KwNotContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwNotContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwNotContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwNot(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwNot(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwNotContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwNot(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwNotContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwNot }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwNot }
}
antlr_rust::type_id!{KwNotContextExt<'a>}

impl<'input> KwNotContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwNotContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwNotContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwNotContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwNotContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_NOT
/// Returns `None` if there is no child corresponding to token K_NOT
fn K_NOT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_NOT, 0)
}

}

impl<'input> KwNotContextAttrs<'input> for KwNotContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwNot(&mut self,)
	-> Result<Rc<KwNotContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwNotContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 460, RULE_kwNot);
        let mut _localctx: Rc<KwNotContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2229);
			recog.base.match_token(K_NOT,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwNull ----------------
pub type KwNullContextAll<'input> = KwNullContext<'input>;


pub type KwNullContext<'input> = BaseParserRuleContext<'input,KwNullContextExt<'input>>;

#[derive(Clone)]
pub struct KwNullContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwNullContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwNullContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwNull(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwNull(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwNullContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwNull(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwNullContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwNull }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwNull }
}
antlr_rust::type_id!{KwNullContextExt<'a>}

impl<'input> KwNullContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwNullContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwNullContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwNullContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwNullContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_NULL
/// Returns `None` if there is no child corresponding to token K_NULL
fn K_NULL(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_NULL, 0)
}

}

impl<'input> KwNullContextAttrs<'input> for KwNullContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwNull(&mut self,)
	-> Result<Rc<KwNullContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwNullContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 462, RULE_kwNull);
        let mut _localctx: Rc<KwNullContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2231);
			recog.base.match_token(K_NULL,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwOf ----------------
pub type KwOfContextAll<'input> = KwOfContext<'input>;


pub type KwOfContext<'input> = BaseParserRuleContext<'input,KwOfContextExt<'input>>;

#[derive(Clone)]
pub struct KwOfContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwOfContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwOfContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwOf(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwOf(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwOfContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwOf(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwOfContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwOf }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwOf }
}
antlr_rust::type_id!{KwOfContextExt<'a>}

impl<'input> KwOfContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwOfContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwOfContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwOfContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwOfContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_OF
/// Returns `None` if there is no child corresponding to token K_OF
fn K_OF(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_OF, 0)
}

}

impl<'input> KwOfContextAttrs<'input> for KwOfContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwOf(&mut self,)
	-> Result<Rc<KwOfContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwOfContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 464, RULE_kwOf);
        let mut _localctx: Rc<KwOfContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2233);
			recog.base.match_token(K_OF,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwOn ----------------
pub type KwOnContextAll<'input> = KwOnContext<'input>;


pub type KwOnContext<'input> = BaseParserRuleContext<'input,KwOnContextExt<'input>>;

#[derive(Clone)]
pub struct KwOnContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwOnContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwOnContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwOn(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwOn(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwOnContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwOn(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwOnContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwOn }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwOn }
}
antlr_rust::type_id!{KwOnContextExt<'a>}

impl<'input> KwOnContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwOnContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwOnContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwOnContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwOnContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_ON
/// Returns `None` if there is no child corresponding to token K_ON
fn K_ON(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_ON, 0)
}

}

impl<'input> KwOnContextAttrs<'input> for KwOnContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwOn(&mut self,)
	-> Result<Rc<KwOnContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwOnContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 466, RULE_kwOn);
        let mut _localctx: Rc<KwOnContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2235);
			recog.base.match_token(K_ON,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwOptions ----------------
pub type KwOptionsContextAll<'input> = KwOptionsContext<'input>;


pub type KwOptionsContext<'input> = BaseParserRuleContext<'input,KwOptionsContextExt<'input>>;

#[derive(Clone)]
pub struct KwOptionsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwOptionsContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwOptionsContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwOptions(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwOptions(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwOptionsContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwOptions(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwOptionsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwOptions }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwOptions }
}
antlr_rust::type_id!{KwOptionsContextExt<'a>}

impl<'input> KwOptionsContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwOptionsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwOptionsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwOptionsContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwOptionsContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_OPTIONS
/// Returns `None` if there is no child corresponding to token K_OPTIONS
fn K_OPTIONS(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_OPTIONS, 0)
}

}

impl<'input> KwOptionsContextAttrs<'input> for KwOptionsContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwOptions(&mut self,)
	-> Result<Rc<KwOptionsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwOptionsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 468, RULE_kwOptions);
        let mut _localctx: Rc<KwOptionsContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2237);
			recog.base.match_token(K_OPTIONS,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwOr ----------------
pub type KwOrContextAll<'input> = KwOrContext<'input>;


pub type KwOrContext<'input> = BaseParserRuleContext<'input,KwOrContextExt<'input>>;

#[derive(Clone)]
pub struct KwOrContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwOrContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwOrContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwOr(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwOr(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwOrContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwOr(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwOrContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwOr }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwOr }
}
antlr_rust::type_id!{KwOrContextExt<'a>}

impl<'input> KwOrContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwOrContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwOrContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwOrContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwOrContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_OR
/// Returns `None` if there is no child corresponding to token K_OR
fn K_OR(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_OR, 0)
}

}

impl<'input> KwOrContextAttrs<'input> for KwOrContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwOr(&mut self,)
	-> Result<Rc<KwOrContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwOrContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 470, RULE_kwOr);
        let mut _localctx: Rc<KwOrContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2239);
			recog.base.match_token(K_OR,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwOrder ----------------
pub type KwOrderContextAll<'input> = KwOrderContext<'input>;


pub type KwOrderContext<'input> = BaseParserRuleContext<'input,KwOrderContextExt<'input>>;

#[derive(Clone)]
pub struct KwOrderContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwOrderContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwOrderContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwOrder(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwOrder(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwOrderContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwOrder(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwOrderContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwOrder }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwOrder }
}
antlr_rust::type_id!{KwOrderContextExt<'a>}

impl<'input> KwOrderContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwOrderContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwOrderContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwOrderContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwOrderContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_ORDER
/// Returns `None` if there is no child corresponding to token K_ORDER
fn K_ORDER(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_ORDER, 0)
}

}

impl<'input> KwOrderContextAttrs<'input> for KwOrderContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwOrder(&mut self,)
	-> Result<Rc<KwOrderContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwOrderContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 472, RULE_kwOrder);
        let mut _localctx: Rc<KwOrderContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2241);
			recog.base.match_token(K_ORDER,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwPassword ----------------
pub type KwPasswordContextAll<'input> = KwPasswordContext<'input>;


pub type KwPasswordContext<'input> = BaseParserRuleContext<'input,KwPasswordContextExt<'input>>;

#[derive(Clone)]
pub struct KwPasswordContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwPasswordContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwPasswordContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwPassword(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwPassword(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwPasswordContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwPassword(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwPasswordContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwPassword }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwPassword }
}
antlr_rust::type_id!{KwPasswordContextExt<'a>}

impl<'input> KwPasswordContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwPasswordContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwPasswordContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwPasswordContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwPasswordContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_PASSWORD
/// Returns `None` if there is no child corresponding to token K_PASSWORD
fn K_PASSWORD(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_PASSWORD, 0)
}

}

impl<'input> KwPasswordContextAttrs<'input> for KwPasswordContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwPassword(&mut self,)
	-> Result<Rc<KwPasswordContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwPasswordContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 474, RULE_kwPassword);
        let mut _localctx: Rc<KwPasswordContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2243);
			recog.base.match_token(K_PASSWORD,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwPrimary ----------------
pub type KwPrimaryContextAll<'input> = KwPrimaryContext<'input>;


pub type KwPrimaryContext<'input> = BaseParserRuleContext<'input,KwPrimaryContextExt<'input>>;

#[derive(Clone)]
pub struct KwPrimaryContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwPrimaryContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwPrimaryContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwPrimary(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwPrimary(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwPrimaryContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwPrimary(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwPrimaryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwPrimary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwPrimary }
}
antlr_rust::type_id!{KwPrimaryContextExt<'a>}

impl<'input> KwPrimaryContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwPrimaryContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwPrimaryContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwPrimaryContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwPrimaryContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_PRIMARY
/// Returns `None` if there is no child corresponding to token K_PRIMARY
fn K_PRIMARY(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_PRIMARY, 0)
}

}

impl<'input> KwPrimaryContextAttrs<'input> for KwPrimaryContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwPrimary(&mut self,)
	-> Result<Rc<KwPrimaryContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwPrimaryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 476, RULE_kwPrimary);
        let mut _localctx: Rc<KwPrimaryContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2245);
			recog.base.match_token(K_PRIMARY,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwRename ----------------
pub type KwRenameContextAll<'input> = KwRenameContext<'input>;


pub type KwRenameContext<'input> = BaseParserRuleContext<'input,KwRenameContextExt<'input>>;

#[derive(Clone)]
pub struct KwRenameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwRenameContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwRenameContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwRename(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwRename(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwRenameContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwRename(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwRenameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwRename }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwRename }
}
antlr_rust::type_id!{KwRenameContextExt<'a>}

impl<'input> KwRenameContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwRenameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwRenameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwRenameContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwRenameContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_RENAME
/// Returns `None` if there is no child corresponding to token K_RENAME
fn K_RENAME(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_RENAME, 0)
}

}

impl<'input> KwRenameContextAttrs<'input> for KwRenameContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwRename(&mut self,)
	-> Result<Rc<KwRenameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwRenameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 478, RULE_kwRename);
        let mut _localctx: Rc<KwRenameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2247);
			recog.base.match_token(K_RENAME,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwReplace ----------------
pub type KwReplaceContextAll<'input> = KwReplaceContext<'input>;


pub type KwReplaceContext<'input> = BaseParserRuleContext<'input,KwReplaceContextExt<'input>>;

#[derive(Clone)]
pub struct KwReplaceContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwReplaceContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwReplaceContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwReplace(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwReplace(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwReplaceContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwReplace(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwReplaceContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwReplace }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwReplace }
}
antlr_rust::type_id!{KwReplaceContextExt<'a>}

impl<'input> KwReplaceContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwReplaceContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwReplaceContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwReplaceContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwReplaceContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_REPLACE
/// Returns `None` if there is no child corresponding to token K_REPLACE
fn K_REPLACE(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_REPLACE, 0)
}

}

impl<'input> KwReplaceContextAttrs<'input> for KwReplaceContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwReplace(&mut self,)
	-> Result<Rc<KwReplaceContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwReplaceContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 480, RULE_kwReplace);
        let mut _localctx: Rc<KwReplaceContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2249);
			recog.base.match_token(K_REPLACE,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwReplication ----------------
pub type KwReplicationContextAll<'input> = KwReplicationContext<'input>;


pub type KwReplicationContext<'input> = BaseParserRuleContext<'input,KwReplicationContextExt<'input>>;

#[derive(Clone)]
pub struct KwReplicationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwReplicationContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwReplicationContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwReplication(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwReplication(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwReplicationContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwReplication(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwReplicationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwReplication }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwReplication }
}
antlr_rust::type_id!{KwReplicationContextExt<'a>}

impl<'input> KwReplicationContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwReplicationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwReplicationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwReplicationContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwReplicationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_REPLICATION
/// Returns `None` if there is no child corresponding to token K_REPLICATION
fn K_REPLICATION(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_REPLICATION, 0)
}

}

impl<'input> KwReplicationContextAttrs<'input> for KwReplicationContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwReplication(&mut self,)
	-> Result<Rc<KwReplicationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwReplicationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 482, RULE_kwReplication);
        let mut _localctx: Rc<KwReplicationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2251);
			recog.base.match_token(K_REPLICATION,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwReturns ----------------
pub type KwReturnsContextAll<'input> = KwReturnsContext<'input>;


pub type KwReturnsContext<'input> = BaseParserRuleContext<'input,KwReturnsContextExt<'input>>;

#[derive(Clone)]
pub struct KwReturnsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwReturnsContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwReturnsContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwReturns(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwReturns(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwReturnsContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwReturns(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwReturnsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwReturns }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwReturns }
}
antlr_rust::type_id!{KwReturnsContextExt<'a>}

impl<'input> KwReturnsContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwReturnsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwReturnsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwReturnsContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwReturnsContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_RETURNS
/// Returns `None` if there is no child corresponding to token K_RETURNS
fn K_RETURNS(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_RETURNS, 0)
}

}

impl<'input> KwReturnsContextAttrs<'input> for KwReturnsContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwReturns(&mut self,)
	-> Result<Rc<KwReturnsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwReturnsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 484, RULE_kwReturns);
        let mut _localctx: Rc<KwReturnsContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2253);
			recog.base.match_token(K_RETURNS,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwRole ----------------
pub type KwRoleContextAll<'input> = KwRoleContext<'input>;


pub type KwRoleContext<'input> = BaseParserRuleContext<'input,KwRoleContextExt<'input>>;

#[derive(Clone)]
pub struct KwRoleContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwRoleContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwRoleContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwRole(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwRole(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwRoleContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwRole(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwRoleContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwRole }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwRole }
}
antlr_rust::type_id!{KwRoleContextExt<'a>}

impl<'input> KwRoleContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwRoleContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwRoleContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwRoleContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwRoleContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_ROLE
/// Returns `None` if there is no child corresponding to token K_ROLE
fn K_ROLE(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_ROLE, 0)
}

}

impl<'input> KwRoleContextAttrs<'input> for KwRoleContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwRole(&mut self,)
	-> Result<Rc<KwRoleContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwRoleContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 486, RULE_kwRole);
        let mut _localctx: Rc<KwRoleContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2255);
			recog.base.match_token(K_ROLE,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwRoles ----------------
pub type KwRolesContextAll<'input> = KwRolesContext<'input>;


pub type KwRolesContext<'input> = BaseParserRuleContext<'input,KwRolesContextExt<'input>>;

#[derive(Clone)]
pub struct KwRolesContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwRolesContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwRolesContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwRoles(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwRoles(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwRolesContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwRoles(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwRolesContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwRoles }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwRoles }
}
antlr_rust::type_id!{KwRolesContextExt<'a>}

impl<'input> KwRolesContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwRolesContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwRolesContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwRolesContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwRolesContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_ROLES
/// Returns `None` if there is no child corresponding to token K_ROLES
fn K_ROLES(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_ROLES, 0)
}

}

impl<'input> KwRolesContextAttrs<'input> for KwRolesContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwRoles(&mut self,)
	-> Result<Rc<KwRolesContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwRolesContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 488, RULE_kwRoles);
        let mut _localctx: Rc<KwRolesContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2257);
			recog.base.match_token(K_ROLES,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwSelect ----------------
pub type KwSelectContextAll<'input> = KwSelectContext<'input>;


pub type KwSelectContext<'input> = BaseParserRuleContext<'input,KwSelectContextExt<'input>>;

#[derive(Clone)]
pub struct KwSelectContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwSelectContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwSelectContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwSelect(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwSelect(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwSelectContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwSelect(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwSelectContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwSelect }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwSelect }
}
antlr_rust::type_id!{KwSelectContextExt<'a>}

impl<'input> KwSelectContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwSelectContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwSelectContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwSelectContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwSelectContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_SELECT
/// Returns `None` if there is no child corresponding to token K_SELECT
fn K_SELECT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_SELECT, 0)
}

}

impl<'input> KwSelectContextAttrs<'input> for KwSelectContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwSelect(&mut self,)
	-> Result<Rc<KwSelectContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwSelectContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 490, RULE_kwSelect);
        let mut _localctx: Rc<KwSelectContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2259);
			recog.base.match_token(K_SELECT,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwSet ----------------
pub type KwSetContextAll<'input> = KwSetContext<'input>;


pub type KwSetContext<'input> = BaseParserRuleContext<'input,KwSetContextExt<'input>>;

#[derive(Clone)]
pub struct KwSetContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwSetContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwSetContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwSet(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwSet(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwSetContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwSet(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwSetContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwSet }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwSet }
}
antlr_rust::type_id!{KwSetContextExt<'a>}

impl<'input> KwSetContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwSetContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwSetContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwSetContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwSetContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_SET
/// Returns `None` if there is no child corresponding to token K_SET
fn K_SET(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_SET, 0)
}

}

impl<'input> KwSetContextAttrs<'input> for KwSetContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwSet(&mut self,)
	-> Result<Rc<KwSetContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwSetContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 492, RULE_kwSet);
        let mut _localctx: Rc<KwSetContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2261);
			recog.base.match_token(K_SET,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwSfunc ----------------
pub type KwSfuncContextAll<'input> = KwSfuncContext<'input>;


pub type KwSfuncContext<'input> = BaseParserRuleContext<'input,KwSfuncContextExt<'input>>;

#[derive(Clone)]
pub struct KwSfuncContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwSfuncContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwSfuncContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwSfunc(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwSfunc(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwSfuncContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwSfunc(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwSfuncContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwSfunc }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwSfunc }
}
antlr_rust::type_id!{KwSfuncContextExt<'a>}

impl<'input> KwSfuncContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwSfuncContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwSfuncContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwSfuncContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwSfuncContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_SFUNC
/// Returns `None` if there is no child corresponding to token K_SFUNC
fn K_SFUNC(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_SFUNC, 0)
}

}

impl<'input> KwSfuncContextAttrs<'input> for KwSfuncContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwSfunc(&mut self,)
	-> Result<Rc<KwSfuncContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwSfuncContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 494, RULE_kwSfunc);
        let mut _localctx: Rc<KwSfuncContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2263);
			recog.base.match_token(K_SFUNC,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwStorage ----------------
pub type KwStorageContextAll<'input> = KwStorageContext<'input>;


pub type KwStorageContext<'input> = BaseParserRuleContext<'input,KwStorageContextExt<'input>>;

#[derive(Clone)]
pub struct KwStorageContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwStorageContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwStorageContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwStorage(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwStorage(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwStorageContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwStorage(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwStorageContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwStorage }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwStorage }
}
antlr_rust::type_id!{KwStorageContextExt<'a>}

impl<'input> KwStorageContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwStorageContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwStorageContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwStorageContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwStorageContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_STORAGE
/// Returns `None` if there is no child corresponding to token K_STORAGE
fn K_STORAGE(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_STORAGE, 0)
}

}

impl<'input> KwStorageContextAttrs<'input> for KwStorageContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwStorage(&mut self,)
	-> Result<Rc<KwStorageContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwStorageContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 496, RULE_kwStorage);
        let mut _localctx: Rc<KwStorageContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2265);
			recog.base.match_token(K_STORAGE,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwStype ----------------
pub type KwStypeContextAll<'input> = KwStypeContext<'input>;


pub type KwStypeContext<'input> = BaseParserRuleContext<'input,KwStypeContextExt<'input>>;

#[derive(Clone)]
pub struct KwStypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwStypeContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwStypeContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwStype(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwStype(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwStypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwStype(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwStypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwStype }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwStype }
}
antlr_rust::type_id!{KwStypeContextExt<'a>}

impl<'input> KwStypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwStypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwStypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwStypeContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwStypeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_STYPE
/// Returns `None` if there is no child corresponding to token K_STYPE
fn K_STYPE(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_STYPE, 0)
}

}

impl<'input> KwStypeContextAttrs<'input> for KwStypeContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwStype(&mut self,)
	-> Result<Rc<KwStypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwStypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 498, RULE_kwStype);
        let mut _localctx: Rc<KwStypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2267);
			recog.base.match_token(K_STYPE,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwSuperuser ----------------
pub type KwSuperuserContextAll<'input> = KwSuperuserContext<'input>;


pub type KwSuperuserContext<'input> = BaseParserRuleContext<'input,KwSuperuserContextExt<'input>>;

#[derive(Clone)]
pub struct KwSuperuserContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwSuperuserContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwSuperuserContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwSuperuser(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwSuperuser(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwSuperuserContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwSuperuser(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwSuperuserContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwSuperuser }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwSuperuser }
}
antlr_rust::type_id!{KwSuperuserContextExt<'a>}

impl<'input> KwSuperuserContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwSuperuserContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwSuperuserContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwSuperuserContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwSuperuserContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_SUPERUSER
/// Returns `None` if there is no child corresponding to token K_SUPERUSER
fn K_SUPERUSER(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_SUPERUSER, 0)
}

}

impl<'input> KwSuperuserContextAttrs<'input> for KwSuperuserContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwSuperuser(&mut self,)
	-> Result<Rc<KwSuperuserContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwSuperuserContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 500, RULE_kwSuperuser);
        let mut _localctx: Rc<KwSuperuserContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2269);
			recog.base.match_token(K_SUPERUSER,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwTable ----------------
pub type KwTableContextAll<'input> = KwTableContext<'input>;


pub type KwTableContext<'input> = BaseParserRuleContext<'input,KwTableContextExt<'input>>;

#[derive(Clone)]
pub struct KwTableContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwTableContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwTableContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwTable(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwTable(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwTableContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwTable(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwTableContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwTable }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwTable }
}
antlr_rust::type_id!{KwTableContextExt<'a>}

impl<'input> KwTableContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwTableContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwTableContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwTableContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwTableContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_TABLE
/// Returns `None` if there is no child corresponding to token K_TABLE
fn K_TABLE(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_TABLE, 0)
}

}

impl<'input> KwTableContextAttrs<'input> for KwTableContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwTable(&mut self,)
	-> Result<Rc<KwTableContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwTableContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 502, RULE_kwTable);
        let mut _localctx: Rc<KwTableContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2271);
			recog.base.match_token(K_TABLE,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwTimestamp ----------------
pub type KwTimestampContextAll<'input> = KwTimestampContext<'input>;


pub type KwTimestampContext<'input> = BaseParserRuleContext<'input,KwTimestampContextExt<'input>>;

#[derive(Clone)]
pub struct KwTimestampContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwTimestampContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwTimestampContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwTimestamp(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwTimestamp(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwTimestampContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwTimestamp(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwTimestampContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwTimestamp }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwTimestamp }
}
antlr_rust::type_id!{KwTimestampContextExt<'a>}

impl<'input> KwTimestampContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwTimestampContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwTimestampContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwTimestampContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwTimestampContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_TIMESTAMP
/// Returns `None` if there is no child corresponding to token K_TIMESTAMP
fn K_TIMESTAMP(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_TIMESTAMP, 0)
}

}

impl<'input> KwTimestampContextAttrs<'input> for KwTimestampContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwTimestamp(&mut self,)
	-> Result<Rc<KwTimestampContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwTimestampContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 504, RULE_kwTimestamp);
        let mut _localctx: Rc<KwTimestampContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2273);
			recog.base.match_token(K_TIMESTAMP,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwTo ----------------
pub type KwToContextAll<'input> = KwToContext<'input>;


pub type KwToContext<'input> = BaseParserRuleContext<'input,KwToContextExt<'input>>;

#[derive(Clone)]
pub struct KwToContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwToContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwToContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwTo(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwTo(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwToContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwTo(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwToContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwTo }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwTo }
}
antlr_rust::type_id!{KwToContextExt<'a>}

impl<'input> KwToContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwToContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwToContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwToContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwToContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_TO
/// Returns `None` if there is no child corresponding to token K_TO
fn K_TO(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_TO, 0)
}

}

impl<'input> KwToContextAttrs<'input> for KwToContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwTo(&mut self,)
	-> Result<Rc<KwToContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwToContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 506, RULE_kwTo);
        let mut _localctx: Rc<KwToContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2275);
			recog.base.match_token(K_TO,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwTrigger ----------------
pub type KwTriggerContextAll<'input> = KwTriggerContext<'input>;


pub type KwTriggerContext<'input> = BaseParserRuleContext<'input,KwTriggerContextExt<'input>>;

#[derive(Clone)]
pub struct KwTriggerContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwTriggerContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwTriggerContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwTrigger(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwTrigger(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwTriggerContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwTrigger(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwTriggerContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwTrigger }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwTrigger }
}
antlr_rust::type_id!{KwTriggerContextExt<'a>}

impl<'input> KwTriggerContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwTriggerContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwTriggerContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwTriggerContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwTriggerContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_TRIGGER
/// Returns `None` if there is no child corresponding to token K_TRIGGER
fn K_TRIGGER(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_TRIGGER, 0)
}

}

impl<'input> KwTriggerContextAttrs<'input> for KwTriggerContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwTrigger(&mut self,)
	-> Result<Rc<KwTriggerContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwTriggerContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 508, RULE_kwTrigger);
        let mut _localctx: Rc<KwTriggerContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2277);
			recog.base.match_token(K_TRIGGER,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwTruncate ----------------
pub type KwTruncateContextAll<'input> = KwTruncateContext<'input>;


pub type KwTruncateContext<'input> = BaseParserRuleContext<'input,KwTruncateContextExt<'input>>;

#[derive(Clone)]
pub struct KwTruncateContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwTruncateContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwTruncateContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwTruncate(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwTruncate(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwTruncateContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwTruncate(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwTruncateContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwTruncate }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwTruncate }
}
antlr_rust::type_id!{KwTruncateContextExt<'a>}

impl<'input> KwTruncateContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwTruncateContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwTruncateContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwTruncateContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwTruncateContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_TRUNCATE
/// Returns `None` if there is no child corresponding to token K_TRUNCATE
fn K_TRUNCATE(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_TRUNCATE, 0)
}

}

impl<'input> KwTruncateContextAttrs<'input> for KwTruncateContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwTruncate(&mut self,)
	-> Result<Rc<KwTruncateContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwTruncateContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 510, RULE_kwTruncate);
        let mut _localctx: Rc<KwTruncateContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2279);
			recog.base.match_token(K_TRUNCATE,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwTtl ----------------
pub type KwTtlContextAll<'input> = KwTtlContext<'input>;


pub type KwTtlContext<'input> = BaseParserRuleContext<'input,KwTtlContextExt<'input>>;

#[derive(Clone)]
pub struct KwTtlContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwTtlContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwTtlContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwTtl(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwTtl(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwTtlContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwTtl(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwTtlContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwTtl }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwTtl }
}
antlr_rust::type_id!{KwTtlContextExt<'a>}

impl<'input> KwTtlContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwTtlContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwTtlContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwTtlContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwTtlContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_TTL
/// Returns `None` if there is no child corresponding to token K_TTL
fn K_TTL(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_TTL, 0)
}

}

impl<'input> KwTtlContextAttrs<'input> for KwTtlContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwTtl(&mut self,)
	-> Result<Rc<KwTtlContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwTtlContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 512, RULE_kwTtl);
        let mut _localctx: Rc<KwTtlContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2281);
			recog.base.match_token(K_TTL,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwType ----------------
pub type KwTypeContextAll<'input> = KwTypeContext<'input>;


pub type KwTypeContext<'input> = BaseParserRuleContext<'input,KwTypeContextExt<'input>>;

#[derive(Clone)]
pub struct KwTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwTypeContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwTypeContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwType(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwType(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwType(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwType }
}
antlr_rust::type_id!{KwTypeContextExt<'a>}

impl<'input> KwTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwTypeContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwTypeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_TYPE
/// Returns `None` if there is no child corresponding to token K_TYPE
fn K_TYPE(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_TYPE, 0)
}

}

impl<'input> KwTypeContextAttrs<'input> for KwTypeContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwType(&mut self,)
	-> Result<Rc<KwTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 514, RULE_kwType);
        let mut _localctx: Rc<KwTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2283);
			recog.base.match_token(K_TYPE,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwUnlogged ----------------
pub type KwUnloggedContextAll<'input> = KwUnloggedContext<'input>;


pub type KwUnloggedContext<'input> = BaseParserRuleContext<'input,KwUnloggedContextExt<'input>>;

#[derive(Clone)]
pub struct KwUnloggedContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwUnloggedContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwUnloggedContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwUnlogged(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwUnlogged(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwUnloggedContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwUnlogged(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwUnloggedContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwUnlogged }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwUnlogged }
}
antlr_rust::type_id!{KwUnloggedContextExt<'a>}

impl<'input> KwUnloggedContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwUnloggedContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwUnloggedContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwUnloggedContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwUnloggedContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_UNLOGGED
/// Returns `None` if there is no child corresponding to token K_UNLOGGED
fn K_UNLOGGED(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_UNLOGGED, 0)
}

}

impl<'input> KwUnloggedContextAttrs<'input> for KwUnloggedContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwUnlogged(&mut self,)
	-> Result<Rc<KwUnloggedContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwUnloggedContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 516, RULE_kwUnlogged);
        let mut _localctx: Rc<KwUnloggedContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2285);
			recog.base.match_token(K_UNLOGGED,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwUpdate ----------------
pub type KwUpdateContextAll<'input> = KwUpdateContext<'input>;


pub type KwUpdateContext<'input> = BaseParserRuleContext<'input,KwUpdateContextExt<'input>>;

#[derive(Clone)]
pub struct KwUpdateContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwUpdateContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwUpdateContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwUpdate(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwUpdate(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwUpdateContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwUpdate(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwUpdateContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwUpdate }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwUpdate }
}
antlr_rust::type_id!{KwUpdateContextExt<'a>}

impl<'input> KwUpdateContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwUpdateContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwUpdateContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwUpdateContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwUpdateContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_UPDATE
/// Returns `None` if there is no child corresponding to token K_UPDATE
fn K_UPDATE(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_UPDATE, 0)
}

}

impl<'input> KwUpdateContextAttrs<'input> for KwUpdateContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwUpdate(&mut self,)
	-> Result<Rc<KwUpdateContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwUpdateContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 518, RULE_kwUpdate);
        let mut _localctx: Rc<KwUpdateContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2287);
			recog.base.match_token(K_UPDATE,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwUse ----------------
pub type KwUseContextAll<'input> = KwUseContext<'input>;


pub type KwUseContext<'input> = BaseParserRuleContext<'input,KwUseContextExt<'input>>;

#[derive(Clone)]
pub struct KwUseContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwUseContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwUseContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwUse(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwUse(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwUseContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwUse(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwUseContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwUse }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwUse }
}
antlr_rust::type_id!{KwUseContextExt<'a>}

impl<'input> KwUseContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwUseContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwUseContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwUseContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwUseContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_USE
/// Returns `None` if there is no child corresponding to token K_USE
fn K_USE(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_USE, 0)
}

}

impl<'input> KwUseContextAttrs<'input> for KwUseContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwUse(&mut self,)
	-> Result<Rc<KwUseContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwUseContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 520, RULE_kwUse);
        let mut _localctx: Rc<KwUseContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2289);
			recog.base.match_token(K_USE,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwUser ----------------
pub type KwUserContextAll<'input> = KwUserContext<'input>;


pub type KwUserContext<'input> = BaseParserRuleContext<'input,KwUserContextExt<'input>>;

#[derive(Clone)]
pub struct KwUserContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwUserContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwUserContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwUser(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwUser(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwUserContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwUser(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwUserContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwUser }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwUser }
}
antlr_rust::type_id!{KwUserContextExt<'a>}

impl<'input> KwUserContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwUserContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwUserContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwUserContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwUserContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_USER
/// Returns `None` if there is no child corresponding to token K_USER
fn K_USER(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_USER, 0)
}

}

impl<'input> KwUserContextAttrs<'input> for KwUserContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwUser(&mut self,)
	-> Result<Rc<KwUserContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwUserContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 522, RULE_kwUser);
        let mut _localctx: Rc<KwUserContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2291);
			recog.base.match_token(K_USER,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwUsers ----------------
pub type KwUsersContextAll<'input> = KwUsersContext<'input>;


pub type KwUsersContext<'input> = BaseParserRuleContext<'input,KwUsersContextExt<'input>>;

#[derive(Clone)]
pub struct KwUsersContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwUsersContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwUsersContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwUsers(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwUsers(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwUsersContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwUsers(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwUsersContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwUsers }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwUsers }
}
antlr_rust::type_id!{KwUsersContextExt<'a>}

impl<'input> KwUsersContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwUsersContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwUsersContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwUsersContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwUsersContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_USERS
/// Returns `None` if there is no child corresponding to token K_USERS
fn K_USERS(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_USERS, 0)
}

}

impl<'input> KwUsersContextAttrs<'input> for KwUsersContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwUsers(&mut self,)
	-> Result<Rc<KwUsersContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwUsersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 524, RULE_kwUsers);
        let mut _localctx: Rc<KwUsersContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2293);
			recog.base.match_token(K_USERS,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwUsing ----------------
pub type KwUsingContextAll<'input> = KwUsingContext<'input>;


pub type KwUsingContext<'input> = BaseParserRuleContext<'input,KwUsingContextExt<'input>>;

#[derive(Clone)]
pub struct KwUsingContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwUsingContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwUsingContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwUsing(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwUsing(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwUsingContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwUsing(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwUsingContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwUsing }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwUsing }
}
antlr_rust::type_id!{KwUsingContextExt<'a>}

impl<'input> KwUsingContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwUsingContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwUsingContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwUsingContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwUsingContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_USING
/// Returns `None` if there is no child corresponding to token K_USING
fn K_USING(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_USING, 0)
}

}

impl<'input> KwUsingContextAttrs<'input> for KwUsingContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwUsing(&mut self,)
	-> Result<Rc<KwUsingContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwUsingContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 526, RULE_kwUsing);
        let mut _localctx: Rc<KwUsingContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2295);
			recog.base.match_token(K_USING,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwValues ----------------
pub type KwValuesContextAll<'input> = KwValuesContext<'input>;


pub type KwValuesContext<'input> = BaseParserRuleContext<'input,KwValuesContextExt<'input>>;

#[derive(Clone)]
pub struct KwValuesContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwValuesContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwValuesContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwValues(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwValues(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwValuesContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwValues(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwValuesContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwValues }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwValues }
}
antlr_rust::type_id!{KwValuesContextExt<'a>}

impl<'input> KwValuesContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwValuesContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwValuesContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwValuesContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwValuesContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_VALUES
/// Returns `None` if there is no child corresponding to token K_VALUES
fn K_VALUES(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_VALUES, 0)
}

}

impl<'input> KwValuesContextAttrs<'input> for KwValuesContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwValues(&mut self,)
	-> Result<Rc<KwValuesContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwValuesContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 528, RULE_kwValues);
        let mut _localctx: Rc<KwValuesContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2297);
			recog.base.match_token(K_VALUES,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwView ----------------
pub type KwViewContextAll<'input> = KwViewContext<'input>;


pub type KwViewContext<'input> = BaseParserRuleContext<'input,KwViewContextExt<'input>>;

#[derive(Clone)]
pub struct KwViewContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwViewContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwViewContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwView(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwView(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwViewContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwView(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwViewContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwView }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwView }
}
antlr_rust::type_id!{KwViewContextExt<'a>}

impl<'input> KwViewContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwViewContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwViewContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwViewContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwViewContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_VIEW
/// Returns `None` if there is no child corresponding to token K_VIEW
fn K_VIEW(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_VIEW, 0)
}

}

impl<'input> KwViewContextAttrs<'input> for KwViewContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwView(&mut self,)
	-> Result<Rc<KwViewContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwViewContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 530, RULE_kwView);
        let mut _localctx: Rc<KwViewContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2299);
			recog.base.match_token(K_VIEW,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwWhere ----------------
pub type KwWhereContextAll<'input> = KwWhereContext<'input>;


pub type KwWhereContext<'input> = BaseParserRuleContext<'input,KwWhereContextExt<'input>>;

#[derive(Clone)]
pub struct KwWhereContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwWhereContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwWhereContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwWhere(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwWhere(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwWhereContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwWhere(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwWhereContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwWhere }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwWhere }
}
antlr_rust::type_id!{KwWhereContextExt<'a>}

impl<'input> KwWhereContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwWhereContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwWhereContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwWhereContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwWhereContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_WHERE
/// Returns `None` if there is no child corresponding to token K_WHERE
fn K_WHERE(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_WHERE, 0)
}

}

impl<'input> KwWhereContextAttrs<'input> for KwWhereContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwWhere(&mut self,)
	-> Result<Rc<KwWhereContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwWhereContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 532, RULE_kwWhere);
        let mut _localctx: Rc<KwWhereContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2301);
			recog.base.match_token(K_WHERE,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwWith ----------------
pub type KwWithContextAll<'input> = KwWithContext<'input>;


pub type KwWithContext<'input> = BaseParserRuleContext<'input,KwWithContextExt<'input>>;

#[derive(Clone)]
pub struct KwWithContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwWithContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwWithContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwWith(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwWith(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwWithContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwWith(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwWithContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwWith }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwWith }
}
antlr_rust::type_id!{KwWithContextExt<'a>}

impl<'input> KwWithContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwWithContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwWithContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwWithContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwWithContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_WITH
/// Returns `None` if there is no child corresponding to token K_WITH
fn K_WITH(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_WITH, 0)
}

}

impl<'input> KwWithContextAttrs<'input> for KwWithContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwWith(&mut self,)
	-> Result<Rc<KwWithContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwWithContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 534, RULE_kwWith);
        let mut _localctx: Rc<KwWithContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2303);
			recog.base.match_token(K_WITH,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- kwRevoke ----------------
pub type KwRevokeContextAll<'input> = KwRevokeContext<'input>;


pub type KwRevokeContext<'input> = BaseParserRuleContext<'input,KwRevokeContextExt<'input>>;

#[derive(Clone)]
pub struct KwRevokeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for KwRevokeContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for KwRevokeContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kwRevoke(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_kwRevoke(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for KwRevokeContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_kwRevoke(self);
	}
}

impl<'input> CustomRuleContext<'input> for KwRevokeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kwRevoke }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kwRevoke }
}
antlr_rust::type_id!{KwRevokeContextExt<'a>}

impl<'input> KwRevokeContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KwRevokeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KwRevokeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KwRevokeContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<KwRevokeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token K_REVOKE
/// Returns `None` if there is no child corresponding to token K_REVOKE
fn K_REVOKE(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(K_REVOKE, 0)
}

}

impl<'input> KwRevokeContextAttrs<'input> for KwRevokeContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kwRevoke(&mut self,)
	-> Result<Rc<KwRevokeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KwRevokeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 536, RULE_kwRevoke);
        let mut _localctx: Rc<KwRevokeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2305);
			recog.base.match_token(K_REVOKE,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- eof ----------------
pub type EofContextAll<'input> = EofContext<'input>;


pub type EofContext<'input> = BaseParserRuleContext<'input,EofContextExt<'input>>;

#[derive(Clone)]
pub struct EofContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for EofContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for EofContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_eof(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_eof(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for EofContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_eof(self);
	}
}

impl<'input> CustomRuleContext<'input> for EofContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_eof }
	//fn type_rule_index() -> usize where Self: Sized { RULE_eof }
}
antlr_rust::type_id!{EofContextExt<'a>}

impl<'input> EofContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EofContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EofContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EofContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<EofContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token EOF
/// Returns `None` if there is no child corresponding to token EOF
fn EOF(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(EOF, 0)
}

}

impl<'input> EofContextAttrs<'input> for EofContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn eof(&mut self,)
	-> Result<Rc<EofContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EofContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 538, RULE_eof);
        let mut _localctx: Rc<EofContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2307);
			recog.base.match_token(EOF,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- syntaxBracketLr ----------------
pub type SyntaxBracketLrContextAll<'input> = SyntaxBracketLrContext<'input>;


pub type SyntaxBracketLrContext<'input> = BaseParserRuleContext<'input,SyntaxBracketLrContextExt<'input>>;

#[derive(Clone)]
pub struct SyntaxBracketLrContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for SyntaxBracketLrContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for SyntaxBracketLrContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_syntaxBracketLr(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_syntaxBracketLr(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for SyntaxBracketLrContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_syntaxBracketLr(self);
	}
}

impl<'input> CustomRuleContext<'input> for SyntaxBracketLrContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_syntaxBracketLr }
	//fn type_rule_index() -> usize where Self: Sized { RULE_syntaxBracketLr }
}
antlr_rust::type_id!{SyntaxBracketLrContextExt<'a>}

impl<'input> SyntaxBracketLrContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SyntaxBracketLrContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SyntaxBracketLrContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SyntaxBracketLrContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<SyntaxBracketLrContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LR_BRACKET
/// Returns `None` if there is no child corresponding to token LR_BRACKET
fn LR_BRACKET(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(LR_BRACKET, 0)
}

}

impl<'input> SyntaxBracketLrContextAttrs<'input> for SyntaxBracketLrContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn syntaxBracketLr(&mut self,)
	-> Result<Rc<SyntaxBracketLrContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SyntaxBracketLrContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 540, RULE_syntaxBracketLr);
        let mut _localctx: Rc<SyntaxBracketLrContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2309);
			recog.base.match_token(LR_BRACKET,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- syntaxBracketRr ----------------
pub type SyntaxBracketRrContextAll<'input> = SyntaxBracketRrContext<'input>;


pub type SyntaxBracketRrContext<'input> = BaseParserRuleContext<'input,SyntaxBracketRrContextExt<'input>>;

#[derive(Clone)]
pub struct SyntaxBracketRrContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for SyntaxBracketRrContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for SyntaxBracketRrContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_syntaxBracketRr(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_syntaxBracketRr(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for SyntaxBracketRrContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_syntaxBracketRr(self);
	}
}

impl<'input> CustomRuleContext<'input> for SyntaxBracketRrContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_syntaxBracketRr }
	//fn type_rule_index() -> usize where Self: Sized { RULE_syntaxBracketRr }
}
antlr_rust::type_id!{SyntaxBracketRrContextExt<'a>}

impl<'input> SyntaxBracketRrContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SyntaxBracketRrContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SyntaxBracketRrContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SyntaxBracketRrContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<SyntaxBracketRrContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token RR_BRACKET
/// Returns `None` if there is no child corresponding to token RR_BRACKET
fn RR_BRACKET(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(RR_BRACKET, 0)
}

}

impl<'input> SyntaxBracketRrContextAttrs<'input> for SyntaxBracketRrContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn syntaxBracketRr(&mut self,)
	-> Result<Rc<SyntaxBracketRrContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SyntaxBracketRrContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 542, RULE_syntaxBracketRr);
        let mut _localctx: Rc<SyntaxBracketRrContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2311);
			recog.base.match_token(RR_BRACKET,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- syntaxBracketLc ----------------
pub type SyntaxBracketLcContextAll<'input> = SyntaxBracketLcContext<'input>;


pub type SyntaxBracketLcContext<'input> = BaseParserRuleContext<'input,SyntaxBracketLcContextExt<'input>>;

#[derive(Clone)]
pub struct SyntaxBracketLcContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for SyntaxBracketLcContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for SyntaxBracketLcContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_syntaxBracketLc(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_syntaxBracketLc(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for SyntaxBracketLcContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_syntaxBracketLc(self);
	}
}

impl<'input> CustomRuleContext<'input> for SyntaxBracketLcContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_syntaxBracketLc }
	//fn type_rule_index() -> usize where Self: Sized { RULE_syntaxBracketLc }
}
antlr_rust::type_id!{SyntaxBracketLcContextExt<'a>}

impl<'input> SyntaxBracketLcContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SyntaxBracketLcContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SyntaxBracketLcContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SyntaxBracketLcContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<SyntaxBracketLcContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LC_BRACKET
/// Returns `None` if there is no child corresponding to token LC_BRACKET
fn LC_BRACKET(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(LC_BRACKET, 0)
}

}

impl<'input> SyntaxBracketLcContextAttrs<'input> for SyntaxBracketLcContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn syntaxBracketLc(&mut self,)
	-> Result<Rc<SyntaxBracketLcContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SyntaxBracketLcContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 544, RULE_syntaxBracketLc);
        let mut _localctx: Rc<SyntaxBracketLcContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2313);
			recog.base.match_token(LC_BRACKET,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- syntaxBracketRc ----------------
pub type SyntaxBracketRcContextAll<'input> = SyntaxBracketRcContext<'input>;


pub type SyntaxBracketRcContext<'input> = BaseParserRuleContext<'input,SyntaxBracketRcContextExt<'input>>;

#[derive(Clone)]
pub struct SyntaxBracketRcContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for SyntaxBracketRcContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for SyntaxBracketRcContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_syntaxBracketRc(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_syntaxBracketRc(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for SyntaxBracketRcContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_syntaxBracketRc(self);
	}
}

impl<'input> CustomRuleContext<'input> for SyntaxBracketRcContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_syntaxBracketRc }
	//fn type_rule_index() -> usize where Self: Sized { RULE_syntaxBracketRc }
}
antlr_rust::type_id!{SyntaxBracketRcContextExt<'a>}

impl<'input> SyntaxBracketRcContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SyntaxBracketRcContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SyntaxBracketRcContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SyntaxBracketRcContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<SyntaxBracketRcContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token RC_BRACKET
/// Returns `None` if there is no child corresponding to token RC_BRACKET
fn RC_BRACKET(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(RC_BRACKET, 0)
}

}

impl<'input> SyntaxBracketRcContextAttrs<'input> for SyntaxBracketRcContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn syntaxBracketRc(&mut self,)
	-> Result<Rc<SyntaxBracketRcContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SyntaxBracketRcContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 546, RULE_syntaxBracketRc);
        let mut _localctx: Rc<SyntaxBracketRcContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2315);
			recog.base.match_token(RC_BRACKET,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- syntaxBracketLa ----------------
pub type SyntaxBracketLaContextAll<'input> = SyntaxBracketLaContext<'input>;


pub type SyntaxBracketLaContext<'input> = BaseParserRuleContext<'input,SyntaxBracketLaContextExt<'input>>;

#[derive(Clone)]
pub struct SyntaxBracketLaContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for SyntaxBracketLaContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for SyntaxBracketLaContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_syntaxBracketLa(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_syntaxBracketLa(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for SyntaxBracketLaContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_syntaxBracketLa(self);
	}
}

impl<'input> CustomRuleContext<'input> for SyntaxBracketLaContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_syntaxBracketLa }
	//fn type_rule_index() -> usize where Self: Sized { RULE_syntaxBracketLa }
}
antlr_rust::type_id!{SyntaxBracketLaContextExt<'a>}

impl<'input> SyntaxBracketLaContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SyntaxBracketLaContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SyntaxBracketLaContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SyntaxBracketLaContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<SyntaxBracketLaContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OPERATOR_LT
/// Returns `None` if there is no child corresponding to token OPERATOR_LT
fn OPERATOR_LT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OPERATOR_LT, 0)
}

}

impl<'input> SyntaxBracketLaContextAttrs<'input> for SyntaxBracketLaContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn syntaxBracketLa(&mut self,)
	-> Result<Rc<SyntaxBracketLaContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SyntaxBracketLaContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 548, RULE_syntaxBracketLa);
        let mut _localctx: Rc<SyntaxBracketLaContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2317);
			recog.base.match_token(OPERATOR_LT,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- syntaxBracketRa ----------------
pub type SyntaxBracketRaContextAll<'input> = SyntaxBracketRaContext<'input>;


pub type SyntaxBracketRaContext<'input> = BaseParserRuleContext<'input,SyntaxBracketRaContextExt<'input>>;

#[derive(Clone)]
pub struct SyntaxBracketRaContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for SyntaxBracketRaContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for SyntaxBracketRaContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_syntaxBracketRa(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_syntaxBracketRa(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for SyntaxBracketRaContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_syntaxBracketRa(self);
	}
}

impl<'input> CustomRuleContext<'input> for SyntaxBracketRaContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_syntaxBracketRa }
	//fn type_rule_index() -> usize where Self: Sized { RULE_syntaxBracketRa }
}
antlr_rust::type_id!{SyntaxBracketRaContextExt<'a>}

impl<'input> SyntaxBracketRaContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SyntaxBracketRaContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SyntaxBracketRaContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SyntaxBracketRaContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<SyntaxBracketRaContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OPERATOR_GT
/// Returns `None` if there is no child corresponding to token OPERATOR_GT
fn OPERATOR_GT(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(OPERATOR_GT, 0)
}

}

impl<'input> SyntaxBracketRaContextAttrs<'input> for SyntaxBracketRaContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn syntaxBracketRa(&mut self,)
	-> Result<Rc<SyntaxBracketRaContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SyntaxBracketRaContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 550, RULE_syntaxBracketRa);
        let mut _localctx: Rc<SyntaxBracketRaContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2319);
			recog.base.match_token(OPERATOR_GT,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- syntaxBracketLs ----------------
pub type SyntaxBracketLsContextAll<'input> = SyntaxBracketLsContext<'input>;


pub type SyntaxBracketLsContext<'input> = BaseParserRuleContext<'input,SyntaxBracketLsContextExt<'input>>;

#[derive(Clone)]
pub struct SyntaxBracketLsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for SyntaxBracketLsContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for SyntaxBracketLsContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_syntaxBracketLs(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_syntaxBracketLs(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for SyntaxBracketLsContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_syntaxBracketLs(self);
	}
}

impl<'input> CustomRuleContext<'input> for SyntaxBracketLsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_syntaxBracketLs }
	//fn type_rule_index() -> usize where Self: Sized { RULE_syntaxBracketLs }
}
antlr_rust::type_id!{SyntaxBracketLsContextExt<'a>}

impl<'input> SyntaxBracketLsContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SyntaxBracketLsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SyntaxBracketLsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SyntaxBracketLsContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<SyntaxBracketLsContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LS_BRACKET
/// Returns `None` if there is no child corresponding to token LS_BRACKET
fn LS_BRACKET(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(LS_BRACKET, 0)
}

}

impl<'input> SyntaxBracketLsContextAttrs<'input> for SyntaxBracketLsContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn syntaxBracketLs(&mut self,)
	-> Result<Rc<SyntaxBracketLsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SyntaxBracketLsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 552, RULE_syntaxBracketLs);
        let mut _localctx: Rc<SyntaxBracketLsContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2321);
			recog.base.match_token(LS_BRACKET,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- syntaxBracketRs ----------------
pub type SyntaxBracketRsContextAll<'input> = SyntaxBracketRsContext<'input>;


pub type SyntaxBracketRsContext<'input> = BaseParserRuleContext<'input,SyntaxBracketRsContextExt<'input>>;

#[derive(Clone)]
pub struct SyntaxBracketRsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for SyntaxBracketRsContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for SyntaxBracketRsContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_syntaxBracketRs(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_syntaxBracketRs(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for SyntaxBracketRsContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_syntaxBracketRs(self);
	}
}

impl<'input> CustomRuleContext<'input> for SyntaxBracketRsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_syntaxBracketRs }
	//fn type_rule_index() -> usize where Self: Sized { RULE_syntaxBracketRs }
}
antlr_rust::type_id!{SyntaxBracketRsContextExt<'a>}

impl<'input> SyntaxBracketRsContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SyntaxBracketRsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SyntaxBracketRsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SyntaxBracketRsContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<SyntaxBracketRsContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token RS_BRACKET
/// Returns `None` if there is no child corresponding to token RS_BRACKET
fn RS_BRACKET(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(RS_BRACKET, 0)
}

}

impl<'input> SyntaxBracketRsContextAttrs<'input> for SyntaxBracketRsContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn syntaxBracketRs(&mut self,)
	-> Result<Rc<SyntaxBracketRsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SyntaxBracketRsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 554, RULE_syntaxBracketRs);
        let mut _localctx: Rc<SyntaxBracketRsContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2323);
			recog.base.match_token(RS_BRACKET,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- syntaxComma ----------------
pub type SyntaxCommaContextAll<'input> = SyntaxCommaContext<'input>;


pub type SyntaxCommaContext<'input> = BaseParserRuleContext<'input,SyntaxCommaContextExt<'input>>;

#[derive(Clone)]
pub struct SyntaxCommaContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for SyntaxCommaContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for SyntaxCommaContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_syntaxComma(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_syntaxComma(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for SyntaxCommaContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_syntaxComma(self);
	}
}

impl<'input> CustomRuleContext<'input> for SyntaxCommaContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_syntaxComma }
	//fn type_rule_index() -> usize where Self: Sized { RULE_syntaxComma }
}
antlr_rust::type_id!{SyntaxCommaContextExt<'a>}

impl<'input> SyntaxCommaContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SyntaxCommaContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SyntaxCommaContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SyntaxCommaContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<SyntaxCommaContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}

}

impl<'input> SyntaxCommaContextAttrs<'input> for SyntaxCommaContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn syntaxComma(&mut self,)
	-> Result<Rc<SyntaxCommaContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SyntaxCommaContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 556, RULE_syntaxComma);
        let mut _localctx: Rc<SyntaxCommaContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2325);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- syntaxColon ----------------
pub type SyntaxColonContextAll<'input> = SyntaxColonContext<'input>;


pub type SyntaxColonContext<'input> = BaseParserRuleContext<'input,SyntaxColonContextExt<'input>>;

#[derive(Clone)]
pub struct SyntaxColonContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CqlParserContext<'input> for SyntaxColonContext<'input>{}

impl<'input,'a> Listenable<dyn CqlParserListener<'input> + 'a> for SyntaxColonContext<'input>{
	fn enter(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_syntaxColon(self);
	}
	fn exit(&self,listener: &mut (dyn CqlParserListener<'input> + 'a)) {
		listener.exit_syntaxColon(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn CqlParserVisitor<'input> + 'a> for SyntaxColonContext<'input>{
	fn accept(&self,visitor: &mut (dyn CqlParserVisitor<'input> + 'a)) {
		visitor.visit_syntaxColon(self);
	}
}

impl<'input> CustomRuleContext<'input> for SyntaxColonContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CqlParserContextType;
	fn get_rule_index(&self) -> usize { RULE_syntaxColon }
	//fn type_rule_index() -> usize where Self: Sized { RULE_syntaxColon }
}
antlr_rust::type_id!{SyntaxColonContextExt<'a>}

impl<'input> SyntaxColonContextExt<'input>{
	fn new(parent: Option<Rc<dyn CqlParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SyntaxColonContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SyntaxColonContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SyntaxColonContextAttrs<'input>: CqlParserContext<'input> + BorrowMut<SyntaxColonContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,CqlParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}

}

impl<'input> SyntaxColonContextAttrs<'input> for SyntaxColonContext<'input>{}

impl<'input, I, H> CqlParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn syntaxColon(&mut self,)
	-> Result<Rc<SyntaxColonContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SyntaxColonContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 558, RULE_syntaxColon);
        let mut _localctx: Rc<SyntaxColonContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2327);
			recog.base.match_token(COLON,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}

lazy_static! {
    static ref _ATN: Arc<ATN> =
        Arc::new(ATNDeserializer::new(None).deserialize(_serializedATN.chars()));
    static ref _decision_to_DFA: Arc<Vec<antlr_rust::RwLock<DFA>>> = {
        let mut dfa = Vec::new();
        let size = _ATN.decision_to_state.len();
        for i in 0..size {
            dfa.push(DFA::new(
                _ATN.clone(),
                _ATN.get_decision_state(i),
                i as isize,
            ).into())
        }
        Arc::new(dfa)
    };
}



const _serializedATN:&'static str =
	"\x03\u{608b}\u{a72a}\u{8133}\u{b9ed}\u{417c}\u{3be7}\u{7786}\u{5964}\x03\
	\u{b2}\u{91c}\x04\x02\x09\x02\x04\x03\x09\x03\x04\x04\x09\x04\x04\x05\x09\
	\x05\x04\x06\x09\x06\x04\x07\x09\x07\x04\x08\x09\x08\x04\x09\x09\x09\x04\
	\x0a\x09\x0a\x04\x0b\x09\x0b\x04\x0c\x09\x0c\x04\x0d\x09\x0d\x04\x0e\x09\
	\x0e\x04\x0f\x09\x0f\x04\x10\x09\x10\x04\x11\x09\x11\x04\x12\x09\x12\x04\
	\x13\x09\x13\x04\x14\x09\x14\x04\x15\x09\x15\x04\x16\x09\x16\x04\x17\x09\
	\x17\x04\x18\x09\x18\x04\x19\x09\x19\x04\x1a\x09\x1a\x04\x1b\x09\x1b\x04\
	\x1c\x09\x1c\x04\x1d\x09\x1d\x04\x1e\x09\x1e\x04\x1f\x09\x1f\x04\x20\x09\
	\x20\x04\x21\x09\x21\x04\x22\x09\x22\x04\x23\x09\x23\x04\x24\x09\x24\x04\
	\x25\x09\x25\x04\x26\x09\x26\x04\x27\x09\x27\x04\x28\x09\x28\x04\x29\x09\
	\x29\x04\x2a\x09\x2a\x04\x2b\x09\x2b\x04\x2c\x09\x2c\x04\x2d\x09\x2d\x04\
	\x2e\x09\x2e\x04\x2f\x09\x2f\x04\x30\x09\x30\x04\x31\x09\x31\x04\x32\x09\
	\x32\x04\x33\x09\x33\x04\x34\x09\x34\x04\x35\x09\x35\x04\x36\x09\x36\x04\
	\x37\x09\x37\x04\x38\x09\x38\x04\x39\x09\x39\x04\x3a\x09\x3a\x04\x3b\x09\
	\x3b\x04\x3c\x09\x3c\x04\x3d\x09\x3d\x04\x3e\x09\x3e\x04\x3f\x09\x3f\x04\
	\x40\x09\x40\x04\x41\x09\x41\x04\x42\x09\x42\x04\x43\x09\x43\x04\x44\x09\
	\x44\x04\x45\x09\x45\x04\x46\x09\x46\x04\x47\x09\x47\x04\x48\x09\x48\x04\
	\x49\x09\x49\x04\x4a\x09\x4a\x04\x4b\x09\x4b\x04\x4c\x09\x4c\x04\x4d\x09\
	\x4d\x04\x4e\x09\x4e\x04\x4f\x09\x4f\x04\x50\x09\x50\x04\x51\x09\x51\x04\
	\x52\x09\x52\x04\x53\x09\x53\x04\x54\x09\x54\x04\x55\x09\x55\x04\x56\x09\
	\x56\x04\x57\x09\x57\x04\x58\x09\x58\x04\x59\x09\x59\x04\x5a\x09\x5a\x04\
	\x5b\x09\x5b\x04\x5c\x09\x5c\x04\x5d\x09\x5d\x04\x5e\x09\x5e\x04\x5f\x09\
	\x5f\x04\x60\x09\x60\x04\x61\x09\x61\x04\x62\x09\x62\x04\x63\x09\x63\x04\
	\x64\x09\x64\x04\x65\x09\x65\x04\x66\x09\x66\x04\x67\x09\x67\x04\x68\x09\
	\x68\x04\x69\x09\x69\x04\x6a\x09\x6a\x04\x6b\x09\x6b\x04\x6c\x09\x6c\x04\
	\x6d\x09\x6d\x04\x6e\x09\x6e\x04\x6f\x09\x6f\x04\x70\x09\x70\x04\x71\x09\
	\x71\x04\x72\x09\x72\x04\x73\x09\x73\x04\x74\x09\x74\x04\x75\x09\x75\x04\
	\x76\x09\x76\x04\x77\x09\x77\x04\x78\x09\x78\x04\x79\x09\x79\x04\x7a\x09\
	\x7a\x04\x7b\x09\x7b\x04\x7c\x09\x7c\x04\x7d\x09\x7d\x04\x7e\x09\x7e\x04\
	\x7f\x09\x7f\x04\u{80}\x09\u{80}\x04\u{81}\x09\u{81}\x04\u{82}\x09\u{82}\
	\x04\u{83}\x09\u{83}\x04\u{84}\x09\u{84}\x04\u{85}\x09\u{85}\x04\u{86}\x09\
	\u{86}\x04\u{87}\x09\u{87}\x04\u{88}\x09\u{88}\x04\u{89}\x09\u{89}\x04\u{8a}\
	\x09\u{8a}\x04\u{8b}\x09\u{8b}\x04\u{8c}\x09\u{8c}\x04\u{8d}\x09\u{8d}\x04\
	\u{8e}\x09\u{8e}\x04\u{8f}\x09\u{8f}\x04\u{90}\x09\u{90}\x04\u{91}\x09\u{91}\
	\x04\u{92}\x09\u{92}\x04\u{93}\x09\u{93}\x04\u{94}\x09\u{94}\x04\u{95}\x09\
	\u{95}\x04\u{96}\x09\u{96}\x04\u{97}\x09\u{97}\x04\u{98}\x09\u{98}\x04\u{99}\
	\x09\u{99}\x04\u{9a}\x09\u{9a}\x04\u{9b}\x09\u{9b}\x04\u{9c}\x09\u{9c}\x04\
	\u{9d}\x09\u{9d}\x04\u{9e}\x09\u{9e}\x04\u{9f}\x09\u{9f}\x04\u{a0}\x09\u{a0}\
	\x04\u{a1}\x09\u{a1}\x04\u{a2}\x09\u{a2}\x04\u{a3}\x09\u{a3}\x04\u{a4}\x09\
	\u{a4}\x04\u{a5}\x09\u{a5}\x04\u{a6}\x09\u{a6}\x04\u{a7}\x09\u{a7}\x04\u{a8}\
	\x09\u{a8}\x04\u{a9}\x09\u{a9}\x04\u{aa}\x09\u{aa}\x04\u{ab}\x09\u{ab}\x04\
	\u{ac}\x09\u{ac}\x04\u{ad}\x09\u{ad}\x04\u{ae}\x09\u{ae}\x04\u{af}\x09\u{af}\
	\x04\u{b0}\x09\u{b0}\x04\u{b1}\x09\u{b1}\x04\u{b2}\x09\u{b2}\x04\u{b3}\x09\
	\u{b3}\x04\u{b4}\x09\u{b4}\x04\u{b5}\x09\u{b5}\x04\u{b6}\x09\u{b6}\x04\u{b7}\
	\x09\u{b7}\x04\u{b8}\x09\u{b8}\x04\u{b9}\x09\u{b9}\x04\u{ba}\x09\u{ba}\x04\
	\u{bb}\x09\u{bb}\x04\u{bc}\x09\u{bc}\x04\u{bd}\x09\u{bd}\x04\u{be}\x09\u{be}\
	\x04\u{bf}\x09\u{bf}\x04\u{c0}\x09\u{c0}\x04\u{c1}\x09\u{c1}\x04\u{c2}\x09\
	\u{c2}\x04\u{c3}\x09\u{c3}\x04\u{c4}\x09\u{c4}\x04\u{c5}\x09\u{c5}\x04\u{c6}\
	\x09\u{c6}\x04\u{c7}\x09\u{c7}\x04\u{c8}\x09\u{c8}\x04\u{c9}\x09\u{c9}\x04\
	\u{ca}\x09\u{ca}\x04\u{cb}\x09\u{cb}\x04\u{cc}\x09\u{cc}\x04\u{cd}\x09\u{cd}\
	\x04\u{ce}\x09\u{ce}\x04\u{cf}\x09\u{cf}\x04\u{d0}\x09\u{d0}\x04\u{d1}\x09\
	\u{d1}\x04\u{d2}\x09\u{d2}\x04\u{d3}\x09\u{d3}\x04\u{d4}\x09\u{d4}\x04\u{d5}\
	\x09\u{d5}\x04\u{d6}\x09\u{d6}\x04\u{d7}\x09\u{d7}\x04\u{d8}\x09\u{d8}\x04\
	\u{d9}\x09\u{d9}\x04\u{da}\x09\u{da}\x04\u{db}\x09\u{db}\x04\u{dc}\x09\u{dc}\
	\x04\u{dd}\x09\u{dd}\x04\u{de}\x09\u{de}\x04\u{df}\x09\u{df}\x04\u{e0}\x09\
	\u{e0}\x04\u{e1}\x09\u{e1}\x04\u{e2}\x09\u{e2}\x04\u{e3}\x09\u{e3}\x04\u{e4}\
	\x09\u{e4}\x04\u{e5}\x09\u{e5}\x04\u{e6}\x09\u{e6}\x04\u{e7}\x09\u{e7}\x04\
	\u{e8}\x09\u{e8}\x04\u{e9}\x09\u{e9}\x04\u{ea}\x09\u{ea}\x04\u{eb}\x09\u{eb}\
	\x04\u{ec}\x09\u{ec}\x04\u{ed}\x09\u{ed}\x04\u{ee}\x09\u{ee}\x04\u{ef}\x09\
	\u{ef}\x04\u{f0}\x09\u{f0}\x04\u{f1}\x09\u{f1}\x04\u{f2}\x09\u{f2}\x04\u{f3}\
	\x09\u{f3}\x04\u{f4}\x09\u{f4}\x04\u{f5}\x09\u{f5}\x04\u{f6}\x09\u{f6}\x04\
	\u{f7}\x09\u{f7}\x04\u{f8}\x09\u{f8}\x04\u{f9}\x09\u{f9}\x04\u{fa}\x09\u{fa}\
	\x04\u{fb}\x09\u{fb}\x04\u{fc}\x09\u{fc}\x04\u{fd}\x09\u{fd}\x04\u{fe}\x09\
	\u{fe}\x04\u{ff}\x09\u{ff}\x04\u{100}\x09\u{100}\x04\u{101}\x09\u{101}\x04\
	\u{102}\x09\u{102}\x04\u{103}\x09\u{103}\x04\u{104}\x09\u{104}\x04\u{105}\
	\x09\u{105}\x04\u{106}\x09\u{106}\x04\u{107}\x09\u{107}\x04\u{108}\x09\u{108}\
	\x04\u{109}\x09\u{109}\x04\u{10a}\x09\u{10a}\x04\u{10b}\x09\u{10b}\x04\u{10c}\
	\x09\u{10c}\x04\u{10d}\x09\u{10d}\x04\u{10e}\x09\u{10e}\x04\u{10f}\x09\u{10f}\
	\x04\u{110}\x09\u{110}\x04\u{111}\x09\u{111}\x04\u{112}\x09\u{112}\x04\u{113}\
	\x09\u{113}\x04\u{114}\x09\u{114}\x04\u{115}\x09\u{115}\x04\u{116}\x09\u{116}\
	\x04\u{117}\x09\u{117}\x04\u{118}\x09\u{118}\x04\u{119}\x09\u{119}\x03\x02\
	\x05\x02\u{234}\x0a\x02\x03\x02\x05\x02\u{237}\x0a\x02\x03\x02\x03\x02\x03\
	\x03\x03\x03\x05\x03\u{23d}\x0a\x03\x03\x03\x03\x03\x03\x03\x07\x03\u{242}\
	\x0a\x03\x0c\x03\x0e\x03\u{245}\x0b\x03\x03\x03\x03\x03\x05\x03\u{249}\x0a\
	\x03\x03\x03\x05\x03\u{24c}\x0a\x03\x03\x03\x05\x03\u{24f}\x0a\x03\x03\x04\
	\x03\x04\x03\x05\x03\x05\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06\
	\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06\
	\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06\
	\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06\
	\x03\x06\x03\x06\x03\x06\x03\x06\x05\x06\u{27a}\x0a\x06\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x08\x03\x08\x03\x08\x03\x09\
	\x03\x09\x03\x09\x03\x09\x03\x09\x05\x09\u{28b}\x0a\x09\x03\x09\x05\x09\
	\u{28e}\x0a\x09\x03\x0a\x03\x0a\x03\x0a\x03\x0a\x03\x0a\x05\x0a\u{295}\x0a\
	\x0a\x03\x0a\x03\x0a\x03\x0a\x05\x0a\u{29a}\x0a\x0a\x03\x0b\x03\x0b\x03\
	\x0b\x03\x0b\x03\x0b\x03\x0b\x03\x0b\x03\x0c\x03\x0c\x05\x0c\u{2a5}\x0a\
	\x0c\x03\x0c\x03\x0c\x03\x0c\x03\x0c\x03\x0c\x03\x0c\x03\x0c\x03\x0c\x05\
	\x0c\u{2af}\x0a\x0c\x03\x0d\x03\x0d\x03\x0d\x03\x0d\x03\x0d\x03\x0d\x03\
	\x0d\x03\x0d\x03\x0d\x03\x0d\x03\x0d\x03\x0d\x03\x0d\x05\x0d\u{2be}\x0a\
	\x0d\x03\x0d\x03\x0d\x03\x0d\x03\x0d\x03\x0d\x03\x0d\x03\x0d\x03\x0d\x03\
	\x0d\x05\x0d\u{2c9}\x0a\x0d\x03\x0d\x03\x0d\x03\x0d\x05\x0d\u{2ce}\x0a\x0d\
	\x03\x0d\x03\x0d\x03\x0d\x03\x0d\x03\x0d\x03\x0d\x03\x0d\x05\x0d\u{2d7}\
	\x0a\x0d\x03\x0e\x03\x0e\x03\x0e\x05\x0e\u{2dc}\x0a\x0e\x03\x0e\x03\x0e\
	\x03\x0e\x03\x0e\x03\x0e\x03\x0e\x05\x0e\u{2e4}\x0a\x0e\x03\x0f\x03\x0f\
	\x03\x0f\x05\x0f\u{2e9}\x0a\x0f\x03\x0f\x03\x0f\x05\x0f\u{2ed}\x0a\x0f\x03\
	\x10\x03\x10\x03\x10\x05\x10\u{2f2}\x0a\x10\x03\x10\x03\x10\x03\x10\x05\
	\x10\u{2f7}\x0a\x10\x03\x10\x03\x10\x03\x10\x03\x10\x03\x10\x03\x11\x03\
	\x11\x03\x11\x03\x11\x03\x11\x03\x11\x07\x11\u{304}\x0a\x11\x0c\x11\x0e\
	\x11\u{307}\x0b\x11\x03\x12\x03\x12\x03\x12\x05\x12\u{30c}\x0a\x12\x03\x12\
	\x03\x12\x03\x12\x05\x12\u{311}\x0a\x12\x03\x12\x03\x12\x03\x12\x03\x12\
	\x03\x13\x03\x13\x03\x13\x03\x13\x05\x13\u{31b}\x0a\x13\x03\x13\x03\x13\
	\x03\x13\x05\x13\u{320}\x0a\x13\x03\x13\x03\x13\x03\x13\x03\x13\x03\x13\
	\x03\x13\x03\x13\x03\x13\x05\x13\u{32a}\x0a\x13\x03\x13\x03\x13\x03\x13\
	\x03\x13\x03\x13\x03\x13\x03\x13\x03\x13\x03\x13\x03\x13\x05\x13\u{336}\
	\x0a\x13\x03\x14\x03\x14\x03\x14\x03\x14\x03\x14\x05\x14\u{33d}\x0a\x14\
	\x03\x15\x03\x15\x03\x15\x03\x15\x07\x15\u{343}\x0a\x15\x0c\x15\x0e\x15\
	\u{346}\x0b\x15\x03\x16\x03\x16\x03\x16\x03\x16\x03\x16\x03\x17\x03\x17\
	\x03\x17\x03\x17\x03\x17\x03\x17\x05\x17\u{353}\x0a\x17\x03\x18\x03\x18\
	\x03\x18\x05\x18\u{358}\x0a\x18\x03\x18\x03\x18\x03\x18\x03\x18\x03\x18\
	\x03\x18\x03\x18\x03\x18\x03\x18\x03\x18\x05\x18\u{364}\x0a\x18\x03\x19\
	\x03\x19\x05\x19\u{368}\x0a\x19\x03\x19\x03\x19\x05\x19\u{36c}\x0a\x19\x03\
	\x19\x03\x19\x03\x19\x05\x19\u{371}\x0a\x19\x03\x19\x03\x19\x03\x19\x05\
	\x19\u{376}\x0a\x19\x03\x19\x03\x19\x03\x19\x03\x19\x03\x19\x03\x19\x03\
	\x19\x03\x19\x03\x19\x03\x1a\x03\x1a\x03\x1b\x03\x1b\x03\x1b\x03\x1b\x07\
	\x1b\u{387}\x0a\x1b\x0c\x1b\x0e\x1b\u{38a}\x0b\x1b\x03\x1c\x03\x1c\x03\x1c\
	\x03\x1c\x05\x1c\u{390}\x0a\x1c\x03\x1c\x03\x1c\x03\x1c\x03\x1c\x03\x1d\
	\x03\x1d\x05\x1d\u{398}\x0a\x1d\x03\x1d\x03\x1d\x05\x1d\u{39c}\x0a\x1d\x03\
	\x1d\x03\x1d\x03\x1d\x05\x1d\u{3a1}\x0a\x1d\x03\x1d\x03\x1d\x03\x1d\x03\
	\x1d\x03\x1d\x03\x1d\x03\x1d\x03\x1d\x03\x1d\x03\x1d\x03\x1d\x03\x1d\x03\
	\x1d\x03\x1e\x03\x1e\x03\x1e\x03\x1e\x05\x1e\u{3b4}\x0a\x1e\x03\x1f\x03\
	\x1f\x03\x1f\x03\x1f\x03\x1f\x07\x1f\u{3bb}\x0a\x1f\x0c\x1f\x0e\x1f\u{3be}\
	\x0b\x1f\x03\x1f\x03\x1f\x03\x20\x03\x20\x03\x20\x03\x20\x03\x21\x03\x21\
	\x03\x21\x03\x21\x03\x21\x03\x21\x07\x21\u{3cc}\x0a\x21\x0c\x21\x0e\x21\
	\u{3cf}\x0b\x21\x03\x21\x03\x21\x03\x22\x03\x22\x03\x22\x03\x22\x03\x22\
	\x07\x22\u{3d8}\x0a\x22\x0c\x22\x0e\x22\u{3db}\x0b\x22\x03\x22\x03\x22\x03\
	\x23\x03\x23\x03\x23\x03\x24\x03\x24\x03\x24\x03\x24\x03\x24\x03\x24\x05\
	\x24\u{3e8}\x0a\x24\x03\x25\x03\x25\x03\x25\x03\x26\x03\x26\x05\x26\u{3ef}\
	\x0a\x26\x03\x27\x03\x27\x03\x27\x03\x27\x03\x27\x05\x27\u{3f6}\x0a\x27\
	\x03\x27\x03\x27\x03\x27\x03\x28\x03\x28\x03\x28\x05\x28\u{3fe}\x0a\x28\
	\x03\x29\x03\x29\x03\x29\x03\x2a\x03\x2a\x03\x2a\x03\x2a\x07\x2a\u{407}\
	\x0a\x2a\x0c\x2a\x0e\x2a\u{40a}\x0b\x2a\x03\x2b\x03\x2b\x03\x2b\x03\x2b\
	\x03\x2c\x03\x2c\x03\x2c\x03\x2c\x03\x2c\x03\x2c\x03\x2c\x07\x2c\u{417}\
	\x0a\x2c\x0c\x2c\x0e\x2c\u{41a}\x0b\x2c\x03\x2d\x03\x2d\x03\x2d\x03\x2d\
	\x03\x2d\x03\x2e\x03\x2e\x03\x2e\x03\x2e\x03\x2e\x05\x2e\u{426}\x0a\x2e\
	\x03\x2e\x03\x2e\x03\x2e\x03\x2f\x03\x2f\x03\x2f\x03\x2f\x03\x2f\x03\x2f\
	\x05\x2f\u{431}\x0a\x2f\x03\x30\x03\x30\x03\x30\x03\x31\x03\x31\x03\x31\
	\x03\x31\x03\x31\x03\x32\x03\x32\x03\x32\x03\x32\x03\x33\x03\x33\x03\x33\
	\x03\x34\x03\x34\x03\x34\x03\x34\x07\x34\u{446}\x0a\x34\x0c\x34\x0e\x34\
	\u{449}\x0b\x34\x03\x35\x03\x35\x03\x35\x03\x36\x03\x36\x03\x36\x03\x36\
	\x03\x36\x03\x36\x07\x36\u{454}\x0a\x36\x0c\x36\x0e\x36\u{457}\x0b\x36\x03\
	\x37\x03\x37\x03\x37\x03\x37\x05\x37\u{45d}\x0a\x37\x03\x38\x03\x38\x03\
	\x38\x03\x38\x03\x38\x07\x38\u{464}\x0a\x38\x0c\x38\x0e\x38\u{467}\x0b\x38\
	\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\
	\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\x05\x39\u{479}\
	\x0a\x39\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x05\x3a\u{481}\
	\x0a\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x05\x3a\u{487}\x0a\x3a\x03\x3b\
	\x03\x3b\x03\x3b\x05\x3b\u{48c}\x0a\x3b\x03\x3b\x03\x3b\x03\x3c\x03\x3c\
	\x03\x3c\x05\x3c\u{493}\x0a\x3c\x03\x3c\x03\x3c\x03\x3c\x05\x3c\u{498}\x0a\
	\x3c\x03\x3c\x03\x3c\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x05\x3d\u{4a0}\x0a\
	\x3d\x03\x3d\x03\x3d\x03\x3d\x05\x3d\u{4a5}\x0a\x3d\x03\x3d\x03\x3d\x03\
	\x3e\x03\x3e\x03\x3e\x05\x3e\u{4ac}\x0a\x3e\x03\x3e\x03\x3e\x03\x3e\x05\
	\x3e\u{4b1}\x0a\x3e\x03\x3e\x03\x3e\x03\x3f\x03\x3f\x03\x3f\x05\x3f\u{4b8}\
	\x0a\x3f\x03\x3f\x03\x3f\x03\x3f\x05\x3f\u{4bd}\x0a\x3f\x03\x3f\x03\x3f\
	\x03\x40\x03\x40\x03\x40\x05\x40\u{4c4}\x0a\x40\x03\x40\x03\x40\x03\x40\
	\x03\x40\x03\x40\x05\x40\u{4cb}\x0a\x40\x03\x40\x03\x40\x03\x41\x03\x41\
	\x03\x41\x05\x41\u{4d2}\x0a\x41\x03\x41\x03\x41\x03\x42\x03\x42\x03\x42\
	\x05\x42\u{4d9}\x0a\x42\x03\x42\x03\x42\x03\x42\x05\x42\u{4de}\x0a\x42\x03\
	\x42\x03\x42\x03\x43\x03\x43\x03\x43\x05\x43\u{4e5}\x0a\x43\x03\x43\x03\
	\x43\x03\x44\x03\x44\x03\x44\x05\x44\u{4ec}\x0a\x44\x03\x44\x03\x44\x03\
	\x44\x05\x44\u{4f1}\x0a\x44\x03\x44\x03\x44\x03\x45\x03\x45\x03\x45\x05\
	\x45\u{4f8}\x0a\x45\x03\x45\x03\x45\x03\x45\x05\x45\u{4fd}\x0a\x45\x03\x45\
	\x03\x45\x03\x45\x03\x45\x03\x45\x05\x45\u{504}\x0a\x45\x03\x46\x03\x46\
	\x05\x46\u{508}\x0a\x46\x03\x46\x05\x46\u{50b}\x0a\x46\x03\x47\x03\x47\x03\
	\x47\x03\x47\x03\x47\x03\x47\x05\x47\u{513}\x0a\x47\x03\x47\x03\x47\x03\
	\x48\x03\x48\x03\x48\x03\x48\x07\x48\u{51b}\x0a\x48\x0c\x48\x0e\x48\u{51e}\
	\x0b\x48\x03\x49\x03\x49\x03\x49\x03\x49\x03\x49\x03\x49\x03\x49\x03\x49\
	\x05\x49\u{528}\x0a\x49\x03\x4a\x03\x4a\x03\x4b\x03\x4b\x05\x4b\u{52e}\x0a\
	\x4b\x03\x4c\x03\x4c\x03\x4c\x03\x4c\x03\x4c\x07\x4c\u{535}\x0a\x4c\x0c\
	\x4c\x0e\x4c\u{538}\x0b\x4c\x03\x4c\x03\x4c\x03\x4d\x03\x4d\x03\x4d\x03\
	\x4d\x03\x4e\x03\x4e\x03\x4f\x03\x4f\x05\x4f\u{544}\x0a\x4f\x03\x50\x03\
	\x50\x03\x50\x03\x50\x07\x50\u{54a}\x0a\x50\x0c\x50\x0e\x50\u{54d}\x0b\x50\
	\x03\x50\x03\x50\x03\x50\x05\x50\u{552}\x0a\x50\x03\x51\x03\x51\x03\x51\
	\x05\x51\u{557}\x0a\x51\x03\x52\x03\x52\x03\x52\x03\x53\x03\x53\x03\x53\
	\x03\x53\x03\x53\x03\x53\x03\x54\x03\x54\x03\x54\x05\x54\u{565}\x0a\x54\
	\x03\x55\x03\x55\x03\x56\x03\x56\x03\x56\x03\x56\x03\x57\x03\x57\x03\x57\
	\x03\x57\x03\x57\x03\x57\x03\x58\x03\x58\x03\x58\x03\x58\x07\x58\u{577}\
	\x0a\x58\x0c\x58\x0e\x58\u{57a}\x0b\x58\x03\x59\x03\x59\x03\x59\x03\x59\
	\x07\x59\u{580}\x0a\x59\x0c\x59\x0e\x59\u{583}\x0b\x59\x03\x5a\x03\x5a\x03\
	\x5b\x03\x5b\x03\x5c\x03\x5c\x03\x5c\x03\x5d\x03\x5d\x05\x5d\u{58e}\x0a\
	\x5d\x03\x5d\x03\x5d\x05\x5d\u{592}\x0a\x5d\x03\x5e\x03\x5e\x05\x5e\u{596}\
	\x0a\x5e\x03\x5f\x03\x5f\x03\x5f\x03\x5f\x03\x5f\x03\x5f\x03\x5f\x03\x5f\
	\x03\x5f\x03\x5f\x03\x5f\x03\x5f\x05\x5f\u{5a4}\x0a\x5f\x03\x60\x03\x60\
	\x03\x60\x03\x60\x07\x60\u{5aa}\x0a\x60\x0c\x60\x0e\x60\u{5ad}\x0b\x60\x03\
	\x61\x03\x61\x03\x61\x03\x61\x03\x61\x03\x61\x05\x61\u{5b5}\x0a\x61\x03\
	\x62\x03\x62\x03\x62\x03\x62\x03\x63\x03\x63\x03\x63\x03\x64\x03\x64\x05\
	\x64\u{5c0}\x0a\x64\x03\x64\x03\x64\x03\x64\x05\x64\u{5c5}\x0a\x64\x03\x64\
	\x03\x64\x03\x65\x03\x65\x03\x65\x05\x65\u{5cc}\x0a\x65\x03\x65\x05\x65\
	\u{5cf}\x0a\x65\x03\x65\x03\x65\x03\x65\x03\x65\x05\x65\u{5d5}\x0a\x65\x03\
	\x65\x03\x65\x03\x65\x03\x65\x03\x65\x03\x66\x03\x66\x05\x66\u{5de}\x0a\
	\x66\x03\x67\x03\x67\x03\x67\x03\x67\x05\x67\u{5e4}\x0a\x67\x03\x68\x03\
	\x68\x03\x68\x03\x68\x03\x68\x03\x69\x03\x69\x03\x69\x03\x69\x03\x69\x03\
	\x6a\x03\x6a\x03\x6a\x03\x6a\x03\x6a\x03\x6b\x05\x6b\u{5f6}\x0a\x6b\x03\
	\x6b\x03\x6b\x05\x6b\u{5fa}\x0a\x6b\x03\x6b\x03\x6b\x05\x6b\u{5fe}\x0a\x6b\
	\x03\x6b\x03\x6b\x03\x6b\x05\x6b\u{603}\x0a\x6b\x03\x6c\x03\x6c\x03\x6c\
	\x03\x6c\x07\x6c\u{609}\x0a\x6c\x0c\x6c\x0e\x6c\u{60c}\x0b\x6c\x03\x6d\x03\
	\x6d\x03\x6d\x03\x6d\x03\x6d\x05\x6d\u{613}\x0a\x6d\x03\x6d\x03\x6d\x05\
	\x6d\u{617}\x0a\x6d\x03\x6e\x05\x6e\u{61a}\x0a\x6e\x03\x6e\x03\x6e\x03\x6e\
	\x03\x6e\x05\x6e\u{620}\x0a\x6e\x03\x6e\x03\x6e\x05\x6e\u{624}\x0a\x6e\x03\
	\x6e\x03\x6e\x03\x6e\x03\x6e\x03\x6e\x05\x6e\u{62b}\x0a\x6e\x03\x6f\x03\
	\x6f\x03\x6f\x03\x70\x03\x70\x03\x70\x03\x70\x07\x70\u{634}\x0a\x70\x0c\
	\x70\x0e\x70\u{637}\x0b\x70\x03\x71\x03\x71\x03\x71\x03\x71\x03\x72\x03\
	\x72\x03\x72\x03\x72\x07\x72\u{641}\x0a\x72\x0c\x72\x0e\x72\u{644}\x0b\x72\
	\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\x05\x73\u{64c}\x0a\x73\
	\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\
	\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\
	\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\
	\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\
	\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\
	\x05\x73\u{67b}\x0a\x73\x03\x74\x03\x74\x03\x74\x03\x74\x03\x74\x07\x74\
	\u{682}\x0a\x74\x0c\x74\x0e\x74\u{685}\x0b\x74\x05\x74\u{687}\x0a\x74\x03\
	\x74\x03\x74\x03\x75\x03\x75\x03\x75\x03\x75\x03\x75\x03\x75\x03\x75\x03\
	\x75\x03\x75\x03\x75\x07\x75\u{695}\x0a\x75\x0c\x75\x0e\x75\u{698}\x0b\x75\
	\x03\x75\x03\x75\x03\x76\x03\x76\x03\x76\x03\x76\x03\x76\x07\x76\u{6a1}\
	\x0a\x76\x0c\x76\x0e\x76\u{6a4}\x0b\x76\x03\x76\x03\x76\x03\x77\x03\x77\
	\x03\x77\x03\x77\x03\x77\x07\x77\u{6ad}\x0a\x77\x0c\x77\x0e\x77\u{6b0}\x0b\
	\x77\x03\x77\x03\x77\x03\x77\x07\x77\u{6b5}\x0a\x77\x0c\x77\x0e\x77\u{6b8}\
	\x0b\x77\x05\x77\u{6ba}\x0a\x77\x03\x77\x03\x77\x03\x77\x03\x77\x07\x77\
	\u{6c0}\x0a\x77\x0c\x77\x0e\x77\u{6c3}\x0b\x77\x05\x77\u{6c5}\x0a\x77\x03\
	\x77\x03\x77\x03\x78\x05\x78\u{6ca}\x0a\x78\x03\x78\x03\x78\x03\x78\x03\
	\x78\x03\x78\x05\x78\u{6d1}\x0a\x78\x03\x78\x03\x78\x05\x78\u{6d5}\x0a\x78\
	\x03\x78\x03\x78\x05\x78\u{6d9}\x0a\x78\x03\x78\x05\x78\u{6dc}\x0a\x78\x03\
	\x79\x03\x79\x03\x79\x03\x79\x03\x79\x03\x79\x03\x79\x03\x79\x03\x79\x03\
	\x79\x03\x79\x03\x79\x03\x79\x03\x79\x03\x79\x03\x79\x05\x79\u{6ee}\x0a\
	\x79\x03\x7a\x03\x7a\x03\x7a\x03\x7b\x03\x7b\x03\x7b\x03\x7c\x03\x7c\x03\
	\x7c\x03\x7d\x03\x7d\x03\x7d\x03\x7d\x03\x7e\x03\x7e\x03\x7e\x03\x7f\x03\
	\x7f\x03\x7f\x03\x7f\x03\x7f\x03\x7f\x03\x7f\x03\x7f\x05\x7f\u{708}\x0a\
	\x7f\x03\u{80}\x03\u{80}\x03\u{80}\x03\u{80}\x03\u{81}\x03\u{81}\x03\u{81}\
	\x03\u{81}\x07\u{81}\u{712}\x0a\u{81}\x0c\u{81}\x0e\u{81}\u{715}\x0b\u{81}\
	\x03\u{82}\x03\u{82}\x03\u{82}\x03\u{82}\x07\u{82}\u{71b}\x0a\u{82}\x0c\
	\u{82}\x0e\u{82}\u{71e}\x0b\u{82}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\
	\x03\u{83}\x05\u{83}\u{725}\x0a\u{83}\x03\u{84}\x03\u{84}\x05\u{84}\u{729}\
	\x0a\u{84}\x03\u{84}\x05\u{84}\u{72c}\x0a\u{84}\x03\u{84}\x03\u{84}\x03\
	\u{84}\x05\u{84}\u{731}\x0a\u{84}\x03\u{84}\x05\u{84}\u{734}\x0a\u{84}\x03\
	\u{84}\x05\u{84}\u{737}\x0a\u{84}\x03\u{84}\x05\u{84}\u{73a}\x0a\u{84}\x03\
	\u{85}\x03\u{85}\x03\u{85}\x03\u{86}\x03\u{86}\x03\u{86}\x03\u{87}\x03\u{87}\
	\x03\u{87}\x03\u{88}\x03\u{88}\x03\u{88}\x03\u{88}\x05\u{88}\u{749}\x0a\
	\u{88}\x03\u{89}\x03\u{89}\x03\u{89}\x03\u{89}\x03\u{8a}\x03\u{8a}\x03\u{8a}\
	\x05\u{8a}\u{752}\x0a\u{8a}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8c}\x03\
	\u{8c}\x03\u{8d}\x03\u{8d}\x05\u{8d}\u{75b}\x0a\u{8d}\x03\u{8d}\x03\u{8d}\
	\x03\u{8d}\x07\u{8d}\u{760}\x0a\u{8d}\x0c\u{8d}\x0e\u{8d}\u{763}\x0b\u{8d}\
	\x03\u{8e}\x03\u{8e}\x03\u{8e}\x03\u{8e}\x03\u{8e}\x03\u{8e}\x03\u{8e}\x05\
	\u{8e}\u{76c}\x0a\u{8e}\x03\u{8e}\x03\u{8e}\x03\u{8e}\x03\u{8e}\x05\u{8e}\
	\u{772}\x0a\u{8e}\x05\u{8e}\u{774}\x0a\u{8e}\x03\u{8f}\x03\u{8f}\x03\u{8f}\
	\x03\u{8f}\x07\u{8f}\u{77a}\x0a\u{8f}\x0c\u{8f}\x0e\u{8f}\u{77d}\x0b\u{8f}\
	\x03\u{90}\x03\u{90}\x03\u{90}\x03\u{90}\x03\u{90}\x03\u{90}\x03\u{90}\x03\
	\u{90}\x03\u{90}\x03\u{90}\x03\u{90}\x03\u{90}\x03\u{90}\x03\u{90}\x03\u{90}\
	\x03\u{90}\x03\u{90}\x03\u{90}\x03\u{90}\x03\u{90}\x05\u{90}\u{793}\x0a\
	\u{90}\x03\u{90}\x03\u{90}\x03\u{90}\x03\u{90}\x03\u{90}\x03\u{90}\x03\u{90}\
	\x07\u{90}\u{79c}\x0a\u{90}\x0c\u{90}\x0e\u{90}\u{79f}\x0b\u{90}\x03\u{90}\
	\x03\u{90}\x03\u{90}\x03\u{90}\x03\u{90}\x03\u{90}\x03\u{90}\x07\u{90}\u{7a8}\
	\x0a\u{90}\x0c\u{90}\x0e\u{90}\u{7ab}\x0b\u{90}\x03\u{90}\x03\u{90}\x03\
	\u{90}\x03\u{90}\x03\u{90}\x03\u{90}\x03\u{90}\x07\u{90}\u{7b4}\x0a\u{90}\
	\x0c\u{90}\x0e\u{90}\u{7b7}\x0b\u{90}\x03\u{90}\x03\u{90}\x03\u{90}\x03\
	\u{90}\x03\u{90}\x03\u{90}\x07\u{90}\u{7bf}\x0a\u{90}\x0c\u{90}\x0e\u{90}\
	\u{7c2}\x0b\u{90}\x03\u{90}\x03\u{90}\x05\u{90}\u{7c6}\x0a\u{90}\x03\u{91}\
	\x03\u{91}\x03\u{91}\x03\u{91}\x03\u{92}\x03\u{92}\x03\u{92}\x03\u{92}\x03\
	\u{92}\x03\u{92}\x03\u{93}\x03\u{93}\x03\u{93}\x03\u{93}\x03\u{93}\x03\u{93}\
	\x03\u{93}\x05\u{93}\u{7d9}\x0a\u{93}\x03\u{93}\x05\u{93}\u{7dc}\x0a\u{93}\
	\x03\u{94}\x03\u{94}\x03\u{94}\x05\u{94}\u{7e1}\x0a\u{94}\x03\u{94}\x03\
	\u{94}\x03\u{94}\x03\u{94}\x05\u{94}\u{7e7}\x0a\u{94}\x07\u{94}\u{7e9}\x0a\
	\u{94}\x0c\u{94}\x0e\u{94}\u{7ec}\x0b\u{94}\x03\u{95}\x03\u{95}\x03\u{95}\
	\x03\u{95}\x03\u{95}\x03\u{95}\x03\u{95}\x03\u{95}\x05\u{95}\u{7f6}\x0a\
	\u{95}\x03\u{96}\x03\u{96}\x03\u{97}\x03\u{97}\x03\u{98}\x03\u{98}\x03\u{99}\
	\x03\u{99}\x03\u{9a}\x03\u{9a}\x03\u{9b}\x03\u{9b}\x03\u{9b}\x03\u{9b}\x05\
	\u{9b}\u{806}\x0a\u{9b}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x05\u{9c}\
	\u{80c}\x0a\u{9c}\x03\u{9d}\x03\u{9d}\x03\u{9d}\x03\u{9d}\x05\u{9d}\u{812}\
	\x0a\u{9d}\x03\u{9e}\x03\u{9e}\x05\u{9e}\u{816}\x0a\u{9e}\x03\u{9f}\x03\
	\u{9f}\x03\u{a0}\x03\u{a0}\x03\u{a0}\x03\u{a0}\x03\u{a0}\x07\u{a0}\u{81f}\
	\x0a\u{a0}\x0c\u{a0}\x0e\u{a0}\u{822}\x0b\u{a0}\x03\u{a0}\x03\u{a0}\x03\
	\u{a1}\x03\u{a1}\x05\u{a1}\u{828}\x0a\u{a1}\x03\u{a2}\x03\u{a2}\x03\u{a3}\
	\x03\u{a3}\x03\u{a4}\x03\u{a4}\x03\u{a5}\x03\u{a5}\x03\u{a6}\x03\u{a6}\x03\
	\u{a7}\x03\u{a7}\x03\u{a8}\x03\u{a8}\x03\u{a9}\x03\u{a9}\x03\u{aa}\x03\u{aa}\
	\x03\u{ab}\x03\u{ab}\x03\u{ac}\x03\u{ac}\x03\u{ad}\x03\u{ad}\x03\u{ad}\x03\
	\u{ae}\x03\u{ae}\x03\u{af}\x03\u{af}\x03\u{b0}\x03\u{b0}\x03\u{b1}\x03\u{b1}\
	\x03\u{b2}\x03\u{b2}\x03\u{b2}\x03\u{b3}\x03\u{b3}\x03\u{b4}\x03\u{b4}\x03\
	\u{b5}\x03\u{b5}\x03\u{b6}\x03\u{b6}\x03\u{b7}\x03\u{b7}\x03\u{b8}\x03\u{b8}\
	\x03\u{b9}\x03\u{b9}\x03\u{ba}\x03\u{ba}\x03\u{bb}\x03\u{bb}\x03\u{bc}\x03\
	\u{bc}\x03\u{bd}\x03\u{bd}\x03\u{be}\x03\u{be}\x03\u{bf}\x03\u{bf}\x03\u{c0}\
	\x03\u{c0}\x03\u{c1}\x03\u{c1}\x03\u{c2}\x03\u{c2}\x03\u{c3}\x03\u{c3}\x03\
	\u{c4}\x03\u{c4}\x03\u{c5}\x03\u{c5}\x03\u{c6}\x03\u{c6}\x03\u{c7}\x03\u{c7}\
	\x03\u{c8}\x03\u{c8}\x03\u{c9}\x03\u{c9}\x03\u{ca}\x03\u{ca}\x03\u{cb}\x03\
	\u{cb}\x03\u{cc}\x03\u{cc}\x03\u{cd}\x03\u{cd}\x03\u{ce}\x03\u{ce}\x03\u{cf}\
	\x03\u{cf}\x03\u{d0}\x03\u{d0}\x03\u{d1}\x03\u{d1}\x03\u{d2}\x03\u{d2}\x03\
	\u{d3}\x03\u{d3}\x03\u{d4}\x03\u{d4}\x03\u{d5}\x03\u{d5}\x03\u{d6}\x03\u{d6}\
	\x03\u{d7}\x03\u{d7}\x03\u{d8}\x03\u{d8}\x03\u{d9}\x03\u{d9}\x03\u{da}\x03\
	\u{da}\x03\u{db}\x03\u{db}\x03\u{dc}\x03\u{dc}\x03\u{dd}\x03\u{dd}\x03\u{de}\
	\x03\u{de}\x03\u{df}\x03\u{df}\x03\u{e0}\x03\u{e0}\x03\u{e1}\x03\u{e1}\x03\
	\u{e2}\x03\u{e2}\x03\u{e3}\x03\u{e3}\x03\u{e4}\x03\u{e4}\x03\u{e5}\x03\u{e5}\
	\x03\u{e6}\x03\u{e6}\x03\u{e7}\x03\u{e7}\x03\u{e8}\x03\u{e8}\x03\u{e9}\x03\
	\u{e9}\x03\u{ea}\x03\u{ea}\x03\u{eb}\x03\u{eb}\x03\u{ec}\x03\u{ec}\x03\u{ed}\
	\x03\u{ed}\x03\u{ee}\x03\u{ee}\x03\u{ef}\x03\u{ef}\x03\u{f0}\x03\u{f0}\x03\
	\u{f1}\x03\u{f1}\x03\u{f2}\x03\u{f2}\x03\u{f3}\x03\u{f3}\x03\u{f4}\x03\u{f4}\
	\x03\u{f5}\x03\u{f5}\x03\u{f6}\x03\u{f6}\x03\u{f7}\x03\u{f7}\x03\u{f8}\x03\
	\u{f8}\x03\u{f9}\x03\u{f9}\x03\u{fa}\x03\u{fa}\x03\u{fb}\x03\u{fb}\x03\u{fc}\
	\x03\u{fc}\x03\u{fd}\x03\u{fd}\x03\u{fe}\x03\u{fe}\x03\u{ff}\x03\u{ff}\x03\
	\u{100}\x03\u{100}\x03\u{101}\x03\u{101}\x03\u{102}\x03\u{102}\x03\u{103}\
	\x03\u{103}\x03\u{104}\x03\u{104}\x03\u{105}\x03\u{105}\x03\u{106}\x03\u{106}\
	\x03\u{107}\x03\u{107}\x03\u{108}\x03\u{108}\x03\u{109}\x03\u{109}\x03\u{10a}\
	\x03\u{10a}\x03\u{10b}\x03\u{10b}\x03\u{10c}\x03\u{10c}\x03\u{10d}\x03\u{10d}\
	\x03\u{10e}\x03\u{10e}\x03\u{10f}\x03\u{10f}\x03\u{110}\x03\u{110}\x03\u{111}\
	\x03\u{111}\x03\u{112}\x03\u{112}\x03\u{113}\x03\u{113}\x03\u{114}\x03\u{114}\
	\x03\u{115}\x03\u{115}\x03\u{116}\x03\u{116}\x03\u{117}\x03\u{117}\x03\u{118}\
	\x03\u{118}\x03\u{119}\x03\u{119}\x03\u{119}\x02\x02\u{11a}\x02\x04\x06\
	\x08\x0a\x0c\x0e\x10\x12\x14\x16\x18\x1a\x1c\x1e\x20\x22\x24\x26\x28\x2a\
	\x2c\x2e\x30\x32\x34\x36\x38\x3a\x3c\x3e\x40\x42\x44\x46\x48\x4a\x4c\x4e\
	\x50\x52\x54\x56\x58\x5a\x5c\x5e\x60\x62\x64\x66\x68\x6a\x6c\x6e\x70\x72\
	\x74\x76\x78\x7a\x7c\x7e\u{80}\u{82}\u{84}\u{86}\u{88}\u{8a}\u{8c}\u{8e}\
	\u{90}\u{92}\u{94}\u{96}\u{98}\u{9a}\u{9c}\u{9e}\u{a0}\u{a2}\u{a4}\u{a6}\
	\u{a8}\u{aa}\u{ac}\u{ae}\u{b0}\u{b2}\u{b4}\u{b6}\u{b8}\u{ba}\u{bc}\u{be}\
	\u{c0}\u{c2}\u{c4}\u{c6}\u{c8}\u{ca}\u{cc}\u{ce}\u{d0}\u{d2}\u{d4}\u{d6}\
	\u{d8}\u{da}\u{dc}\u{de}\u{e0}\u{e2}\u{e4}\u{e6}\u{e8}\u{ea}\u{ec}\u{ee}\
	\u{f0}\u{f2}\u{f4}\u{f6}\u{f8}\u{fa}\u{fc}\u{fe}\u{100}\u{102}\u{104}\u{106}\
	\u{108}\u{10a}\u{10c}\u{10e}\u{110}\u{112}\u{114}\u{116}\u{118}\u{11a}\u{11c}\
	\u{11e}\u{120}\u{122}\u{124}\u{126}\u{128}\u{12a}\u{12c}\u{12e}\u{130}\u{132}\
	\u{134}\u{136}\u{138}\u{13a}\u{13c}\u{13e}\u{140}\u{142}\u{144}\u{146}\u{148}\
	\u{14a}\u{14c}\u{14e}\u{150}\u{152}\u{154}\u{156}\u{158}\u{15a}\u{15c}\u{15e}\
	\u{160}\u{162}\u{164}\u{166}\u{168}\u{16a}\u{16c}\u{16e}\u{170}\u{172}\u{174}\
	\u{176}\u{178}\u{17a}\u{17c}\u{17e}\u{180}\u{182}\u{184}\u{186}\u{188}\u{18a}\
	\u{18c}\u{18e}\u{190}\u{192}\u{194}\u{196}\u{198}\u{19a}\u{19c}\u{19e}\u{1a0}\
	\u{1a2}\u{1a4}\u{1a6}\u{1a8}\u{1aa}\u{1ac}\u{1ae}\u{1b0}\u{1b2}\u{1b4}\u{1b6}\
	\u{1b8}\u{1ba}\u{1bc}\u{1be}\u{1c0}\u{1c2}\u{1c4}\u{1c6}\u{1c8}\u{1ca}\u{1cc}\
	\u{1ce}\u{1d0}\u{1d2}\u{1d4}\u{1d6}\u{1d8}\u{1da}\u{1dc}\u{1de}\u{1e0}\u{1e2}\
	\u{1e4}\u{1e6}\u{1e8}\u{1ea}\u{1ec}\u{1ee}\u{1f0}\u{1f2}\u{1f4}\u{1f6}\u{1f8}\
	\u{1fa}\u{1fc}\u{1fe}\u{200}\u{202}\u{204}\u{206}\u{208}\u{20a}\u{20c}\u{20e}\
	\u{210}\u{212}\u{214}\u{216}\u{218}\u{21a}\u{21c}\u{21e}\u{220}\u{222}\u{224}\
	\u{226}\u{228}\u{22a}\u{22c}\u{22e}\u{230}\x02\x07\x04\x02\x14\x14\x16\x16\
	\x03\x02\u{ad}\u{b1}\x03\x02\u{a7}\u{a8}\x04\x02\x39\x39\x7f\x7f\x07\x02\
	\x73\x73\x7b\x7b\u{89}\u{89}\u{8f}\u{a4}\u{ab}\u{ab}\x02\u{915}\x02\u{233}\
	\x03\x02\x02\x02\x04\u{243}\x03\x02\x02\x02\x06\u{250}\x03\x02\x02\x02\x08\
	\u{252}\x03\x02\x02\x02\x0a\u{279}\x03\x02\x02\x02\x0c\u{27b}\x03\x02\x02\
	\x02\x0e\u{282}\x03\x02\x02\x02\x10\u{285}\x03\x02\x02\x02\x12\u{28f}\x03\
	\x02\x02\x02\x14\u{29b}\x03\x02\x02\x02\x16\u{2ae}\x03\x02\x02\x02\x18\u{2d6}\
	\x03\x02\x02\x02\x1a\u{2d8}\x03\x02\x02\x02\x1c\u{2e5}\x03\x02\x02\x02\x1e\
	\u{2ee}\x03\x02\x02\x02\x20\u{2fd}\x03\x02\x02\x02\x22\u{308}\x03\x02\x02\
	\x02\x24\u{316}\x03\x02\x02\x02\x26\u{337}\x03\x02\x02\x02\x28\u{33e}\x03\
	\x02\x02\x02\x2a\u{347}\x03\x02\x02\x02\x2c\u{352}\x03\x02\x02\x02\x2e\u{354}\
	\x03\x02\x02\x02\x30\u{365}\x03\x02\x02\x02\x32\u{380}\x03\x02\x02\x02\x34\
	\u{382}\x03\x02\x02\x02\x36\u{38f}\x03\x02\x02\x02\x38\u{395}\x03\x02\x02\
	\x02\x3a\u{3b3}\x03\x02\x02\x02\x3c\u{3b5}\x03\x02\x02\x02\x3e\u{3c1}\x03\
	\x02\x02\x02\x40\u{3c5}\x03\x02\x02\x02\x42\u{3d2}\x03\x02\x02\x02\x44\u{3de}\
	\x03\x02\x02\x02\x46\u{3e1}\x03\x02\x02\x02\x48\u{3e9}\x03\x02\x02\x02\x4a\
	\u{3ee}\x03\x02\x02\x02\x4c\u{3f0}\x03\x02\x02\x02\x4e\u{3fd}\x03\x02\x02\
	\x02\x50\u{3ff}\x03\x02\x02\x02\x52\u{402}\x03\x02\x02\x02\x54\u{40b}\x03\
	\x02\x02\x02\x56\u{40f}\x03\x02\x02\x02\x58\u{41b}\x03\x02\x02\x02\x5a\u{420}\
	\x03\x02\x02\x02\x5c\u{430}\x03\x02\x02\x02\x5e\u{432}\x03\x02\x02\x02\x60\
	\u{435}\x03\x02\x02\x02\x62\u{43a}\x03\x02\x02\x02\x64\u{43e}\x03\x02\x02\
	\x02\x66\u{441}\x03\x02\x02\x02\x68\u{44a}\x03\x02\x02\x02\x6a\u{44d}\x03\
	\x02\x02\x02\x6c\u{458}\x03\x02\x02\x02\x6e\u{45e}\x03\x02\x02\x02\x70\u{478}\
	\x03\x02\x02\x02\x72\u{47a}\x03\x02\x02\x02\x74\u{488}\x03\x02\x02\x02\x76\
	\u{48f}\x03\x02\x02\x02\x78\u{49b}\x03\x02\x02\x02\x7a\u{4a8}\x03\x02\x02\
	\x02\x7c\u{4b4}\x03\x02\x02\x02\x7e\u{4c0}\x03\x02\x02\x02\u{80}\u{4ce}\
	\x03\x02\x02\x02\u{82}\u{4d5}\x03\x02\x02\x02\u{84}\u{4e1}\x03\x02\x02\x02\
	\u{86}\u{4e8}\x03\x02\x02\x02\u{88}\u{4f4}\x03\x02\x02\x02\u{8a}\u{505}\
	\x03\x02\x02\x02\u{8c}\u{50c}\x03\x02\x02\x02\u{8e}\u{516}\x03\x02\x02\x02\
	\u{90}\u{527}\x03\x02\x02\x02\u{92}\u{529}\x03\x02\x02\x02\u{94}\u{52d}\
	\x03\x02\x02\x02\u{96}\u{52f}\x03\x02\x02\x02\u{98}\u{53b}\x03\x02\x02\x02\
	\u{9a}\u{53f}\x03\x02\x02\x02\u{9c}\u{543}\x03\x02\x02\x02\u{9e}\u{545}\
	\x03\x02\x02\x02\u{a0}\u{553}\x03\x02\x02\x02\u{a2}\u{558}\x03\x02\x02\x02\
	\u{a4}\u{55b}\x03\x02\x02\x02\u{a6}\u{564}\x03\x02\x02\x02\u{a8}\u{566}\
	\x03\x02\x02\x02\u{aa}\u{568}\x03\x02\x02\x02\u{ac}\u{56c}\x03\x02\x02\x02\
	\u{ae}\u{572}\x03\x02\x02\x02\u{b0}\u{57b}\x03\x02\x02\x02\u{b2}\u{584}\
	\x03\x02\x02\x02\u{b4}\u{586}\x03\x02\x02\x02\u{b6}\u{588}\x03\x02\x02\x02\
	\u{b8}\u{58b}\x03\x02\x02\x02\u{ba}\u{595}\x03\x02\x02\x02\u{bc}\u{597}\
	\x03\x02\x02\x02\u{be}\u{5a5}\x03\x02\x02\x02\u{c0}\u{5b4}\x03\x02\x02\x02\
	\u{c2}\u{5b6}\x03\x02\x02\x02\u{c4}\u{5ba}\x03\x02\x02\x02\u{c6}\u{5bd}\
	\x03\x02\x02\x02\u{c8}\u{5c8}\x03\x02\x02\x02\u{ca}\u{5dd}\x03\x02\x02\x02\
	\u{cc}\u{5e3}\x03\x02\x02\x02\u{ce}\u{5e5}\x03\x02\x02\x02\u{d0}\u{5ea}\
	\x03\x02\x02\x02\u{d2}\u{5ef}\x03\x02\x02\x02\u{d4}\u{5f5}\x03\x02\x02\x02\
	\u{d6}\u{604}\x03\x02\x02\x02\u{d8}\u{616}\x03\x02\x02\x02\u{da}\u{619}\
	\x03\x02\x02\x02\u{dc}\u{62c}\x03\x02\x02\x02\u{de}\u{62f}\x03\x02\x02\x02\
	\u{e0}\u{638}\x03\x02\x02\x02\u{e2}\u{63c}\x03\x02\x02\x02\u{e4}\u{67a}\
	\x03\x02\x02\x02\u{e6}\u{67c}\x03\x02\x02\x02\u{e8}\u{68a}\x03\x02\x02\x02\
	\u{ea}\u{69b}\x03\x02\x02\x02\u{ec}\u{6a7}\x03\x02\x02\x02\u{ee}\u{6c9}\
	\x03\x02\x02\x02\u{f0}\u{6ed}\x03\x02\x02\x02\u{f2}\u{6ef}\x03\x02\x02\x02\
	\u{f4}\u{6f2}\x03\x02\x02\x02\u{f6}\u{6f5}\x03\x02\x02\x02\u{f8}\u{6f8}\
	\x03\x02\x02\x02\u{fa}\u{6fc}\x03\x02\x02\x02\u{fc}\u{707}\x03\x02\x02\x02\
	\u{fe}\u{709}\x03\x02\x02\x02\u{100}\u{70d}\x03\x02\x02\x02\u{102}\u{716}\
	\x03\x02\x02\x02\u{104}\u{724}\x03\x02\x02\x02\u{106}\u{726}\x03\x02\x02\
	\x02\u{108}\u{73b}\x03\x02\x02\x02\u{10a}\u{73e}\x03\x02\x02\x02\u{10c}\
	\u{741}\x03\x02\x02\x02\u{10e}\u{748}\x03\x02\x02\x02\u{110}\u{74a}\x03\
	\x02\x02\x02\u{112}\u{74e}\x03\x02\x02\x02\u{114}\u{753}\x03\x02\x02\x02\
	\u{116}\u{756}\x03\x02\x02\x02\u{118}\u{75a}\x03\x02\x02\x02\u{11a}\u{773}\
	\x03\x02\x02\x02\u{11c}\u{775}\x03\x02\x02\x02\u{11e}\u{7c5}\x03\x02\x02\
	\x02\u{120}\u{7c7}\x03\x02\x02\x02\u{122}\u{7cb}\x03\x02\x02\x02\u{124}\
	\u{7db}\x03\x02\x02\x02\u{126}\u{7e0}\x03\x02\x02\x02\u{128}\u{7f5}\x03\
	\x02\x02\x02\u{12a}\u{7f7}\x03\x02\x02\x02\u{12c}\u{7f9}\x03\x02\x02\x02\
	\u{12e}\u{7fb}\x03\x02\x02\x02\u{130}\u{7fd}\x03\x02\x02\x02\u{132}\u{7ff}\
	\x03\x02\x02\x02\u{134}\u{805}\x03\x02\x02\x02\u{136}\u{80b}\x03\x02\x02\
	\x02\u{138}\u{811}\x03\x02\x02\x02\u{13a}\u{813}\x03\x02\x02\x02\u{13c}\
	\u{817}\x03\x02\x02\x02\u{13e}\u{819}\x03\x02\x02\x02\u{140}\u{827}\x03\
	\x02\x02\x02\u{142}\u{829}\x03\x02\x02\x02\u{144}\u{82b}\x03\x02\x02\x02\
	\u{146}\u{82d}\x03\x02\x02\x02\u{148}\u{82f}\x03\x02\x02\x02\u{14a}\u{831}\
	\x03\x02\x02\x02\u{14c}\u{833}\x03\x02\x02\x02\u{14e}\u{835}\x03\x02\x02\
	\x02\u{150}\u{837}\x03\x02\x02\x02\u{152}\u{839}\x03\x02\x02\x02\u{154}\
	\u{83b}\x03\x02\x02\x02\u{156}\u{83d}\x03\x02\x02\x02\u{158}\u{83f}\x03\
	\x02\x02\x02\u{15a}\u{842}\x03\x02\x02\x02\u{15c}\u{844}\x03\x02\x02\x02\
	\u{15e}\u{846}\x03\x02\x02\x02\u{160}\u{848}\x03\x02\x02\x02\u{162}\u{84a}\
	\x03\x02\x02\x02\u{164}\u{84d}\x03\x02\x02\x02\u{166}\u{84f}\x03\x02\x02\
	\x02\u{168}\u{851}\x03\x02\x02\x02\u{16a}\u{853}\x03\x02\x02\x02\u{16c}\
	\u{855}\x03\x02\x02\x02\u{16e}\u{857}\x03\x02\x02\x02\u{170}\u{859}\x03\
	\x02\x02\x02\u{172}\u{85b}\x03\x02\x02\x02\u{174}\u{85d}\x03\x02\x02\x02\
	\u{176}\u{85f}\x03\x02\x02\x02\u{178}\u{861}\x03\x02\x02\x02\u{17a}\u{863}\
	\x03\x02\x02\x02\u{17c}\u{865}\x03\x02\x02\x02\u{17e}\u{867}\x03\x02\x02\
	\x02\u{180}\u{869}\x03\x02\x02\x02\u{182}\u{86b}\x03\x02\x02\x02\u{184}\
	\u{86d}\x03\x02\x02\x02\u{186}\u{86f}\x03\x02\x02\x02\u{188}\u{871}\x03\
	\x02\x02\x02\u{18a}\u{873}\x03\x02\x02\x02\u{18c}\u{875}\x03\x02\x02\x02\
	\u{18e}\u{877}\x03\x02\x02\x02\u{190}\u{879}\x03\x02\x02\x02\u{192}\u{87b}\
	\x03\x02\x02\x02\u{194}\u{87d}\x03\x02\x02\x02\u{196}\u{87f}\x03\x02\x02\
	\x02\u{198}\u{881}\x03\x02\x02\x02\u{19a}\u{883}\x03\x02\x02\x02\u{19c}\
	\u{885}\x03\x02\x02\x02\u{19e}\u{887}\x03\x02\x02\x02\u{1a0}\u{889}\x03\
	\x02\x02\x02\u{1a2}\u{88b}\x03\x02\x02\x02\u{1a4}\u{88d}\x03\x02\x02\x02\
	\u{1a6}\u{88f}\x03\x02\x02\x02\u{1a8}\u{891}\x03\x02\x02\x02\u{1aa}\u{893}\
	\x03\x02\x02\x02\u{1ac}\u{895}\x03\x02\x02\x02\u{1ae}\u{897}\x03\x02\x02\
	\x02\u{1b0}\u{899}\x03\x02\x02\x02\u{1b2}\u{89b}\x03\x02\x02\x02\u{1b4}\
	\u{89d}\x03\x02\x02\x02\u{1b6}\u{89f}\x03\x02\x02\x02\u{1b8}\u{8a1}\x03\
	\x02\x02\x02\u{1ba}\u{8a3}\x03\x02\x02\x02\u{1bc}\u{8a5}\x03\x02\x02\x02\
	\u{1be}\u{8a7}\x03\x02\x02\x02\u{1c0}\u{8a9}\x03\x02\x02\x02\u{1c2}\u{8ab}\
	\x03\x02\x02\x02\u{1c4}\u{8ad}\x03\x02\x02\x02\u{1c6}\u{8af}\x03\x02\x02\
	\x02\u{1c8}\u{8b1}\x03\x02\x02\x02\u{1ca}\u{8b3}\x03\x02\x02\x02\u{1cc}\
	\u{8b5}\x03\x02\x02\x02\u{1ce}\u{8b7}\x03\x02\x02\x02\u{1d0}\u{8b9}\x03\
	\x02\x02\x02\u{1d2}\u{8bb}\x03\x02\x02\x02\u{1d4}\u{8bd}\x03\x02\x02\x02\
	\u{1d6}\u{8bf}\x03\x02\x02\x02\u{1d8}\u{8c1}\x03\x02\x02\x02\u{1da}\u{8c3}\
	\x03\x02\x02\x02\u{1dc}\u{8c5}\x03\x02\x02\x02\u{1de}\u{8c7}\x03\x02\x02\
	\x02\u{1e0}\u{8c9}\x03\x02\x02\x02\u{1e2}\u{8cb}\x03\x02\x02\x02\u{1e4}\
	\u{8cd}\x03\x02\x02\x02\u{1e6}\u{8cf}\x03\x02\x02\x02\u{1e8}\u{8d1}\x03\
	\x02\x02\x02\u{1ea}\u{8d3}\x03\x02\x02\x02\u{1ec}\u{8d5}\x03\x02\x02\x02\
	\u{1ee}\u{8d7}\x03\x02\x02\x02\u{1f0}\u{8d9}\x03\x02\x02\x02\u{1f2}\u{8db}\
	\x03\x02\x02\x02\u{1f4}\u{8dd}\x03\x02\x02\x02\u{1f6}\u{8df}\x03\x02\x02\
	\x02\u{1f8}\u{8e1}\x03\x02\x02\x02\u{1fa}\u{8e3}\x03\x02\x02\x02\u{1fc}\
	\u{8e5}\x03\x02\x02\x02\u{1fe}\u{8e7}\x03\x02\x02\x02\u{200}\u{8e9}\x03\
	\x02\x02\x02\u{202}\u{8eb}\x03\x02\x02\x02\u{204}\u{8ed}\x03\x02\x02\x02\
	\u{206}\u{8ef}\x03\x02\x02\x02\u{208}\u{8f1}\x03\x02\x02\x02\u{20a}\u{8f3}\
	\x03\x02\x02\x02\u{20c}\u{8f5}\x03\x02\x02\x02\u{20e}\u{8f7}\x03\x02\x02\
	\x02\u{210}\u{8f9}\x03\x02\x02\x02\u{212}\u{8fb}\x03\x02\x02\x02\u{214}\
	\u{8fd}\x03\x02\x02\x02\u{216}\u{8ff}\x03\x02\x02\x02\u{218}\u{901}\x03\
	\x02\x02\x02\u{21a}\u{903}\x03\x02\x02\x02\u{21c}\u{905}\x03\x02\x02\x02\
	\u{21e}\u{907}\x03\x02\x02\x02\u{220}\u{909}\x03\x02\x02\x02\u{222}\u{90b}\
	\x03\x02\x02\x02\u{224}\u{90d}\x03\x02\x02\x02\u{226}\u{90f}\x03\x02\x02\
	\x02\u{228}\u{911}\x03\x02\x02\x02\u{22a}\u{913}\x03\x02\x02\x02\u{22c}\
	\u{915}\x03\x02\x02\x02\u{22e}\u{917}\x03\x02\x02\x02\u{230}\u{919}\x03\
	\x02\x02\x02\u{232}\u{234}\x05\x04\x03\x02\u{233}\u{232}\x03\x02\x02\x02\
	\u{233}\u{234}\x03\x02\x02\x02\u{234}\u{236}\x03\x02\x02\x02\u{235}\u{237}\
	\x07\x15\x02\x02\u{236}\u{235}\x03\x02\x02\x02\u{236}\u{237}\x03\x02\x02\
	\x02\u{237}\u{238}\x03\x02\x02\x02\u{238}\u{239}\x05\u{21c}\u{10f}\x02\u{239}\
	\x03\x03\x02\x02\x02\u{23a}\u{23c}\x05\x0a\x06\x02\u{23b}\u{23d}\x07\x15\
	\x02\x02\u{23c}\u{23b}\x03\x02\x02\x02\u{23c}\u{23d}\x03\x02\x02\x02\u{23d}\
	\u{23e}\x03\x02\x02\x02\u{23e}\u{23f}\x05\x06\x04\x02\u{23f}\u{242}\x03\
	\x02\x02\x02\u{240}\u{242}\x05\x08\x05\x02\u{241}\u{23a}\x03\x02\x02\x02\
	\u{241}\u{240}\x03\x02\x02\x02\u{242}\u{245}\x03\x02\x02\x02\u{243}\u{241}\
	\x03\x02\x02\x02\u{243}\u{244}\x03\x02\x02\x02\u{244}\u{24e}\x03\x02\x02\
	\x02\u{245}\u{243}\x03\x02\x02\x02\u{246}\u{24b}\x05\x0a\x06\x02\u{247}\
	\u{249}\x07\x15\x02\x02\u{248}\u{247}\x03\x02\x02\x02\u{248}\u{249}\x03\
	\x02\x02\x02\u{249}\u{24a}\x03\x02\x02\x02\u{24a}\u{24c}\x05\x06\x04\x02\
	\u{24b}\u{248}\x03\x02\x02\x02\u{24b}\u{24c}\x03\x02\x02\x02\u{24c}\u{24f}\
	\x03\x02\x02\x02\u{24d}\u{24f}\x05\x08\x05\x02\u{24e}\u{246}\x03\x02\x02\
	\x02\u{24e}\u{24d}\x03\x02\x02\x02\u{24f}\x05\x03\x02\x02\x02\u{250}\u{251}\
	\x07\x0a\x02\x02\u{251}\x07\x03\x02\x02\x02\u{252}\u{253}\x05\x06\x04\x02\
	\u{253}\x09\x03\x02\x02\x02\u{254}\u{27a}\x05\u{bc}\x5f\x02\u{255}\u{27a}\
	\x05\x72\x3a\x02\u{256}\u{27a}\x05\x6c\x37\x02\u{257}\u{27a}\x05\x5a\x2e\
	\x02\u{258}\u{27a}\x05\x4c\x27\x02\u{259}\u{27a}\x05\x46\x24\x02\u{25a}\
	\u{27a}\x05\u{b6}\x5c\x02\u{25b}\u{27a}\x05\x38\x1d\x02\u{25c}\u{27a}\x05\
	\x30\x19\x02\u{25d}\u{27a}\x05\u{c8}\x65\x02\u{25e}\u{27a}\x05\x2e\x18\x02\
	\u{25f}\u{27a}\x05\x24\x13\x02\u{260}\u{27a}\x05\x1c\x0f\x02\u{261}\u{27a}\
	\x05\u{88}\x45\x02\u{262}\u{27a}\x05\x22\x12\x02\u{263}\u{27a}\x05\x1e\x10\
	\x02\u{264}\u{27a}\x05\x1a\x0e\x02\u{265}\u{27a}\x05\u{d4}\x6b\x02\u{266}\
	\u{27a}\x05\x7a\x3e\x02\u{267}\u{27a}\x05\x7c\x3f\x02\u{268}\u{27a}\x05\
	\u{86}\x44\x02\u{269}\u{27a}\x05\u{84}\x43\x02\u{26a}\u{27a}\x05\x78\x3d\
	\x02\u{26b}\u{27a}\x05\u{80}\x41\x02\u{26c}\u{27a}\x05\u{82}\x42\x02\u{26d}\
	\u{27a}\x05\x7e\x40\x02\u{26e}\u{27a}\x05\x76\x3c\x02\u{26f}\u{27a}\x05\
	\x74\x3b\x02\u{270}\u{27a}\x05\x14\x0b\x02\u{271}\u{27a}\x05\u{ee}\x78\x02\
	\u{272}\u{27a}\x05\x12\x0a\x02\u{273}\u{27a}\x05\x10\x09\x02\u{274}\u{27a}\
	\x05\x0c\x07\x02\u{275}\u{27a}\x05\u{106}\u{84}\x02\u{276}\u{27a}\x05\u{c6}\
	\x64\x02\u{277}\u{27a}\x05\u{da}\x6e\x02\u{278}\u{27a}\x05\u{c4}\x63\x02\
	\u{279}\u{254}\x03\x02\x02\x02\u{279}\u{255}\x03\x02\x02\x02\u{279}\u{256}\
	\x03\x02\x02\x02\u{279}\u{257}\x03\x02\x02\x02\u{279}\u{258}\x03\x02\x02\
	\x02\u{279}\u{259}\x03\x02\x02\x02\u{279}\u{25a}\x03\x02\x02\x02\u{279}\
	\u{25b}\x03\x02\x02\x02\u{279}\u{25c}\x03\x02\x02\x02\u{279}\u{25d}\x03\
	\x02\x02\x02\u{279}\u{25e}\x03\x02\x02\x02\u{279}\u{25f}\x03\x02\x02\x02\
	\u{279}\u{260}\x03\x02\x02\x02\u{279}\u{261}\x03\x02\x02\x02\u{279}\u{262}\
	\x03\x02\x02\x02\u{279}\u{263}\x03\x02\x02\x02\u{279}\u{264}\x03\x02\x02\
	\x02\u{279}\u{265}\x03\x02\x02\x02\u{279}\u{266}\x03\x02\x02\x02\u{279}\
	\u{267}\x03\x02\x02\x02\u{279}\u{268}\x03\x02\x02\x02\u{279}\u{269}\x03\
	\x02\x02\x02\u{279}\u{26a}\x03\x02\x02\x02\u{279}\u{26b}\x03\x02\x02\x02\
	\u{279}\u{26c}\x03\x02\x02\x02\u{279}\u{26d}\x03\x02\x02\x02\u{279}\u{26e}\
	\x03\x02\x02\x02\u{279}\u{26f}\x03\x02\x02\x02\u{279}\u{270}\x03\x02\x02\
	\x02\u{279}\u{271}\x03\x02\x02\x02\u{279}\u{272}\x03\x02\x02\x02\u{279}\
	\u{273}\x03\x02\x02\x02\u{279}\u{274}\x03\x02\x02\x02\u{279}\u{275}\x03\
	\x02\x02\x02\u{279}\u{276}\x03\x02\x02\x02\u{279}\u{277}\x03\x02\x02\x02\
	\u{279}\u{278}\x03\x02\x02\x02\u{27a}\x0b\x03\x02\x02\x02\u{27b}\u{27c}\
	\x05\u{21a}\u{10e}\x02\u{27c}\u{27d}\x05\x16\x0c\x02\u{27d}\u{27e}\x05\u{1d4}\
	\u{eb}\x02\u{27e}\u{27f}\x05\x18\x0d\x02\u{27f}\u{280}\x05\u{198}\u{cd}\
	\x02\u{280}\u{281}\x05\u{142}\u{a2}\x02\u{281}\x0d\x03\x02\x02\x02\u{282}\
	\u{283}\x05\u{1c0}\u{e1}\x02\u{283}\u{284}\x05\u{20e}\u{108}\x02\u{284}\
	\x0f\x03\x02\x02\x02\u{285}\u{286}\x05\u{1c0}\u{e1}\x02\u{286}\u{28a}\x05\
	\u{1ea}\u{f6}\x02\u{287}\u{288}\x05\u{1d2}\u{ea}\x02\u{288}\u{289}\x05\u{142}\
	\u{a2}\x02\u{289}\u{28b}\x03\x02\x02\x02\u{28a}\u{287}\x03\x02\x02\x02\u{28a}\
	\u{28b}\x03\x02\x02\x02\u{28b}\u{28d}\x03\x02\x02\x02\u{28c}\u{28e}\x05\
	\u{1cc}\u{e7}\x02\u{28d}\u{28c}\x03\x02\x02\x02\u{28d}\u{28e}\x03\x02\x02\
	\x02\u{28e}\x11\x03\x02\x02\x02\u{28f}\u{290}\x05\u{1c0}\u{e1}\x02\u{290}\
	\u{294}\x05\x16\x0c\x02\u{291}\u{292}\x05\u{1d4}\u{eb}\x02\u{292}\u{293}\
	\x05\x18\x0d\x02\u{293}\u{295}\x03\x02\x02\x02\u{294}\u{291}\x03\x02\x02\
	\x02\u{294}\u{295}\x03\x02\x02\x02\u{295}\u{299}\x03\x02\x02\x02\u{296}\
	\u{297}\x05\u{1d2}\u{ea}\x02\u{297}\u{298}\x05\u{142}\u{a2}\x02\u{298}\u{29a}\
	\x03\x02\x02\x02\u{299}\u{296}\x03\x02\x02\x02\u{299}\u{29a}\x03\x02\x02\
	\x02\u{29a}\x13\x03\x02\x02\x02\u{29b}\u{29c}\x05\u{1a0}\u{d1}\x02\u{29c}\
	\u{29d}\x05\x16\x0c\x02\u{29d}\u{29e}\x05\u{1d4}\u{eb}\x02\u{29e}\u{29f}\
	\x05\x18\x0d\x02\u{29f}\u{2a0}\x05\u{1fc}\u{ff}\x02\u{2a0}\u{2a1}\x05\u{142}\
	\u{a2}\x02\u{2a1}\x15\x03\x02\x02\x02\u{2a2}\u{2a5}\x05\u{160}\u{b1}\x02\
	\u{2a3}\u{2a5}\x05\u{162}\u{b2}\x02\u{2a4}\u{2a2}\x03\x02\x02\x02\u{2a4}\
	\u{2a3}\x03\x02\x02\x02\u{2a5}\u{2af}\x03\x02\x02\x02\u{2a6}\u{2af}\x05\
	\u{166}\u{b4}\x02\u{2a7}\u{2af}\x05\u{170}\u{b9}\x02\u{2a8}\u{2af}\x05\u{186}\
	\u{c4}\x02\u{2a9}\u{2af}\x05\u{190}\u{c9}\x02\u{2aa}\u{2af}\x05\u{180}\u{c1}\
	\x02\u{2ab}\u{2af}\x05\u{18a}\u{c6}\x02\u{2ac}\u{2af}\x05\u{1c8}\u{e5}\x02\
	\u{2ad}\u{2af}\x05\u{1ec}\u{f7}\x02\u{2ae}\u{2a4}\x03\x02\x02\x02\u{2ae}\
	\u{2a6}\x03\x02\x02\x02\u{2ae}\u{2a7}\x03\x02\x02\x02\u{2ae}\u{2a8}\x03\
	\x02\x02\x02\u{2ae}\u{2a9}\x03\x02\x02\x02\u{2ae}\u{2aa}\x03\x02\x02\x02\
	\u{2ae}\u{2ab}\x03\x02\x02\x02\u{2ae}\u{2ac}\x03\x02\x02\x02\u{2ae}\u{2ad}\
	\x03\x02\x02\x02\u{2af}\x17\x03\x02\x02\x02\u{2b0}\u{2b1}\x05\u{160}\u{b1}\
	\x02\u{2b1}\u{2b2}\x05\u{19e}\u{d0}\x02\u{2b2}\u{2d7}\x03\x02\x02\x02\u{2b3}\
	\u{2b4}\x05\u{160}\u{b1}\x02\u{2b4}\u{2b5}\x05\u{19e}\u{d0}\x02\u{2b5}\u{2b6}\
	\x05\u{1a4}\u{d3}\x02\u{2b6}\u{2b7}\x05\u{1b8}\u{dd}\x02\u{2b7}\u{2b8}\x05\
	\u{134}\u{9b}\x02\u{2b8}\u{2d7}\x03\x02\x02\x02\u{2b9}\u{2bd}\x05\u{19c}\
	\u{cf}\x02\u{2ba}\u{2bb}\x05\u{134}\u{9b}\x02\u{2bb}\u{2bc}\x07\x10\x02\
	\x02\u{2bc}\u{2be}\x03\x02\x02\x02\u{2bd}\u{2ba}\x03\x02\x02\x02\u{2bd}\
	\u{2be}\x03\x02\x02\x02\u{2be}\u{2bf}\x03\x02\x02\x02\u{2bf}\u{2c0}\x05\
	\u{14e}\u{a8}\x02\u{2c0}\u{2d7}\x03\x02\x02\x02\u{2c1}\u{2c2}\x05\u{160}\
	\u{b1}\x02\u{2c2}\u{2c3}\x05\u{1ba}\u{de}\x02\u{2c3}\u{2d7}\x03\x02\x02\
	\x02\u{2c4}\u{2c5}\x05\u{1b8}\u{dd}\x02\u{2c5}\u{2c6}\x05\u{134}\u{9b}\x02\
	\u{2c6}\u{2d7}\x03\x02\x02\x02\u{2c7}\u{2c9}\x05\u{1f8}\u{fd}\x02\u{2c8}\
	\u{2c7}\x03\x02\x02\x02\u{2c8}\u{2c9}\x03\x02\x02\x02\u{2c9}\u{2cd}\x03\
	\x02\x02\x02\u{2ca}\u{2cb}\x05\u{134}\u{9b}\x02\u{2cb}\u{2cc}\x07\x10\x02\
	\x02\u{2cc}\u{2ce}\x03\x02\x02\x02\u{2cd}\u{2ca}\x03\x02\x02\x02\u{2cd}\
	\u{2ce}\x03\x02\x02\x02\u{2ce}\u{2cf}\x03\x02\x02\x02\u{2cf}\u{2d7}\x05\
	\u{136}\u{9c}\x02\u{2d0}\u{2d1}\x05\u{160}\u{b1}\x02\u{2d1}\u{2d2}\x05\u{1ea}\
	\u{f6}\x02\u{2d2}\u{2d7}\x03\x02\x02\x02\u{2d3}\u{2d4}\x05\u{1e8}\u{f5}\
	\x02\u{2d4}\u{2d5}\x05\u{142}\u{a2}\x02\u{2d5}\u{2d7}\x03\x02\x02\x02\u{2d6}\
	\u{2b0}\x03\x02\x02\x02\u{2d6}\u{2b3}\x03\x02\x02\x02\u{2d6}\u{2b9}\x03\
	\x02\x02\x02\u{2d6}\u{2c1}\x03\x02\x02\x02\u{2d6}\u{2c4}\x03\x02\x02\x02\
	\u{2d6}\u{2c8}\x03\x02\x02\x02\u{2d6}\u{2d0}\x03\x02\x02\x02\u{2d6}\u{2d3}\
	\x03\x02\x02\x02\u{2d7}\x19\x03\x02\x02\x02\u{2d8}\u{2d9}\x05\u{180}\u{c1}\
	\x02\u{2d9}\u{2db}\x05\u{20c}\u{107}\x02\u{2da}\u{2dc}\x05\u{f8}\x7d\x02\
	\u{2db}\u{2da}\x03\x02\x02\x02\u{2db}\u{2dc}\x03\x02\x02\x02\u{2dc}\u{2dd}\
	\x03\x02\x02\x02\u{2dd}\u{2de}\x05\u{152}\u{aa}\x02\u{2de}\u{2df}\x05\u{218}\
	\u{10d}\x02\u{2df}\u{2e0}\x05\u{1dc}\u{ef}\x02\u{2e0}\u{2e3}\x05\u{12e}\
	\u{98}\x02\u{2e1}\u{2e4}\x05\u{1f6}\u{fc}\x02\u{2e2}\u{2e4}\x05\u{1ca}\u{e6}\
	\x02\u{2e3}\u{2e1}\x03\x02\x02\x02\u{2e3}\u{2e2}\x03\x02\x02\x02\u{2e3}\
	\u{2e4}\x03\x02\x02\x02\u{2e4}\x1b\x03\x02\x02\x02\u{2e5}\u{2e6}\x05\u{180}\
	\u{c1}\x02\u{2e6}\u{2e8}\x05\u{1e8}\u{f5}\x02\u{2e7}\u{2e9}\x05\u{f8}\x7d\
	\x02\u{2e8}\u{2e7}\x03\x02\x02\x02\u{2e8}\u{2e9}\x03\x02\x02\x02\u{2e9}\
	\u{2ea}\x03\x02\x02\x02\u{2ea}\u{2ec}\x05\u{142}\u{a2}\x02\u{2eb}\u{2ed}\
	\x05\x6e\x38\x02\u{2ec}\u{2eb}\x03\x02\x02\x02\u{2ec}\u{2ed}\x03\x02\x02\
	\x02\u{2ed}\x1d\x03\x02\x02\x02\u{2ee}\u{2ef}\x05\u{180}\u{c1}\x02\u{2ef}\
	\u{2f1}\x05\u{204}\u{103}\x02\u{2f0}\u{2f2}\x05\u{f8}\x7d\x02\u{2f1}\u{2f0}\
	\x03\x02\x02\x02\u{2f1}\u{2f2}\x03\x02\x02\x02\u{2f2}\u{2f6}\x03\x02\x02\
	\x02\u{2f3}\u{2f4}\x05\u{134}\u{9b}\x02\u{2f4}\u{2f5}\x07\x10\x02\x02\u{2f5}\
	\u{2f7}\x03\x02\x02\x02\u{2f6}\u{2f3}\x03\x02\x02\x02\u{2f6}\u{2f7}\x03\
	\x02\x02\x02\u{2f7}\u{2f8}\x03\x02\x02\x02\u{2f8}\u{2f9}\x05\u{14a}\u{a6}\
	\x02\u{2f9}\u{2fa}\x05\u{21e}\u{110}\x02\u{2fa}\u{2fb}\x05\x20\x11\x02\u{2fb}\
	\u{2fc}\x05\u{220}\u{111}\x02\u{2fc}\x1f\x03\x02\x02\x02\u{2fd}\u{2fe}\x05\
	\u{138}\u{9d}\x02\u{2fe}\u{305}\x05\u{13a}\u{9e}\x02\u{2ff}\u{300}\x05\u{22e}\
	\u{118}\x02\u{300}\u{301}\x05\u{138}\u{9d}\x02\u{301}\u{302}\x05\u{13a}\
	\u{9e}\x02\u{302}\u{304}\x03\x02\x02\x02\u{303}\u{2ff}\x03\x02\x02\x02\u{304}\
	\u{307}\x03\x02\x02\x02\u{305}\u{303}\x03\x02\x02\x02\u{305}\u{306}\x03\
	\x02\x02\x02\u{306}\x21\x03\x02\x02\x02\u{307}\u{305}\x03\x02\x02\x02\u{308}\
	\u{309}\x05\u{180}\u{c1}\x02\u{309}\u{30b}\x05\u{1fe}\u{100}\x02\u{30a}\
	\u{30c}\x05\u{f8}\x7d\x02\u{30b}\u{30a}\x03\x02\x02\x02\u{30b}\u{30c}\x03\
	\x02\x02\x02\u{30c}\u{310}\x03\x02\x02\x02\u{30d}\u{30e}\x05\u{134}\u{9b}\
	\x02\u{30e}\u{30f}\x07\x10\x02\x02\u{30f}\u{311}\x03\x02\x02\x02\u{310}\
	\u{30d}\x03\x02\x02\x02\u{310}\u{311}\x03\x02\x02\x02\u{311}\u{312}\x03\
	\x02\x02\x02\u{312}\u{313}\x05\u{144}\u{a3}\x02\u{313}\u{314}\x05\u{210}\
	\u{109}\x02\u{314}\u{315}\x05\u{146}\u{a4}\x02\u{315}\x23\x03\x02\x02\x02\
	\u{316}\u{317}\x05\u{180}\u{c1}\x02\u{317}\u{318}\x05\u{1c6}\u{e4}\x02\u{318}\
	\u{31a}\x05\u{214}\u{10b}\x02\u{319}\u{31b}\x05\u{f8}\x7d\x02\u{31a}\u{319}\
	\x03\x02\x02\x02\u{31a}\u{31b}\x03\x02\x02\x02\u{31b}\u{31f}\x03\x02\x02\
	\x02\u{31c}\u{31d}\x05\u{134}\u{9b}\x02\u{31d}\u{31e}\x07\x10\x02\x02\u{31e}\
	\u{320}\x03\x02\x02\x02\u{31f}\u{31c}\x03\x02\x02\x02\u{31f}\u{320}\x03\
	\x02\x02\x02\u{320}\u{321}\x03\x02\x02\x02\u{321}\u{322}\x05\u{148}\u{a5}\
	\x02\u{322}\u{323}\x05\u{16c}\u{b7}\x02\u{323}\u{324}\x05\u{1ec}\u{f7}\x02\
	\u{324}\u{325}\x05\u{100}\u{81}\x02\u{325}\u{329}\x05\u{198}\u{cd}\x02\u{326}\
	\u{327}\x05\u{134}\u{9b}\x02\u{327}\u{328}\x07\x10\x02\x02\u{328}\u{32a}\
	\x03\x02\x02\x02\u{329}\u{326}\x03\x02\x02\x02\u{329}\u{32a}\x03\x02\x02\
	\x02\u{32a}\u{32b}\x03\x02\x02\x02\u{32b}\u{32c}\x05\u{136}\u{9c}\x02\u{32c}\
	\u{32d}\x05\x26\x14\x02\u{32d}\u{32e}\x05\u{1de}\u{f0}\x02\u{32e}\u{32f}\
	\x05\u{1b4}\u{db}\x02\u{32f}\u{330}\x05\u{21e}\u{110}\x02\u{330}\u{331}\
	\x05\u{100}\u{81}\x02\u{331}\u{335}\x05\u{220}\u{111}\x02\u{332}\u{333}\
	\x05\u{218}\u{10d}\x02\u{333}\u{334}\x05\x2c\x17\x02\u{334}\u{336}\x03\x02\
	\x02\x02\u{335}\u{332}\x03\x02\x02\x02\u{335}\u{336}\x03\x02\x02\x02\u{336}\
	\x25\x03\x02\x02\x02\u{337}\u{338}\x05\u{216}\u{10c}\x02\u{338}\u{33c}\x05\
	\x28\x15\x02\u{339}\u{33a}\x05\u{168}\u{b5}\x02\u{33a}\u{33b}\x05\u{11c}\
	\u{8f}\x02\u{33b}\u{33d}\x03\x02\x02\x02\u{33c}\u{339}\x03\x02\x02\x02\u{33c}\
	\u{33d}\x03\x02\x02\x02\u{33d}\x27\x03\x02\x02\x02\u{33e}\u{344}\x05\x2a\
	\x16\x02\u{33f}\u{340}\x05\u{168}\u{b5}\x02\u{340}\u{341}\x05\x2a\x16\x02\
	\u{341}\u{343}\x03\x02\x02\x02\u{342}\u{33f}\x03\x02\x02\x02\u{343}\u{346}\
	\x03\x02\x02\x02\u{344}\u{342}\x03\x02\x02\x02\u{344}\u{345}\x03\x02\x02\
	\x02\u{345}\x29\x03\x02\x02\x02\u{346}\u{344}\x03\x02\x02\x02\u{347}\u{348}\
	\x05\u{138}\u{9d}\x02\u{348}\u{349}\x05\u{1b0}\u{d9}\x02\u{349}\u{34a}\x05\
	\u{1ce}\u{e8}\x02\u{34a}\u{34b}\x05\u{1d0}\u{e9}\x02\u{34b}\x2b\x03\x02\
	\x02\x02\u{34c}\u{353}\x05\u{8e}\x48\x02\u{34d}\u{34e}\x05\u{8e}\x48\x02\
	\u{34e}\u{34f}\x05\u{168}\u{b5}\x02\u{34f}\u{350}\x05\u{8c}\x47\x02\u{350}\
	\u{353}\x03\x02\x02\x02\u{351}\u{353}\x05\u{8c}\x47\x02\u{352}\u{34c}\x03\
	\x02\x02\x02\u{352}\u{34d}\x03\x02\x02\x02\u{352}\u{351}\x03\x02\x02\x02\
	\u{353}\x2d\x03\x02\x02\x02\u{354}\u{355}\x05\u{180}\u{c1}\x02\u{355}\u{357}\
	\x05\u{1b8}\u{dd}\x02\u{356}\u{358}\x05\u{f8}\x7d\x02\u{357}\u{356}\x03\
	\x02\x02\x02\u{357}\u{358}\x03\x02\x02\x02\u{358}\u{359}\x03\x02\x02\x02\
	\u{359}\u{35a}\x05\u{134}\u{9b}\x02\u{35a}\u{35b}\x05\u{218}\u{10d}\x02\
	\u{35b}\u{35c}\x05\u{1e4}\u{f3}\x02\u{35c}\u{35d}\x07\u{ad}\x02\x02\u{35d}\
	\u{35e}\x05\u{222}\u{112}\x02\u{35e}\u{35f}\x05\u{be}\x60\x02\u{35f}\u{363}\
	\x05\u{224}\u{113}\x02\u{360}\u{361}\x05\u{168}\u{b5}\x02\u{361}\u{362}\
	\x05\u{c2}\x62\x02\u{362}\u{364}\x03\x02\x02\x02\u{363}\u{360}\x03\x02\x02\
	\x02\u{363}\u{364}\x03\x02\x02\x02\u{364}\x2f\x03\x02\x02\x02\u{365}\u{367}\
	\x05\u{180}\u{c1}\x02\u{366}\u{368}\x05\x44\x23\x02\u{367}\u{366}\x03\x02\
	\x02\x02\u{367}\u{368}\x03\x02\x02\x02\u{368}\u{369}\x03\x02\x02\x02\u{369}\
	\u{36b}\x05\u{19c}\u{cf}\x02\u{36a}\u{36c}\x05\u{f8}\x7d\x02\u{36b}\u{36a}\
	\x03\x02\x02\x02\u{36b}\u{36c}\x03\x02\x02\x02\u{36c}\u{370}\x03\x02\x02\
	\x02\u{36d}\u{36e}\x05\u{134}\u{9b}\x02\u{36e}\u{36f}\x07\x10\x02\x02\u{36f}\
	\u{371}\x03\x02\x02\x02\u{370}\u{36d}\x03\x02\x02\x02\u{370}\u{371}\x03\
	\x02\x02\x02\u{371}\u{372}\x03\x02\x02\x02\u{372}\u{373}\x05\u{14e}\u{a8}\
	\x02\u{373}\u{375}\x05\u{21e}\u{110}\x02\u{374}\u{376}\x05\x34\x1b\x02\u{375}\
	\u{374}\x03\x02\x02\x02\u{375}\u{376}\x03\x02\x02\x02\u{376}\u{377}\x03\
	\x02\x02\x02\u{377}\u{378}\x05\u{220}\u{111}\x02\u{378}\u{379}\x05\x36\x1c\
	\x02\u{379}\u{37a}\x05\u{1e6}\u{f4}\x02\u{37a}\u{37b}\x05\u{13a}\u{9e}\x02\
	\u{37b}\u{37c}\x05\u{1bc}\u{df}\x02\u{37c}\u{37d}\x05\u{150}\u{a9}\x02\u{37d}\
	\u{37e}\x05\u{16c}\u{b7}\x02\u{37e}\u{37f}\x05\x32\x1a\x02\u{37f}\x31\x03\
	\x02\x02\x02\u{380}\u{381}\x07\u{a5}\x02\x02\u{381}\x33\x03\x02\x02\x02\
	\u{382}\u{388}\x05\u{158}\u{ad}\x02\u{383}\u{384}\x05\u{22e}\u{118}\x02\
	\u{384}\u{385}\x05\u{158}\u{ad}\x02\u{385}\u{387}\x03\x02\x02\x02\u{386}\
	\u{383}\x03\x02\x02\x02\u{387}\u{38a}\x03\x02\x02\x02\u{388}\u{386}\x03\
	\x02\x02\x02\u{388}\u{389}\x03\x02\x02\x02\u{389}\x35\x03\x02\x02\x02\u{38a}\
	\u{388}\x03\x02\x02\x02\u{38b}\u{390}\x05\u{178}\u{bd}\x02\u{38c}\u{38d}\
	\x05\u{1e6}\u{f4}\x02\u{38d}\u{38e}\x05\u{1d0}\u{e9}\x02\u{38e}\u{390}\x03\
	\x02\x02\x02\u{38f}\u{38b}\x03\x02\x02\x02\u{38f}\u{38c}\x03\x02\x02\x02\
	\u{390}\u{391}\x03\x02\x02\x02\u{391}\u{392}\x05\u{1d4}\u{eb}\x02\u{392}\
	\u{393}\x05\u{1d0}\u{e9}\x02\u{393}\u{394}\x05\u{1aa}\u{d6}\x02\u{394}\x37\
	\x03\x02\x02\x02\u{395}\u{397}\x05\u{180}\u{c1}\x02\u{396}\u{398}\x05\x44\
	\x23\x02\u{397}\u{396}\x03\x02\x02\x02\u{397}\u{398}\x03\x02\x02\x02\u{398}\
	\u{399}\x03\x02\x02\x02\u{399}\u{39b}\x05\u{15e}\u{b0}\x02\u{39a}\u{39c}\
	\x05\u{f8}\x7d\x02\u{39b}\u{39a}\x03\x02\x02\x02\u{39b}\u{39c}\x03\x02\x02\
	\x02\u{39c}\u{3a0}\x03\x02\x02\x02\u{39d}\u{39e}\x05\u{134}\u{9b}\x02\u{39e}\
	\u{39f}\x07\x10\x02\x02\u{39f}\u{3a1}\x03\x02\x02\x02\u{3a0}\u{39d}\x03\
	\x02\x02\x02\u{3a0}\u{3a1}\x03\x02\x02\x02\u{3a1}\u{3a2}\x03\x02\x02\x02\
	\u{3a2}\u{3a3}\x05\u{14c}\u{a7}\x02\u{3a3}\u{3a4}\x05\u{21e}\u{110}\x02\
	\u{3a4}\u{3a5}\x05\u{13a}\u{9e}\x02\u{3a5}\u{3a6}\x05\u{220}\u{111}\x02\
	\u{3a6}\u{3a7}\x05\u{1f0}\u{f9}\x02\u{3a7}\u{3a8}\x05\u{14e}\u{a8}\x02\u{3a8}\
	\u{3a9}\x05\u{1f4}\u{fb}\x02\u{3a9}\u{3aa}\x05\u{13a}\u{9e}\x02\u{3aa}\u{3ab}\
	\x05\u{196}\u{cc}\x02\u{3ab}\u{3ac}\x05\u{14e}\u{a8}\x02\u{3ac}\u{3ad}\x05\
	\u{1a8}\u{d5}\x02\u{3ad}\u{3ae}\x05\x3a\x1e\x02\u{3ae}\x39\x03\x02\x02\x02\
	\u{3af}\u{3b4}\x05\u{128}\u{95}\x02\u{3b0}\u{3b4}\x05\x42\x22\x02\u{3b1}\
	\u{3b4}\x05\x40\x21\x02\u{3b2}\u{3b4}\x05\x3c\x1f\x02\u{3b3}\u{3af}\x03\
	\x02\x02\x02\u{3b3}\u{3b0}\x03\x02\x02\x02\u{3b3}\u{3b1}\x03\x02\x02\x02\
	\u{3b3}\u{3b2}\x03\x02\x02\x02\u{3b4}\x3b\x03\x02\x02\x02\u{3b5}\u{3b6}\
	\x05\u{222}\u{112}\x02\u{3b6}\u{3bc}\x05\x3e\x20\x02\u{3b7}\u{3b8}\x05\u{22e}\
	\u{118}\x02\u{3b8}\u{3b9}\x05\x3e\x20\x02\u{3b9}\u{3bb}\x03\x02\x02\x02\
	\u{3ba}\u{3b7}\x03\x02\x02\x02\u{3bb}\u{3be}\x03\x02\x02\x02\u{3bc}\u{3ba}\
	\x03\x02\x02\x02\u{3bc}\u{3bd}\x03\x02\x02\x02\u{3bd}\u{3bf}\x03\x02\x02\
	\x02\u{3be}\u{3bc}\x03\x02\x02\x02\u{3bf}\u{3c0}\x05\u{224}\u{113}\x02\u{3c0}\
	\x3d\x03\x02\x02\x02\u{3c1}\u{3c2}\x05\u{156}\u{ac}\x02\u{3c2}\u{3c3}\x07\
	\x0b\x02\x02\u{3c3}\u{3c4}\x05\x3a\x1e\x02\u{3c4}\x3f\x03\x02\x02\x02\u{3c5}\
	\u{3c6}\x05\u{21e}\u{110}\x02\u{3c6}\u{3cd}\x05\x42\x22\x02\u{3c7}\u{3c8}\
	\x05\u{22e}\u{118}\x02\u{3c8}\u{3c9}\x05\u{128}\u{95}\x02\u{3c9}\u{3cc}\
	\x03\x02\x02\x02\u{3ca}\u{3cc}\x05\x42\x22\x02\u{3cb}\u{3c7}\x03\x02\x02\
	\x02\u{3cb}\u{3ca}\x03\x02\x02\x02\u{3cc}\u{3cf}\x03\x02\x02\x02\u{3cd}\
	\u{3cb}\x03\x02\x02\x02\u{3cd}\u{3ce}\x03\x02\x02\x02\u{3ce}\u{3d0}\x03\
	\x02\x02\x02\u{3cf}\u{3cd}\x03\x02\x02\x02\u{3d0}\u{3d1}\x05\u{220}\u{111}\
	\x02\u{3d1}\x41\x03\x02\x02\x02\u{3d2}\u{3d3}\x05\u{21e}\u{110}\x02\u{3d3}\
	\u{3d9}\x05\u{128}\u{95}\x02\u{3d4}\u{3d5}\x05\u{22e}\u{118}\x02\u{3d5}\
	\u{3d6}\x05\u{128}\u{95}\x02\u{3d6}\u{3d8}\x03\x02\x02\x02\u{3d7}\u{3d4}\
	\x03\x02\x02\x02\u{3d8}\u{3db}\x03\x02\x02\x02\u{3d9}\u{3d7}\x03\x02\x02\
	\x02\u{3d9}\u{3da}\x03\x02\x02\x02\u{3da}\u{3dc}\x03\x02\x02\x02\u{3db}\
	\u{3d9}\x03\x02\x02\x02\u{3dc}\u{3dd}\x05\u{220}\u{111}\x02\u{3dd}\x43\x03\
	\x02\x02\x02\u{3de}\u{3df}\x05\u{1d8}\u{ed}\x02\u{3df}\u{3e0}\x05\u{1e2}\
	\u{f2}\x02\u{3e0}\x45\x03\x02\x02\x02\u{3e1}\u{3e2}\x05\u{166}\u{b4}\x02\
	\u{3e2}\u{3e3}\x05\u{20c}\u{107}\x02\u{3e3}\u{3e4}\x05\u{152}\u{aa}\x02\
	\u{3e4}\u{3e5}\x05\u{218}\u{10d}\x02\u{3e5}\u{3e7}\x05\x48\x25\x02\u{3e6}\
	\u{3e8}\x05\x4a\x26\x02\u{3e7}\u{3e6}\x03\x02\x02\x02\u{3e7}\u{3e8}\x03\
	\x02\x02\x02\u{3e8}\x47\x03\x02\x02\x02\u{3e9}\u{3ea}\x05\u{1dc}\u{ef}\x02\
	\u{3ea}\u{3eb}\x05\u{12e}\u{98}\x02\u{3eb}\x49\x03\x02\x02\x02\u{3ec}\u{3ef}\
	\x05\u{1f6}\u{fc}\x02\u{3ed}\u{3ef}\x05\u{1ca}\u{e6}\x02\u{3ee}\u{3ec}\x03\
	\x02\x02\x02\u{3ee}\u{3ed}\x03\x02\x02\x02\u{3ef}\x4b\x03\x02\x02\x02\u{3f0}\
	\u{3f1}\x05\u{166}\u{b4}\x02\u{3f1}\u{3f5}\x05\u{204}\u{103}\x02\u{3f2}\
	\u{3f3}\x05\u{134}\u{9b}\x02\u{3f3}\u{3f4}\x07\x10\x02\x02\u{3f4}\u{3f6}\
	\x03\x02\x02\x02\u{3f5}\u{3f2}\x03\x02\x02\x02\u{3f5}\u{3f6}\x03\x02\x02\
	\x02\u{3f6}\u{3f7}\x03\x02\x02\x02\u{3f7}\u{3f8}\x05\u{14a}\u{a6}\x02\u{3f8}\
	\u{3f9}\x05\x4e\x28\x02\u{3f9}\x4d\x03\x02\x02\x02\u{3fa}\u{3fe}\x05\x58\
	\x2d\x02\u{3fb}\u{3fe}\x05\x56\x2c\x02\u{3fc}\u{3fe}\x05\x50\x29\x02\u{3fd}\
	\u{3fa}\x03\x02\x02\x02\u{3fd}\u{3fb}\x03\x02\x02\x02\u{3fd}\u{3fc}\x03\
	\x02\x02\x02\u{3fe}\x4f\x03\x02\x02\x02\u{3ff}\u{400}\x05\u{1e0}\u{f1}\x02\
	\u{400}\u{401}\x05\x52\x2a\x02\u{401}\x51\x03\x02\x02\x02\u{402}\u{408}\
	\x05\x54\x2b\x02\u{403}\u{404}\x05\u{168}\u{b5}\x02\u{404}\u{405}\x05\x54\
	\x2b\x02\u{405}\u{407}\x03\x02\x02\x02\u{406}\u{403}\x03\x02\x02\x02\u{407}\
	\u{40a}\x03\x02\x02\x02\u{408}\u{406}\x03\x02\x02\x02\u{408}\u{409}\x03\
	\x02\x02\x02\u{409}\x53\x03\x02\x02\x02\u{40a}\u{408}\x03\x02\x02\x02\u{40b}\
	\u{40c}\x05\u{138}\u{9d}\x02\u{40c}\u{40d}\x05\u{1fc}\u{ff}\x02\u{40d}\u{40e}\
	\x05\u{138}\u{9d}\x02\u{40e}\x55\x03\x02\x02\x02\u{40f}\u{410}\x05\u{15c}\
	\u{af}\x02\u{410}\u{411}\x05\u{138}\u{9d}\x02\u{411}\u{418}\x05\u{13a}\u{9e}\
	\x02\u{412}\u{413}\x05\u{22e}\u{118}\x02\u{413}\u{414}\x05\u{138}\u{9d}\
	\x02\u{414}\u{415}\x05\u{13a}\u{9e}\x02\u{415}\u{417}\x03\x02\x02\x02\u{416}\
	\u{412}\x03\x02\x02\x02\u{417}\u{41a}\x03\x02\x02\x02\u{418}\u{416}\x03\
	\x02\x02\x02\u{418}\u{419}\x03\x02\x02\x02\u{419}\x57\x03\x02\x02\x02\u{41a}\
	\u{418}\x03\x02\x02\x02\u{41b}\u{41c}\x05\u{166}\u{b4}\x02\u{41c}\u{41d}\
	\x05\u{138}\u{9d}\x02\u{41d}\u{41e}\x05\u{204}\u{103}\x02\u{41e}\u{41f}\
	\x05\u{13a}\u{9e}\x02\u{41f}\x59\x03\x02\x02\x02\u{420}\u{421}\x05\u{166}\
	\u{b4}\x02\u{421}\u{425}\x05\u{1f8}\u{fd}\x02\u{422}\u{423}\x05\u{134}\u{9b}\
	\x02\u{423}\u{424}\x07\x10\x02\x02\u{424}\u{426}\x03\x02\x02\x02\u{425}\
	\u{422}\x03\x02\x02\x02\u{425}\u{426}\x03\x02\x02\x02\u{426}\u{427}\x03\
	\x02\x02\x02\u{427}\u{428}\x05\u{136}\u{9c}\x02\u{428}\u{429}\x05\x5c\x2f\
	\x02\u{429}\x5b\x03\x02\x02\x02\u{42a}\u{431}\x05\x68\x35\x02\u{42b}\u{431}\
	\x05\x64\x33\x02\u{42c}\u{431}\x05\x64\x33\x02\u{42d}\u{431}\x05\x62\x32\
	\x02\u{42e}\u{431}\x05\x60\x31\x02\u{42f}\u{431}\x05\x5e\x30\x02\u{430}\
	\u{42a}\x03\x02\x02\x02\u{430}\u{42b}\x03\x02\x02\x02\u{430}\u{42c}\x03\
	\x02\x02\x02\u{430}\u{42d}\x03\x02\x02\x02\u{430}\u{42e}\x03\x02\x02\x02\
	\u{430}\u{42f}\x03\x02\x02\x02\u{431}\x5d\x03\x02\x02\x02\u{432}\u{433}\
	\x05\u{218}\u{10d}\x02\u{433}\u{434}\x05\u{8e}\x48\x02\u{434}\x5f\x03\x02\
	\x02\x02\u{435}\u{436}\x05\u{1e0}\u{f1}\x02\u{436}\u{437}\x05\u{138}\u{9d}\
	\x02\u{437}\u{438}\x05\u{1fc}\u{ff}\x02\u{438}\u{439}\x05\u{138}\u{9d}\x02\
	\u{439}\x61\x03\x02\x02\x02\u{43a}\u{43b}\x05\u{18a}\u{c6}\x02\u{43b}\u{43c}\
	\x05\u{17c}\u{bf}\x02\u{43c}\u{43d}\x05\u{1f2}\u{fa}\x02\u{43d}\x63\x03\
	\x02\x02\x02\u{43e}\u{43f}\x05\u{18a}\u{c6}\x02\u{43f}\u{440}\x05\x66\x34\
	\x02\u{440}\x65\x03\x02\x02\x02\u{441}\u{447}\x05\u{138}\u{9d}\x02\u{442}\
	\u{443}\x05\u{22e}\u{118}\x02\u{443}\u{444}\x05\u{138}\u{9d}\x02\u{444}\
	\u{446}\x03\x02\x02\x02\u{445}\u{442}\x03\x02\x02\x02\u{446}\u{449}\x03\
	\x02\x02\x02\u{447}\u{445}\x03\x02\x02\x02\u{447}\u{448}\x03\x02\x02\x02\
	\u{448}\x67\x03\x02\x02\x02\u{449}\u{447}\x03\x02\x02\x02\u{44a}\u{44b}\
	\x05\u{15c}\u{af}\x02\u{44b}\u{44c}\x05\x6a\x36\x02\u{44c}\x69\x03\x02\x02\
	\x02\u{44d}\u{44e}\x05\u{138}\u{9d}\x02\u{44e}\u{455}\x05\u{13a}\u{9e}\x02\
	\u{44f}\u{450}\x05\u{22e}\u{118}\x02\u{450}\u{451}\x05\u{138}\u{9d}\x02\
	\u{451}\u{452}\x05\u{13a}\u{9e}\x02\u{452}\u{454}\x03\x02\x02\x02\u{453}\
	\u{44f}\x03\x02\x02\x02\u{454}\u{457}\x03\x02\x02\x02\u{455}\u{453}\x03\
	\x02\x02\x02\u{455}\u{456}\x03\x02\x02\x02\u{456}\x6b\x03\x02\x02\x02\u{457}\
	\u{455}\x03\x02\x02\x02\u{458}\u{459}\x05\u{166}\u{b4}\x02\u{459}\u{45a}\
	\x05\u{1e8}\u{f5}\x02\u{45a}\u{45c}\x05\u{142}\u{a2}\x02\u{45b}\u{45d}\x05\
	\x6e\x38\x02\u{45c}\u{45b}\x03\x02\x02\x02\u{45c}\u{45d}\x03\x02\x02\x02\
	\u{45d}\x6d\x03\x02\x02\x02\u{45e}\u{45f}\x05\u{218}\u{10d}\x02\u{45f}\u{465}\
	\x05\x70\x39\x02\u{460}\u{461}\x05\u{168}\u{b5}\x02\u{461}\u{462}\x05\x70\
	\x39\x02\u{462}\u{464}\x03\x02\x02\x02\u{463}\u{460}\x03\x02\x02\x02\u{464}\
	\u{467}\x03\x02\x02\x02\u{465}\u{463}\x03\x02\x02\x02\u{465}\u{466}\x03\
	\x02\x02\x02\u{466}\x6f\x03\x02\x02\x02\u{467}\u{465}\x03\x02\x02\x02\u{468}\
	\u{469}\x05\u{1dc}\u{ef}\x02\u{469}\u{46a}\x07\u{ad}\x02\x02\u{46a}\u{46b}\
	\x05\u{12e}\u{98}\x02\u{46b}\u{479}\x03\x02\x02\x02\u{46c}\u{46d}\x05\u{1c4}\
	\u{e3}\x02\u{46d}\u{46e}\x07\u{ad}\x02\x02\u{46e}\u{46f}\x05\u{130}\u{99}\
	\x02\u{46f}\u{479}\x03\x02\x02\x02\u{470}\u{471}\x05\u{1f6}\u{fc}\x02\u{471}\
	\u{472}\x07\u{ad}\x02\x02\u{472}\u{473}\x05\u{130}\u{99}\x02\u{473}\u{479}\
	\x03\x02\x02\x02\u{474}\u{475}\x05\u{1d6}\u{ec}\x02\u{475}\u{476}\x07\u{ad}\
	\x02\x02\u{476}\u{477}\x05\u{96}\x4c\x02\u{477}\u{479}\x03\x02\x02\x02\u{478}\
	\u{468}\x03\x02\x02\x02\u{478}\u{46c}\x03\x02\x02\x02\u{478}\u{470}\x03\
	\x02\x02\x02\u{478}\u{474}\x03\x02\x02\x02\u{479}\x71\x03\x02\x02\x02\u{47a}\
	\u{47b}\x05\u{166}\u{b4}\x02\u{47b}\u{47c}\x05\u{1c6}\u{e4}\x02\u{47c}\u{480}\
	\x05\u{214}\u{10b}\x02\u{47d}\u{47e}\x05\u{134}\u{9b}\x02\u{47e}\u{47f}\
	\x07\x10\x02\x02\u{47f}\u{481}\x03\x02\x02\x02\u{480}\u{47d}\x03\x02\x02\
	\x02\u{480}\u{481}\x03\x02\x02\x02\u{481}\u{482}\x03\x02\x02\x02\u{482}\
	\u{486}\x05\u{148}\u{a5}\x02\u{483}\u{484}\x05\u{218}\u{10d}\x02\u{484}\
	\u{485}\x05\u{8e}\x48\x02\u{485}\u{487}\x03\x02\x02\x02\u{486}\u{483}\x03\
	\x02\x02\x02\u{486}\u{487}\x03\x02\x02\x02\u{487}\x73\x03\x02\x02\x02\u{488}\
	\u{489}\x05\u{18a}\u{c6}\x02\u{489}\u{48b}\x05\u{20c}\u{107}\x02\u{48a}\
	\u{48c}\x05\u{fa}\x7e\x02\u{48b}\u{48a}\x03\x02\x02\x02\u{48b}\u{48c}\x03\
	\x02\x02\x02\u{48c}\u{48d}\x03\x02\x02\x02\u{48d}\u{48e}\x05\u{152}\u{aa}\
	\x02\u{48e}\x75\x03\x02\x02\x02\u{48f}\u{490}\x05\u{18a}\u{c6}\x02\u{490}\
	\u{492}\x05\u{204}\u{103}\x02\u{491}\u{493}\x05\u{fa}\x7e\x02\u{492}\u{491}\
	\x03\x02\x02\x02\u{492}\u{493}\x03\x02\x02\x02\u{493}\u{497}\x03\x02\x02\
	\x02\u{494}\u{495}\x05\u{134}\u{9b}\x02\u{495}\u{496}\x07\x10\x02\x02\u{496}\
	\u{498}\x03\x02\x02\x02\u{497}\u{494}\x03\x02\x02\x02\u{497}\u{498}\x03\
	\x02\x02\x02\u{498}\u{499}\x03\x02\x02\x02\u{499}\u{49a}\x05\u{14a}\u{a6}\
	\x02\u{49a}\x77\x03\x02\x02\x02\u{49b}\u{49c}\x05\u{18a}\u{c6}\x02\u{49c}\
	\u{49d}\x05\u{1c6}\u{e4}\x02\u{49d}\u{49f}\x05\u{214}\u{10b}\x02\u{49e}\
	\u{4a0}\x05\u{fa}\x7e\x02\u{49f}\u{49e}\x03\x02\x02\x02\u{49f}\u{4a0}\x03\
	\x02\x02\x02\u{4a0}\u{4a4}\x03\x02\x02\x02\u{4a1}\u{4a2}\x05\u{134}\u{9b}\
	\x02\u{4a2}\u{4a3}\x07\x10\x02\x02\u{4a3}\u{4a5}\x03\x02\x02\x02\u{4a4}\
	\u{4a1}\x03\x02\x02\x02\u{4a4}\u{4a5}\x03\x02\x02\x02\u{4a5}\u{4a6}\x03\
	\x02\x02\x02\u{4a6}\u{4a7}\x05\u{148}\u{a5}\x02\u{4a7}\x79\x03\x02\x02\x02\
	\u{4a8}\u{4a9}\x05\u{18a}\u{c6}\x02\u{4a9}\u{4ab}\x05\u{15e}\u{b0}\x02\u{4aa}\
	\u{4ac}\x05\u{fa}\x7e\x02\u{4ab}\u{4aa}\x03\x02\x02\x02\u{4ab}\u{4ac}\x03\
	\x02\x02\x02\u{4ac}\u{4b0}\x03\x02\x02\x02\u{4ad}\u{4ae}\x05\u{134}\u{9b}\
	\x02\u{4ae}\u{4af}\x07\x10\x02\x02\u{4af}\u{4b1}\x03\x02\x02\x02\u{4b0}\
	\u{4ad}\x03\x02\x02\x02\u{4b0}\u{4b1}\x03\x02\x02\x02\u{4b1}\u{4b2}\x03\
	\x02\x02\x02\u{4b2}\u{4b3}\x05\u{14c}\u{a7}\x02\u{4b3}\x7b\x03\x02\x02\x02\
	\u{4b4}\u{4b5}\x05\u{18a}\u{c6}\x02\u{4b5}\u{4b7}\x05\u{19c}\u{cf}\x02\u{4b6}\
	\u{4b8}\x05\u{fa}\x7e\x02\u{4b7}\u{4b6}\x03\x02\x02\x02\u{4b7}\u{4b8}\x03\
	\x02\x02\x02\u{4b8}\u{4bc}\x03\x02\x02\x02\u{4b9}\u{4ba}\x05\u{134}\u{9b}\
	\x02\u{4ba}\u{4bb}\x07\x10\x02\x02\u{4bb}\u{4bd}\x03\x02\x02\x02\u{4bc}\
	\u{4b9}\x03\x02\x02\x02\u{4bc}\u{4bd}\x03\x02\x02\x02\u{4bd}\u{4be}\x03\
	\x02\x02\x02\u{4be}\u{4bf}\x05\u{14e}\u{a8}\x02\u{4bf}\x7d\x03\x02\x02\x02\
	\u{4c0}\u{4c1}\x05\u{18a}\u{c6}\x02\u{4c1}\u{4c3}\x05\u{1fe}\u{100}\x02\
	\u{4c2}\u{4c4}\x05\u{fa}\x7e\x02\u{4c3}\u{4c2}\x03\x02\x02\x02\u{4c3}\u{4c4}\
	\x03\x02\x02\x02\u{4c4}\u{4c5}\x03\x02\x02\x02\u{4c5}\u{4c6}\x05\u{144}\
	\u{a3}\x02\u{4c6}\u{4ca}\x05\u{1d4}\u{eb}\x02\u{4c7}\u{4c8}\x05\u{134}\u{9b}\
	\x02\u{4c8}\u{4c9}\x07\x10\x02\x02\u{4c9}\u{4cb}\x03\x02\x02\x02\u{4ca}\
	\u{4c7}\x03\x02\x02\x02\u{4ca}\u{4cb}\x03\x02\x02\x02\u{4cb}\u{4cc}\x03\
	\x02\x02\x02\u{4cc}\u{4cd}\x05\u{136}\u{9c}\x02\u{4cd}\x7f\x03\x02\x02\x02\
	\u{4ce}\u{4cf}\x05\u{18a}\u{c6}\x02\u{4cf}\u{4d1}\x05\u{1e8}\u{f5}\x02\u{4d0}\
	\u{4d2}\x05\u{fa}\x7e\x02\u{4d1}\u{4d0}\x03\x02\x02\x02\u{4d1}\u{4d2}\x03\
	\x02\x02\x02\u{4d2}\u{4d3}\x03\x02\x02\x02\u{4d3}\u{4d4}\x05\u{142}\u{a2}\
	\x02\u{4d4}\u{81}\x03\x02\x02\x02\u{4d5}\u{4d6}\x05\u{18a}\u{c6}\x02\u{4d6}\
	\u{4d8}\x05\u{1f8}\u{fd}\x02\u{4d7}\u{4d9}\x05\u{fa}\x7e\x02\u{4d8}\u{4d7}\
	\x03\x02\x02\x02\u{4d8}\u{4d9}\x03\x02\x02\x02\u{4d9}\u{4dd}\x03\x02\x02\
	\x02\u{4da}\u{4db}\x05\u{134}\u{9b}\x02\u{4db}\u{4dc}\x07\x10\x02\x02\u{4dc}\
	\u{4de}\x03\x02\x02\x02\u{4dd}\u{4da}\x03\x02\x02\x02\u{4dd}\u{4de}\x03\
	\x02\x02\x02\u{4de}\u{4df}\x03\x02\x02\x02\u{4df}\u{4e0}\x05\u{136}\u{9c}\
	\x02\u{4e0}\u{83}\x03\x02\x02\x02\u{4e1}\u{4e2}\x05\u{18a}\u{c6}\x02\u{4e2}\
	\u{4e4}\x05\u{1b8}\u{dd}\x02\u{4e3}\u{4e5}\x05\u{fa}\x7e\x02\u{4e4}\u{4e3}\
	\x03\x02\x02\x02\u{4e4}\u{4e5}\x03\x02\x02\x02\u{4e5}\u{4e6}\x03\x02\x02\
	\x02\u{4e6}\u{4e7}\x05\u{134}\u{9b}\x02\u{4e7}\u{85}\x03\x02\x02\x02\u{4e8}\
	\u{4e9}\x05\u{18a}\u{c6}\x02\u{4e9}\u{4eb}\x05\u{1a6}\u{d4}\x02\u{4ea}\u{4ec}\
	\x05\u{fa}\x7e\x02\u{4eb}\u{4ea}\x03\x02\x02\x02\u{4eb}\u{4ec}\x03\x02\x02\
	\x02\u{4ec}\u{4f0}\x03\x02\x02\x02\u{4ed}\u{4ee}\x05\u{134}\u{9b}\x02\u{4ee}\
	\u{4ef}\x07\x10\x02\x02\u{4ef}\u{4f1}\x03\x02\x02\x02\u{4f0}\u{4ed}\x03\
	\x02\x02\x02\u{4f0}\u{4f1}\x03\x02\x02\x02\u{4f1}\u{4f2}\x03\x02\x02\x02\
	\u{4f2}\u{4f3}\x05\u{ca}\x66\x02\u{4f3}\u{87}\x03\x02\x02\x02\u{4f4}\u{4f5}\
	\x05\u{180}\u{c1}\x02\u{4f5}\u{4f7}\x05\u{1f8}\u{fd}\x02\u{4f6}\u{4f8}\x05\
	\u{f8}\x7d\x02\u{4f7}\u{4f6}\x03\x02\x02\x02\u{4f7}\u{4f8}\x03\x02\x02\x02\
	\u{4f8}\u{4fc}\x03\x02\x02\x02\u{4f9}\u{4fa}\x05\u{134}\u{9b}\x02\u{4fa}\
	\u{4fb}\x07\x10\x02\x02\u{4fb}\u{4fd}\x03\x02\x02\x02\u{4fc}\u{4f9}\x03\
	\x02\x02\x02\u{4fc}\u{4fd}\x03\x02\x02\x02\u{4fd}\u{4fe}\x03\x02\x02\x02\
	\u{4fe}\u{4ff}\x05\u{136}\u{9c}\x02\u{4ff}\u{500}\x05\u{21e}\u{110}\x02\
	\u{500}\u{501}\x05\u{9e}\x50\x02\u{501}\u{503}\x05\u{220}\u{111}\x02\u{502}\
	\u{504}\x05\u{8a}\x46\x02\u{503}\u{502}\x03\x02\x02\x02\u{503}\u{504}\x03\
	\x02\x02\x02\u{504}\u{89}\x03\x02\x02\x02\u{505}\u{507}\x05\u{218}\u{10d}\
	\x02\u{506}\u{508}\x05\u{8e}\x48\x02\u{507}\u{506}\x03\x02\x02\x02\u{507}\
	\u{508}\x03\x02\x02\x02\u{508}\u{50a}\x03\x02\x02\x02\u{509}\u{50b}\x05\
	\u{8c}\x47\x02\u{50a}\u{509}\x03\x02\x02\x02\u{50a}\u{50b}\x03\x02\x02\x02\
	\u{50b}\u{8b}\x03\x02\x02\x02\u{50c}\u{50d}\x05\u{17a}\u{be}\x02\u{50d}\
	\u{50e}\x05\u{1da}\u{ee}\x02\u{50e}\u{50f}\x05\u{176}\u{bc}\x02\u{50f}\u{510}\
	\x05\u{21e}\u{110}\x02\u{510}\u{512}\x05\u{138}\u{9d}\x02\u{511}\u{513}\
	\x05\u{140}\u{a1}\x02\u{512}\u{511}\x03\x02\x02\x02\u{512}\u{513}\x03\x02\
	\x02\x02\u{513}\u{514}\x03\x02\x02\x02\u{514}\u{515}\x05\u{220}\u{111}\x02\
	\u{515}\u{8d}\x03\x02\x02\x02\u{516}\u{51c}\x05\u{90}\x49\x02\u{517}\u{518}\
	\x05\u{168}\u{b5}\x02\u{518}\u{519}\x05\u{90}\x49\x02\u{519}\u{51b}\x03\
	\x02\x02\x02\u{51a}\u{517}\x03\x02\x02\x02\u{51b}\u{51e}\x03\x02\x02\x02\
	\u{51c}\u{51a}\x03\x02\x02\x02\u{51c}\u{51d}\x03\x02\x02\x02\u{51d}\u{8f}\
	\x03\x02\x02\x02\u{51e}\u{51c}\x03\x02\x02\x02\u{51f}\u{520}\x05\u{92}\x4a\
	\x02\u{520}\u{521}\x07\u{ad}\x02\x02\u{521}\u{522}\x05\u{94}\x4b\x02\u{522}\
	\u{528}\x03\x02\x02\x02\u{523}\u{524}\x05\u{92}\x4a\x02\u{524}\u{525}\x07\
	\u{ad}\x02\x02\u{525}\u{526}\x05\u{96}\x4c\x02\u{526}\u{528}\x03\x02\x02\
	\x02\u{527}\u{51f}\x03\x02\x02\x02\u{527}\u{523}\x03\x02\x02\x02\u{528}\
	\u{91}\x03\x02\x02\x02\u{529}\u{52a}\x07\u{ab}\x02\x02\u{52a}\u{93}\x03\
	\x02\x02\x02\u{52b}\u{52e}\x05\u{12e}\u{98}\x02\u{52c}\u{52e}\x05\u{12c}\
	\u{97}\x02\u{52d}\u{52b}\x03\x02\x02\x02\u{52d}\u{52c}\x03\x02\x02\x02\u{52e}\
	\u{95}\x03\x02\x02\x02\u{52f}\u{530}\x05\u{222}\u{112}\x02\u{530}\u{536}\
	\x05\u{98}\x4d\x02\u{531}\u{532}\x05\u{22e}\u{118}\x02\u{532}\u{533}\x05\
	\u{98}\x4d\x02\u{533}\u{535}\x03\x02\x02\x02\u{534}\u{531}\x03\x02\x02\x02\
	\u{535}\u{538}\x03\x02\x02\x02\u{536}\u{534}\x03\x02\x02\x02\u{536}\u{537}\
	\x03\x02\x02\x02\u{537}\u{539}\x03\x02\x02\x02\u{538}\u{536}\x03\x02\x02\
	\x02\u{539}\u{53a}\x05\u{224}\u{113}\x02\u{53a}\u{97}\x03\x02\x02\x02\u{53b}\
	\u{53c}\x05\u{9a}\x4e\x02\u{53c}\u{53d}\x07\x0b\x02\x02\u{53d}\u{53e}\x05\
	\u{9c}\x4f\x02\u{53e}\u{99}\x03\x02\x02\x02\u{53f}\u{540}\x05\u{12e}\u{98}\
	\x02\u{540}\u{9b}\x03\x02\x02\x02\u{541}\u{544}\x05\u{12e}\u{98}\x02\u{542}\
	\u{544}\x05\u{12c}\u{97}\x02\u{543}\u{541}\x03\x02\x02\x02\u{543}\u{542}\
	\x03\x02\x02\x02\u{544}\u{9d}\x03\x02\x02\x02\u{545}\u{54b}\x05\u{a0}\x51\
	\x02\u{546}\u{547}\x05\u{22e}\u{118}\x02\u{547}\u{548}\x05\u{a0}\x51\x02\
	\u{548}\u{54a}\x03\x02\x02\x02\u{549}\u{546}\x03\x02\x02\x02\u{54a}\u{54d}\
	\x03\x02\x02\x02\u{54b}\u{549}\x03\x02\x02\x02\u{54b}\u{54c}\x03\x02\x02\
	\x02\u{54c}\u{551}\x03\x02\x02\x02\u{54d}\u{54b}\x03\x02\x02\x02\u{54e}\
	\u{54f}\x05\u{22e}\u{118}\x02\u{54f}\u{550}\x05\u{a4}\x53\x02\u{550}\u{552}\
	\x03\x02\x02\x02\u{551}\u{54e}\x03\x02\x02\x02\u{551}\u{552}\x03\x02\x02\
	\x02\u{552}\u{9f}\x03\x02\x02\x02\u{553}\u{554}\x05\u{138}\u{9d}\x02\u{554}\
	\u{556}\x05\u{13a}\u{9e}\x02\u{555}\u{557}\x05\u{a2}\x52\x02\u{556}\u{555}\
	\x03\x02\x02\x02\u{556}\u{557}\x03\x02\x02\x02\u{557}\u{a1}\x03\x02\x02\
	\x02\u{558}\u{559}\x05\u{1de}\u{f0}\x02\u{559}\u{55a}\x05\u{1b4}\u{db}\x02\
	\u{55a}\u{a3}\x03\x02\x02\x02\u{55b}\u{55c}\x05\u{1de}\u{f0}\x02\u{55c}\
	\u{55d}\x05\u{1b4}\u{db}\x02\u{55d}\u{55e}\x05\u{21e}\u{110}\x02\u{55e}\
	\u{55f}\x05\u{a6}\x54\x02\u{55f}\u{560}\x05\u{220}\u{111}\x02\u{560}\u{a5}\
	\x03\x02\x02\x02\u{561}\u{565}\x05\u{a8}\x55\x02\u{562}\u{565}\x05\u{aa}\
	\x56\x02\u{563}\u{565}\x05\u{ac}\x57\x02\u{564}\u{561}\x03\x02\x02\x02\u{564}\
	\u{562}\x03\x02\x02\x02\u{564}\u{563}\x03\x02\x02\x02\u{565}\u{a7}\x03\x02\
	\x02\x02\u{566}\u{567}\x05\u{138}\u{9d}\x02\u{567}\u{a9}\x03\x02\x02\x02\
	\u{568}\u{569}\x05\u{b2}\x5a\x02\u{569}\u{56a}\x05\u{22e}\u{118}\x02\u{56a}\
	\u{56b}\x05\u{b0}\x59\x02\u{56b}\u{ab}\x03\x02\x02\x02\u{56c}\u{56d}\x05\
	\u{21e}\u{110}\x02\u{56d}\u{56e}\x05\u{ae}\x58\x02\u{56e}\u{56f}\x05\u{220}\
	\u{111}\x02\u{56f}\u{570}\x05\u{22e}\u{118}\x02\u{570}\u{571}\x05\u{b0}\
	\x59\x02\u{571}\u{ad}\x03\x02\x02\x02\u{572}\u{578}\x05\u{b2}\x5a\x02\u{573}\
	\u{574}\x05\u{22e}\u{118}\x02\u{574}\u{575}\x05\u{b2}\x5a\x02\u{575}\u{577}\
	\x03\x02\x02\x02\u{576}\u{573}\x03\x02\x02\x02\u{577}\u{57a}\x03\x02\x02\
	\x02\u{578}\u{576}\x03\x02\x02\x02\u{578}\u{579}\x03\x02\x02\x02\u{579}\
	\u{af}\x03\x02\x02\x02\u{57a}\u{578}\x03\x02\x02\x02\u{57b}\u{581}\x05\u{b4}\
	\x5b\x02\u{57c}\u{57d}\x05\u{22e}\u{118}\x02\u{57d}\u{57e}\x05\u{b4}\x5b\
	\x02\u{57e}\u{580}\x03\x02\x02\x02\u{57f}\u{57c}\x03\x02\x02\x02\u{580}\
	\u{583}\x03\x02\x02\x02\u{581}\u{57f}\x03\x02\x02\x02\u{581}\u{582}\x03\
	\x02\x02\x02\u{582}\u{b1}\x03\x02\x02\x02\u{583}\u{581}\x03\x02\x02\x02\
	\u{584}\u{585}\x05\u{138}\u{9d}\x02\u{585}\u{b3}\x03\x02\x02\x02\u{586}\
	\u{587}\x05\u{138}\u{9d}\x02\u{587}\u{b5}\x03\x02\x02\x02\u{588}\u{589}\
	\x05\u{16a}\u{b6}\x02\u{589}\u{58a}\x05\u{172}\u{ba}\x02\u{58a}\u{b7}\x03\
	\x02\x02\x02\u{58b}\u{58d}\x05\u{174}\u{bb}\x02\u{58c}\u{58e}\x05\u{ba}\
	\x5e\x02\u{58d}\u{58c}\x03\x02\x02\x02\u{58d}\u{58e}\x03\x02\x02\x02\u{58e}\
	\u{58f}\x03\x02\x02\x02\u{58f}\u{591}\x05\u{172}\u{ba}\x02\u{590}\u{592}\
	\x05\u{f6}\x7c\x02\u{591}\u{590}\x03\x02\x02\x02\u{591}\u{592}\x03\x02\x02\
	\x02\u{592}\u{b9}\x03\x02\x02\x02\u{593}\u{596}\x05\u{1c2}\u{e2}\x02\u{594}\
	\u{596}\x05\u{206}\u{104}\x02\u{595}\u{593}\x03\x02\x02\x02\u{595}\u{594}\
	\x03\x02\x02\x02\u{596}\u{bb}\x03\x02\x02\x02\u{597}\u{598}\x05\u{166}\u{b4}\
	\x02\u{598}\u{599}\x05\u{1b8}\u{dd}\x02\u{599}\u{59a}\x05\u{134}\u{9b}\x02\
	\u{59a}\u{59b}\x05\u{218}\u{10d}\x02\u{59b}\u{59c}\x05\u{1e4}\u{f3}\x02\
	\u{59c}\u{59d}\x07\u{ad}\x02\x02\u{59d}\u{59e}\x05\u{222}\u{112}\x02\u{59e}\
	\u{59f}\x05\u{be}\x60\x02\u{59f}\u{5a3}\x05\u{224}\u{113}\x02\u{5a0}\u{5a1}\
	\x05\u{168}\u{b5}\x02\u{5a1}\u{5a2}\x05\u{c2}\x62\x02\u{5a2}\u{5a4}\x03\
	\x02\x02\x02\u{5a3}\u{5a0}\x03\x02\x02\x02\u{5a3}\u{5a4}\x03\x02\x02\x02\
	\u{5a4}\u{bd}\x03\x02\x02\x02\u{5a5}\u{5ab}\x05\u{c0}\x61\x02\u{5a6}\u{5a7}\
	\x05\u{22e}\u{118}\x02\u{5a7}\u{5a8}\x05\u{c0}\x61\x02\u{5a8}\u{5aa}\x03\
	\x02\x02\x02\u{5a9}\u{5a6}\x03\x02\x02\x02\u{5aa}\u{5ad}\x03\x02\x02\x02\
	\u{5ab}\u{5a9}\x03\x02\x02\x02\u{5ab}\u{5ac}\x03\x02\x02\x02\u{5ac}\u{bf}\
	\x03\x02\x02\x02\u{5ad}\u{5ab}\x03\x02\x02\x02\u{5ae}\u{5af}\x07\u{a6}\x02\
	\x02\u{5af}\u{5b0}\x07\x0b\x02\x02\u{5b0}\u{5b5}\x07\u{a6}\x02\x02\u{5b1}\
	\u{5b2}\x07\u{a6}\x02\x02\u{5b2}\u{5b3}\x07\x0b\x02\x02\u{5b3}\u{5b5}\x07\
	\u{a7}\x02\x02\u{5b4}\u{5ae}\x03\x02\x02\x02\u{5b4}\u{5b1}\x03\x02\x02\x02\
	\u{5b5}\u{c1}\x03\x02\x02\x02\u{5b6}\u{5b7}\x05\u{18c}\u{c7}\x02\u{5b7}\
	\u{5b8}\x07\u{ad}\x02\x02\u{5b8}\u{5b9}\x05\u{130}\u{99}\x02\u{5b9}\u{c3}\
	\x03\x02\x02\x02\u{5ba}\u{5bb}\x05\u{20a}\u{106}\x02\u{5bb}\u{5bc}\x05\u{134}\
	\u{9b}\x02\u{5bc}\u{c5}\x03\x02\x02\x02\u{5bd}\u{5bf}\x05\u{200}\u{101}\
	\x02\u{5be}\u{5c0}\x05\u{1f8}\u{fd}\x02\u{5bf}\u{5be}\x03\x02\x02\x02\u{5bf}\
	\u{5c0}\x03\x02\x02\x02\u{5c0}\u{5c4}\x03\x02\x02\x02\u{5c1}\u{5c2}\x05\
	\u{134}\u{9b}\x02\u{5c2}\u{5c3}\x07\x10\x02\x02\u{5c3}\u{5c5}\x03\x02\x02\
	\x02\u{5c4}\u{5c1}\x03\x02\x02\x02\u{5c4}\u{5c5}\x03\x02\x02\x02\u{5c5}\
	\u{5c6}\x03\x02\x02\x02\u{5c6}\u{5c7}\x05\u{136}\u{9c}\x02\u{5c7}\u{c7}\
	\x03\x02\x02\x02\u{5c8}\u{5c9}\x05\u{180}\u{c1}\x02\u{5c9}\u{5cb}\x05\u{1a6}\
	\u{d4}\x02\u{5ca}\u{5cc}\x05\u{f8}\x7d\x02\u{5cb}\u{5ca}\x03\x02\x02\x02\
	\u{5cb}\u{5cc}\x03\x02\x02\x02\u{5cc}\u{5ce}\x03\x02\x02\x02\u{5cd}\u{5cf}\
	\x05\u{ca}\x66\x02\u{5ce}\u{5cd}\x03\x02\x02\x02\u{5ce}\u{5cf}\x03\x02\x02\
	\x02\u{5cf}\u{5d0}\x03\x02\x02\x02\u{5d0}\u{5d4}\x05\u{1d4}\u{eb}\x02\u{5d1}\
	\u{5d2}\x05\u{134}\u{9b}\x02\u{5d2}\u{5d3}\x07\x10\x02\x02\u{5d3}\u{5d5}\
	\x03\x02\x02\x02\u{5d4}\u{5d1}\x03\x02\x02\x02\u{5d4}\u{5d5}\x03\x02\x02\
	\x02\u{5d5}\u{5d6}\x03\x02\x02\x02\u{5d6}\u{5d7}\x05\u{136}\u{9c}\x02\u{5d7}\
	\u{5d8}\x05\u{21e}\u{110}\x02\u{5d8}\u{5d9}\x05\u{cc}\x67\x02\u{5d9}\u{5da}\
	\x05\u{220}\u{111}\x02\u{5da}\u{c9}\x03\x02\x02\x02\u{5db}\u{5de}\x07\u{ab}\
	\x02\x02\u{5dc}\u{5de}\x05\u{12e}\u{98}\x02\u{5dd}\u{5db}\x03\x02\x02\x02\
	\u{5dd}\u{5dc}\x03\x02\x02\x02\u{5de}\u{cb}\x03\x02\x02\x02\u{5df}\u{5e4}\
	\x05\u{138}\u{9d}\x02\u{5e0}\u{5e4}\x05\u{ce}\x68\x02\u{5e1}\u{5e4}\x05\
	\u{d0}\x69\x02\u{5e2}\u{5e4}\x05\u{d2}\x6a\x02\u{5e3}\u{5df}\x03\x02\x02\
	\x02\u{5e3}\u{5e0}\x03\x02\x02\x02\u{5e3}\u{5e1}\x03\x02\x02\x02\u{5e3}\
	\u{5e2}\x03\x02\x02\x02\u{5e4}\u{cd}\x03\x02\x02\x02\u{5e5}\u{5e6}\x05\u{1b6}\
	\u{dc}\x02\u{5e6}\u{5e7}\x05\u{21e}\u{110}\x02\u{5e7}\u{5e8}\x07\u{ab}\x02\
	\x02\u{5e8}\u{5e9}\x05\u{220}\u{111}\x02\u{5e9}\u{cf}\x03\x02\x02\x02\u{5ea}\
	\u{5eb}\x05\u{18e}\u{c8}\x02\u{5eb}\u{5ec}\x05\u{21e}\u{110}\x02\u{5ec}\
	\u{5ed}\x07\u{ab}\x02\x02\u{5ed}\u{5ee}\x05\u{220}\u{111}\x02\u{5ee}\u{d1}\
	\x03\x02\x02\x02\u{5ef}\u{5f0}\x05\u{19a}\u{ce}\x02\u{5f0}\u{5f1}\x05\u{21e}\
	\u{110}\x02\u{5f1}\u{5f2}\x07\u{ab}\x02\x02\u{5f2}\u{5f3}\x05\u{220}\u{111}\
	\x02\u{5f3}\u{d3}\x03\x02\x02\x02\u{5f4}\u{5f6}\x05\u{b8}\x5d\x02\u{5f5}\
	\u{5f4}\x03\x02\x02\x02\u{5f5}\u{5f6}\x03\x02\x02\x02\u{5f6}\u{5f7}\x03\
	\x02\x02\x02\u{5f7}\u{5f9}\x05\u{182}\u{c2}\x02\u{5f8}\u{5fa}\x05\u{d6}\
	\x6c\x02\u{5f9}\u{5f8}\x03\x02\x02\x02\u{5f9}\u{5fa}\x03\x02\x02\x02\u{5fa}\
	\u{5fb}\x03\x02\x02\x02\u{5fb}\u{5fd}\x05\u{10c}\u{87}\x02\u{5fc}\u{5fe}\
	\x05\u{f6}\x7c\x02\u{5fd}\u{5fc}\x03\x02\x02\x02\u{5fd}\u{5fe}\x03\x02\x02\
	\x02\u{5fe}\u{5ff}\x03\x02\x02\x02\u{5ff}\u{602}\x05\u{114}\u{8b}\x02\u{600}\
	\u{603}\x05\u{fa}\x7e\x02\u{601}\u{603}\x05\u{dc}\x6f\x02\u{602}\u{600}\
	\x03\x02\x02\x02\u{602}\u{601}\x03\x02\x02\x02\u{602}\u{603}\x03\x02\x02\
	\x02\u{603}\u{d5}\x03\x02\x02\x02\u{604}\u{60a}\x05\u{d8}\x6d\x02\u{605}\
	\u{606}\x05\u{22e}\u{118}\x02\u{606}\u{607}\x05\u{d8}\x6d\x02\u{607}\u{609}\
	\x03\x02\x02\x02\u{608}\u{605}\x03\x02\x02\x02\u{609}\u{60c}\x03\x02\x02\
	\x02\u{60a}\u{608}\x03\x02\x02\x02\u{60a}\u{60b}\x03\x02\x02\x02\u{60b}\
	\u{d7}\x03\x02\x02\x02\u{60c}\u{60a}\x03\x02\x02\x02\u{60d}\u{617}\x07\u{ab}\
	\x02\x02\u{60e}\u{60f}\x07\u{ab}\x02\x02\u{60f}\u{612}\x07\x07\x02\x02\u{610}\
	\u{613}\x05\u{12e}\u{98}\x02\u{611}\u{613}\x05\u{12a}\u{96}\x02\u{612}\u{610}\
	\x03\x02\x02\x02\u{612}\u{611}\x03\x02\x02\x02\u{613}\u{614}\x03\x02\x02\
	\x02\u{614}\u{615}\x07\x08\x02\x02\u{615}\u{617}\x03\x02\x02\x02\u{616}\
	\u{60d}\x03\x02\x02\x02\u{616}\u{60e}\x03\x02\x02\x02\u{617}\u{d9}\x03\x02\
	\x02\x02\u{618}\u{61a}\x05\u{b8}\x5d\x02\u{619}\u{618}\x03\x02\x02\x02\u{619}\
	\u{61a}\x03\x02\x02\x02\u{61a}\u{61b}\x03\x02\x02\x02\u{61b}\u{61f}\x05\
	\u{208}\u{105}\x02\u{61c}\u{61d}\x05\u{134}\u{9b}\x02\u{61d}\u{61e}\x07\
	\x10\x02\x02\u{61e}\u{620}\x03\x02\x02\x02\u{61f}\u{61c}\x03\x02\x02\x02\
	\u{61f}\u{620}\x03\x02\x02\x02\u{620}\u{621}\x03\x02\x02\x02\u{621}\u{623}\
	\x05\u{136}\u{9c}\x02\u{622}\u{624}\x05\u{f0}\x79\x02\u{623}\u{622}\x03\
	\x02\x02\x02\u{623}\u{624}\x03\x02\x02\x02\u{624}\u{625}\x03\x02\x02\x02\
	\u{625}\u{626}\x05\u{1ee}\u{f8}\x02\u{626}\u{627}\x05\u{e2}\x72\x02\u{627}\
	\u{62a}\x05\u{114}\u{8b}\x02\u{628}\u{62b}\x05\u{fa}\x7e\x02\u{629}\u{62b}\
	\x05\u{dc}\x6f\x02\u{62a}\u{628}\x03\x02\x02\x02\u{62a}\u{629}\x03\x02\x02\
	\x02\u{62a}\u{62b}\x03\x02\x02\x02\u{62b}\u{db}\x03\x02\x02\x02\u{62c}\u{62d}\
	\x05\u{1a2}\u{d2}\x02\u{62d}\u{62e}\x05\u{de}\x70\x02\u{62e}\u{dd}\x03\x02\
	\x02\x02\u{62f}\u{635}\x05\u{e0}\x71\x02\u{630}\u{631}\x05\u{168}\u{b5}\
	\x02\u{631}\u{632}\x05\u{e0}\x71\x02\u{632}\u{634}\x03\x02\x02\x02\u{633}\
	\u{630}\x03\x02\x02\x02\u{634}\u{637}\x03\x02\x02\x02\u{635}\u{633}\x03\
	\x02\x02\x02\u{635}\u{636}\x03\x02\x02\x02\u{636}\u{df}\x03\x02\x02\x02\
	\u{637}\u{635}\x03\x02\x02\x02\u{638}\u{639}\x07\u{ab}\x02\x02\u{639}\u{63a}\
	\x07\u{ad}\x02\x02\u{63a}\u{63b}\x05\u{128}\u{95}\x02\u{63b}\u{e1}\x03\x02\
	\x02\x02\u{63c}\u{642}\x05\u{e4}\x73\x02\u{63d}\u{63e}\x05\u{22e}\u{118}\
	\x02\u{63e}\u{63f}\x05\u{e4}\x73\x02\u{63f}\u{641}\x03\x02\x02\x02\u{640}\
	\u{63d}\x03\x02\x02\x02\u{641}\u{644}\x03\x02\x02\x02\u{642}\u{640}\x03\
	\x02\x02\x02\u{642}\u{643}\x03\x02\x02\x02\u{643}\u{e3}\x03\x02\x02\x02\
	\u{644}\u{642}\x03\x02\x02\x02\u{645}\u{646}\x07\u{ab}\x02\x02\u{646}\u{64b}\
	\x07\u{ad}\x02\x02\u{647}\u{64c}\x05\u{128}\u{95}\x02\u{648}\u{64c}\x05\
	\u{e8}\x75\x02\u{649}\u{64c}\x05\u{e6}\x74\x02\u{64a}\u{64c}\x05\u{ea}\x76\
	\x02\u{64b}\u{647}\x03\x02\x02\x02\u{64b}\u{648}\x03\x02\x02\x02\u{64b}\
	\u{649}\x03\x02\x02\x02\u{64b}\u{64a}\x03\x02\x02\x02\u{64c}\u{67b}\x03\
	\x02\x02\x02\u{64d}\u{64e}\x07\u{ab}\x02\x02\u{64e}\u{64f}\x07\u{ad}\x02\
	\x02\u{64f}\u{650}\x07\u{ab}\x02\x02\u{650}\u{651}\x09\x02\x02\x02\u{651}\
	\u{67b}\x05\u{12a}\u{96}\x02\u{652}\u{653}\x07\u{ab}\x02\x02\u{653}\u{654}\
	\x07\u{ad}\x02\x02\u{654}\u{655}\x07\u{ab}\x02\x02\u{655}\u{656}\x09\x02\
	\x02\x02\u{656}\u{67b}\x05\u{e6}\x74\x02\u{657}\u{658}\x07\u{ab}\x02\x02\
	\u{658}\u{659}\x07\u{ad}\x02\x02\u{659}\u{65a}\x05\u{e6}\x74\x02\u{65a}\
	\u{65b}\x09\x02\x02\x02\u{65b}\u{65c}\x07\u{ab}\x02\x02\u{65c}\u{67b}\x03\
	\x02\x02\x02\u{65d}\u{65e}\x07\u{ab}\x02\x02\u{65e}\u{65f}\x07\u{ad}\x02\
	\x02\u{65f}\u{660}\x07\u{ab}\x02\x02\u{660}\u{661}\x09\x02\x02\x02\u{661}\
	\u{67b}\x05\u{e8}\x75\x02\u{662}\u{663}\x07\u{ab}\x02\x02\u{663}\u{664}\
	\x07\u{ad}\x02\x02\u{664}\u{665}\x05\u{e8}\x75\x02\u{665}\u{666}\x09\x02\
	\x02\x02\u{666}\u{667}\x07\u{ab}\x02\x02\u{667}\u{67b}\x03\x02\x02\x02\u{668}\
	\u{669}\x07\u{ab}\x02\x02\u{669}\u{66a}\x07\u{ad}\x02\x02\u{66a}\u{66b}\
	\x07\u{ab}\x02\x02\u{66b}\u{66c}\x09\x02\x02\x02\u{66c}\u{67b}\x05\u{ea}\
	\x76\x02\u{66d}\u{66e}\x07\u{ab}\x02\x02\u{66e}\u{66f}\x07\u{ad}\x02\x02\
	\u{66f}\u{670}\x05\u{ea}\x76\x02\u{670}\u{671}\x09\x02\x02\x02\u{671}\u{672}\
	\x07\u{ab}\x02\x02\u{672}\u{67b}\x03\x02\x02\x02\u{673}\u{674}\x07\u{ab}\
	\x02\x02\u{674}\u{675}\x05\u{22a}\u{116}\x02\u{675}\u{676}\x05\u{12a}\u{96}\
	\x02\u{676}\u{677}\x05\u{22c}\u{117}\x02\u{677}\u{678}\x07\u{ad}\x02\x02\
	\u{678}\u{679}\x05\u{128}\u{95}\x02\u{679}\u{67b}\x03\x02\x02\x02\u{67a}\
	\u{645}\x03\x02\x02\x02\u{67a}\u{64d}\x03\x02\x02\x02\u{67a}\u{652}\x03\
	\x02\x02\x02\u{67a}\u{657}\x03\x02\x02\x02\u{67a}\u{65d}\x03\x02\x02\x02\
	\u{67a}\u{662}\x03\x02\x02\x02\u{67a}\u{668}\x03\x02\x02\x02\u{67a}\u{66d}\
	\x03\x02\x02\x02\u{67a}\u{673}\x03\x02\x02\x02\u{67b}\u{e5}\x03\x02\x02\
	\x02\u{67c}\u{686}\x05\u{222}\u{112}\x02\u{67d}\u{683}\x05\u{128}\u{95}\
	\x02\u{67e}\u{67f}\x05\u{22e}\u{118}\x02\u{67f}\u{680}\x05\u{128}\u{95}\
	\x02\u{680}\u{682}\x03\x02\x02\x02\u{681}\u{67e}\x03\x02\x02\x02\u{682}\
	\u{685}\x03\x02\x02\x02\u{683}\u{681}\x03\x02\x02\x02\u{683}\u{684}\x03\
	\x02\x02\x02\u{684}\u{687}\x03\x02\x02\x02\u{685}\u{683}\x03\x02\x02\x02\
	\u{686}\u{67d}\x03\x02\x02\x02\u{686}\u{687}\x03\x02\x02\x02\u{687}\u{688}\
	\x03\x02\x02\x02\u{688}\u{689}\x05\u{224}\u{113}\x02\u{689}\u{e7}\x03\x02\
	\x02\x02\u{68a}\u{68b}\x05\u{222}\u{112}\x02\u{68b}\u{68c}\x05\u{128}\u{95}\
	\x02\u{68c}\u{68d}\x05\u{230}\u{119}\x02\u{68d}\u{68e}\x05\u{128}\u{95}\
	\x02\u{68e}\u{696}\x03\x02\x02\x02\u{68f}\u{690}\x05\u{22e}\u{118}\x02\u{690}\
	\u{691}\x05\u{128}\u{95}\x02\u{691}\u{692}\x05\u{230}\u{119}\x02\u{692}\
	\u{693}\x05\u{128}\u{95}\x02\u{693}\u{695}\x03\x02\x02\x02\u{694}\u{68f}\
	\x03\x02\x02\x02\u{695}\u{698}\x03\x02\x02\x02\u{696}\u{694}\x03\x02\x02\
	\x02\u{696}\u{697}\x03\x02\x02\x02\u{697}\u{699}\x03\x02\x02\x02\u{698}\
	\u{696}\x03\x02\x02\x02\u{699}\u{69a}\x05\u{224}\u{113}\x02\u{69a}\u{e9}\
	\x03\x02\x02\x02\u{69b}\u{69c}\x05\u{22a}\u{116}\x02\u{69c}\u{6a2}\x05\u{128}\
	\u{95}\x02\u{69d}\u{69e}\x05\u{22e}\u{118}\x02\u{69e}\u{69f}\x05\u{128}\
	\u{95}\x02\u{69f}\u{6a1}\x03\x02\x02\x02\u{6a0}\u{69d}\x03\x02\x02\x02\u{6a1}\
	\u{6a4}\x03\x02\x02\x02\u{6a2}\u{6a0}\x03\x02\x02\x02\u{6a2}\u{6a3}\x03\
	\x02\x02\x02\u{6a3}\u{6a5}\x03\x02\x02\x02\u{6a4}\u{6a2}\x03\x02\x02\x02\
	\u{6a5}\u{6a6}\x05\u{22c}\u{117}\x02\u{6a6}\u{eb}\x03\x02\x02\x02\u{6a7}\
	\u{6c4}\x05\u{21e}\u{110}\x02\u{6a8}\u{6b9}\x05\u{128}\u{95}\x02\u{6a9}\
	\u{6aa}\x05\u{22e}\u{118}\x02\u{6aa}\u{6ab}\x05\u{128}\u{95}\x02\u{6ab}\
	\u{6ad}\x03\x02\x02\x02\u{6ac}\u{6a9}\x03\x02\x02\x02\u{6ad}\u{6b0}\x03\
	\x02\x02\x02\u{6ae}\u{6ac}\x03\x02\x02\x02\u{6ae}\u{6af}\x03\x02\x02\x02\
	\u{6af}\u{6ba}\x03\x02\x02\x02\u{6b0}\u{6ae}\x03\x02\x02\x02\u{6b1}\u{6b2}\
	\x05\u{22e}\u{118}\x02\u{6b2}\u{6b3}\x05\u{ec}\x77\x02\u{6b3}\u{6b5}\x03\
	\x02\x02\x02\u{6b4}\u{6b1}\x03\x02\x02\x02\u{6b5}\u{6b8}\x03\x02\x02\x02\
	\u{6b6}\u{6b4}\x03\x02\x02\x02\u{6b6}\u{6b7}\x03\x02\x02\x02\u{6b7}\u{6ba}\
	\x03\x02\x02\x02\u{6b8}\u{6b6}\x03\x02\x02\x02\u{6b9}\u{6ae}\x03\x02\x02\
	\x02\u{6b9}\u{6b6}\x03\x02\x02\x02\u{6ba}\u{6c5}\x03\x02\x02\x02\u{6bb}\
	\u{6c1}\x05\u{ec}\x77\x02\u{6bc}\u{6bd}\x05\u{22e}\u{118}\x02\u{6bd}\u{6be}\
	\x05\u{ec}\x77\x02\u{6be}\u{6c0}\x03\x02\x02\x02\u{6bf}\u{6bc}\x03\x02\x02\
	\x02\u{6c0}\u{6c3}\x03\x02\x02\x02\u{6c1}\u{6bf}\x03\x02\x02\x02\u{6c1}\
	\u{6c2}\x03\x02\x02\x02\u{6c2}\u{6c5}\x03\x02\x02\x02\u{6c3}\u{6c1}\x03\
	\x02\x02\x02\u{6c4}\u{6a8}\x03\x02\x02\x02\u{6c4}\u{6bb}\x03\x02\x02\x02\
	\u{6c5}\u{6c6}\x03\x02\x02\x02\u{6c6}\u{6c7}\x05\u{220}\u{111}\x02\u{6c7}\
	\u{ed}\x03\x02\x02\x02\u{6c8}\u{6ca}\x05\u{b8}\x5d\x02\u{6c9}\u{6c8}\x03\
	\x02\x02\x02\u{6c9}\u{6ca}\x03\x02\x02\x02\u{6ca}\u{6cb}\x03\x02\x02\x02\
	\u{6cb}\u{6cc}\x05\u{1ac}\u{d7}\x02\u{6cc}\u{6d0}\x05\u{1ae}\u{d8}\x02\u{6cd}\
	\u{6ce}\x05\u{134}\u{9b}\x02\u{6ce}\u{6cf}\x07\x10\x02\x02\u{6cf}\u{6d1}\
	\x03\x02\x02\x02\u{6d0}\u{6cd}\x03\x02\x02\x02\u{6d0}\u{6d1}\x03\x02\x02\
	\x02\u{6d1}\u{6d2}\x03\x02\x02\x02\u{6d2}\u{6d4}\x05\u{136}\u{9c}\x02\u{6d3}\
	\u{6d5}\x05\u{fe}\u{80}\x02\u{6d4}\u{6d3}\x03\x02\x02\x02\u{6d4}\u{6d5}\
	\x03\x02\x02\x02\u{6d5}\u{6d6}\x03\x02\x02\x02\u{6d6}\u{6d8}\x05\u{fc}\x7f\
	\x02\u{6d7}\u{6d9}\x05\u{f8}\x7d\x02\u{6d8}\u{6d7}\x03\x02\x02\x02\u{6d8}\
	\u{6d9}\x03\x02\x02\x02\u{6d9}\u{6db}\x03\x02\x02\x02\u{6da}\u{6dc}\x05\
	\u{f0}\x79\x02\u{6db}\u{6da}\x03\x02\x02\x02\u{6db}\u{6dc}\x03\x02\x02\x02\
	\u{6dc}\u{ef}\x03\x02\x02\x02\u{6dd}\u{6de}\x05\u{210}\u{109}\x02\u{6de}\
	\u{6df}\x05\u{f4}\x7b\x02\u{6df}\u{6ee}\x03\x02\x02\x02\u{6e0}\u{6e1}\x05\
	\u{210}\u{109}\x02\u{6e1}\u{6e2}\x05\u{f4}\x7b\x02\u{6e2}\u{6e3}\x05\u{168}\
	\u{b5}\x02\u{6e3}\u{6e4}\x05\u{f2}\x7a\x02\u{6e4}\u{6ee}\x03\x02\x02\x02\
	\u{6e5}\u{6e6}\x05\u{210}\u{109}\x02\u{6e6}\u{6e7}\x05\u{f2}\x7a\x02\u{6e7}\
	\u{6ee}\x03\x02\x02\x02\u{6e8}\u{6e9}\x05\u{210}\u{109}\x02\u{6e9}\u{6ea}\
	\x05\u{f2}\x7a\x02\u{6ea}\u{6eb}\x05\u{168}\u{b5}\x02\u{6eb}\u{6ec}\x05\
	\u{f4}\x7b\x02\u{6ec}\u{6ee}\x03\x02\x02\x02\u{6ed}\u{6dd}\x03\x02\x02\x02\
	\u{6ed}\u{6e0}\x03\x02\x02\x02\u{6ed}\u{6e5}\x03\x02\x02\x02\u{6ed}\u{6e8}\
	\x03\x02\x02\x02\u{6ee}\u{f1}\x03\x02\x02\x02\u{6ef}\u{6f0}\x05\u{1fa}\u{fe}\
	\x02\u{6f0}\u{6f1}\x05\u{12a}\u{96}\x02\u{6f1}\u{f3}\x03\x02\x02\x02\u{6f2}\
	\u{6f3}\x05\u{202}\u{102}\x02\u{6f3}\u{6f4}\x05\u{12a}\u{96}\x02\u{6f4}\
	\u{f5}\x03\x02\x02\x02\u{6f5}\u{6f6}\x05\u{210}\u{109}\x02\u{6f6}\u{6f7}\
	\x05\u{f2}\x7a\x02\u{6f7}\u{f7}\x03\x02\x02\x02\u{6f8}\u{6f9}\x05\u{1a2}\
	\u{d2}\x02\u{6f9}\u{6fa}\x05\u{1ce}\u{e8}\x02\u{6fa}\u{6fb}\x05\u{192}\u{ca}\
	\x02\u{6fb}\u{f9}\x03\x02\x02\x02\u{6fc}\u{6fd}\x05\u{1a2}\u{d2}\x02\u{6fd}\
	\u{6fe}\x05\u{192}\u{ca}\x02\u{6fe}\u{fb}\x03\x02\x02\x02\u{6ff}\u{700}\
	\x05\u{212}\u{10a}\x02\u{700}\u{701}\x07\x03\x02\x02\u{701}\u{702}\x05\u{102}\
	\u{82}\x02\u{702}\u{703}\x07\x04\x02\x02\u{703}\u{708}\x03\x02\x02\x02\u{704}\
	\u{705}\x05\u{1b2}\u{da}\x02\u{705}\u{706}\x05\u{128}\u{95}\x02\u{706}\u{708}\
	\x03\x02\x02\x02\u{707}\u{6ff}\x03\x02\x02\x02\u{707}\u{704}\x03\x02\x02\
	\x02\u{708}\u{fd}\x03\x02\x02\x02\u{709}\u{70a}\x07\x03\x02\x02\u{70a}\u{70b}\
	\x05\u{100}\u{81}\x02\u{70b}\u{70c}\x07\x04\x02\x02\u{70c}\u{ff}\x03\x02\
	\x02\x02\u{70d}\u{713}\x05\u{138}\u{9d}\x02\u{70e}\u{70f}\x05\u{22e}\u{118}\
	\x02\u{70f}\u{710}\x05\u{138}\u{9d}\x02\u{710}\u{712}\x03\x02\x02\x02\u{711}\
	\u{70e}\x03\x02\x02\x02\u{712}\u{715}\x03\x02\x02\x02\u{713}\u{711}\x03\
	\x02\x02\x02\u{713}\u{714}\x03\x02\x02\x02\u{714}\u{101}\x03\x02\x02\x02\
	\u{715}\u{713}\x03\x02\x02\x02\u{716}\u{71c}\x05\u{104}\u{83}\x02\u{717}\
	\u{718}\x05\u{22e}\u{118}\x02\u{718}\u{719}\x05\u{104}\u{83}\x02\u{719}\
	\u{71b}\x03\x02\x02\x02\u{71a}\u{717}\x03\x02\x02\x02\u{71b}\u{71e}\x03\
	\x02\x02\x02\u{71c}\u{71a}\x03\x02\x02\x02\u{71c}\u{71d}\x03\x02\x02\x02\
	\u{71d}\u{103}\x03\x02\x02\x02\u{71e}\u{71c}\x03\x02\x02\x02\u{71f}\u{725}\
	\x05\u{128}\u{95}\x02\u{720}\u{725}\x05\u{e8}\x75\x02\u{721}\u{725}\x05\
	\u{e6}\x74\x02\u{722}\u{725}\x05\u{ea}\x76\x02\u{723}\u{725}\x05\u{ec}\x77\
	\x02\u{724}\u{71f}\x03\x02\x02\x02\u{724}\u{720}\x03\x02\x02\x02\u{724}\
	\u{721}\x03\x02\x02\x02\u{724}\u{722}\x03\x02\x02\x02\u{724}\u{723}\x03\
	\x02\x02\x02\u{725}\u{105}\x03\x02\x02\x02\u{726}\u{728}\x05\u{1ec}\u{f7}\
	\x02\u{727}\u{729}\x05\u{116}\u{8c}\x02\u{728}\u{727}\x03\x02\x02\x02\u{728}\
	\u{729}\x03\x02\x02\x02\u{729}\u{72b}\x03\x02\x02\x02\u{72a}\u{72c}\x05\
	\u{1b2}\u{da}\x02\u{72b}\u{72a}\x03\x02\x02\x02\u{72b}\u{72c}\x03\x02\x02\
	\x02\u{72c}\u{72d}\x03\x02\x02\x02\u{72d}\u{72e}\x05\u{118}\u{8d}\x02\u{72e}\
	\u{730}\x05\u{10c}\u{87}\x02\u{72f}\u{731}\x05\u{114}\u{8b}\x02\u{730}\u{72f}\
	\x03\x02\x02\x02\u{730}\u{731}\x03\x02\x02\x02\u{731}\u{733}\x03\x02\x02\
	\x02\u{732}\u{734}\x05\u{110}\u{89}\x02\u{733}\u{732}\x03\x02\x02\x02\u{733}\
	\u{734}\x03\x02\x02\x02\u{734}\u{736}\x03\x02\x02\x02\u{735}\u{737}\x05\
	\u{10a}\u{86}\x02\u{736}\u{735}\x03\x02\x02\x02\u{736}\u{737}\x03\x02\x02\
	\x02\u{737}\u{739}\x03\x02\x02\x02\u{738}\u{73a}\x05\u{108}\u{85}\x02\u{739}\
	\u{738}\x03\x02\x02\x02\u{739}\u{73a}\x03\x02\x02\x02\u{73a}\u{107}\x03\
	\x02\x02\x02\u{73b}\u{73c}\x05\u{164}\u{b3}\x02\u{73c}\u{73d}\x05\u{194}\
	\u{cb}\x02\u{73d}\u{109}\x03\x02\x02\x02\u{73e}\u{73f}\x05\u{1be}\u{e0}\
	\x02\u{73f}\u{740}\x05\u{12a}\u{96}\x02\u{740}\u{10b}\x03\x02\x02\x02\u{741}\
	\u{742}\x05\u{198}\u{cd}\x02\u{742}\u{743}\x05\u{10e}\u{88}\x02\u{743}\u{10d}\
	\x03\x02\x02\x02\u{744}\u{749}\x07\u{ab}\x02\x02\u{745}\u{746}\x07\u{ab}\
	\x02\x02\u{746}\u{747}\x07\x10\x02\x02\u{747}\u{749}\x07\u{ab}\x02\x02\u{748}\
	\u{744}\x03\x02\x02\x02\u{748}\u{745}\x03\x02\x02\x02\u{749}\u{10f}\x03\
	\x02\x02\x02\u{74a}\u{74b}\x05\u{1da}\u{ee}\x02\u{74b}\u{74c}\x05\u{176}\
	\u{bc}\x02\u{74c}\u{74d}\x05\u{112}\u{8a}\x02\u{74d}\u{111}\x03\x02\x02\
	\x02\u{74e}\u{751}\x07\u{ab}\x02\x02\u{74f}\u{752}\x05\u{16e}\u{b8}\x02\
	\u{750}\u{752}\x05\u{184}\u{c3}\x02\u{751}\u{74f}\x03\x02\x02\x02\u{751}\
	\u{750}\x03\x02\x02\x02\u{751}\u{752}\x03\x02\x02\x02\u{752}\u{113}\x03\
	\x02\x02\x02\u{753}\u{754}\x05\u{216}\u{10c}\x02\u{754}\u{755}\x05\u{11c}\
	\u{8f}\x02\u{755}\u{115}\x03\x02\x02\x02\u{756}\u{757}\x05\u{188}\u{c5}\
	\x02\u{757}\u{117}\x03\x02\x02\x02\u{758}\u{75b}\x07\x11\x02\x02\u{759}\
	\u{75b}\x05\u{11a}\u{8e}\x02\u{75a}\u{758}\x03\x02\x02\x02\u{75a}\u{759}\
	\x03\x02\x02\x02\u{75b}\u{761}\x03\x02\x02\x02\u{75c}\u{75d}\x05\u{22e}\
	\u{118}\x02\u{75d}\u{75e}\x05\u{11a}\u{8e}\x02\u{75e}\u{760}\x03\x02\x02\
	\x02\u{75f}\u{75c}\x03\x02\x02\x02\u{760}\u{763}\x03\x02\x02\x02\u{761}\
	\u{75f}\x03\x02\x02\x02\u{761}\u{762}\x03\x02\x02\x02\u{762}\u{119}\x03\
	\x02\x02\x02\u{763}\u{761}\x03\x02\x02\x02\u{764}\u{765}\x07\u{ab}\x02\x02\
	\u{765}\u{766}\x07\x10\x02\x02\u{766}\u{774}\x07\x11\x02\x02\u{767}\u{76b}\
	\x07\u{ab}\x02\x02\u{768}\u{769}\x05\u{16c}\u{b7}\x02\u{769}\u{76a}\x07\
	\u{ab}\x02\x02\u{76a}\u{76c}\x03\x02\x02\x02\u{76b}\u{768}\x03\x02\x02\x02\
	\u{76b}\u{76c}\x03\x02\x02\x02\u{76c}\u{774}\x03\x02\x02\x02\u{76d}\u{771}\
	\x05\u{124}\u{93}\x02\u{76e}\u{76f}\x05\u{16c}\u{b7}\x02\u{76f}\u{770}\x07\
	\u{ab}\x02\x02\u{770}\u{772}\x03\x02\x02\x02\u{771}\u{76e}\x03\x02\x02\x02\
	\u{771}\u{772}\x03\x02\x02\x02\u{772}\u{774}\x03\x02\x02\x02\u{773}\u{764}\
	\x03\x02\x02\x02\u{773}\u{767}\x03\x02\x02\x02\u{773}\u{76d}\x03\x02\x02\
	\x02\u{774}\u{11b}\x03\x02\x02\x02\u{775}\u{77b}\x05\u{11e}\u{90}\x02\u{776}\
	\u{777}\x05\u{168}\u{b5}\x02\u{777}\u{778}\x05\u{11e}\u{90}\x02\u{778}\u{77a}\
	\x03\x02\x02\x02\u{779}\u{776}\x03\x02\x02\x02\u{77a}\u{77d}\x03\x02\x02\
	\x02\u{77b}\u{779}\x03\x02\x02\x02\u{77b}\u{77c}\x03\x02\x02\x02\u{77c}\
	\u{11d}\x03\x02\x02\x02\u{77d}\u{77b}\x03\x02\x02\x02\u{77e}\u{77f}\x07\
	\u{ab}\x02\x02\u{77f}\u{780}\x09\x03\x02\x02\u{780}\u{7c6}\x05\u{128}\u{95}\
	\x02\u{781}\u{782}\x07\u{ab}\x02\x02\u{782}\u{783}\x07\x10\x02\x02\u{783}\
	\u{784}\x07\u{ab}\x02\x02\u{784}\u{785}\x09\x03\x02\x02\u{785}\u{7c6}\x05\
	\u{128}\u{95}\x02\u{786}\u{787}\x05\u{124}\u{93}\x02\u{787}\u{788}\x09\x03\
	\x02\x02\u{788}\u{789}\x05\u{128}\u{95}\x02\u{789}\u{7c6}\x03\x02\x02\x02\
	\u{78a}\u{78b}\x05\u{124}\u{93}\x02\u{78b}\u{78c}\x09\x03\x02\x02\u{78c}\
	\u{78d}\x05\u{124}\u{93}\x02\u{78d}\u{7c6}\x03\x02\x02\x02\u{78e}\u{78f}\
	\x07\u{ab}\x02\x02\u{78f}\u{790}\x05\u{1a4}\u{d3}\x02\u{790}\u{792}\x07\
	\x03\x02\x02\u{791}\u{793}\x05\u{126}\u{94}\x02\u{792}\u{791}\x03\x02\x02\
	\x02\u{792}\u{793}\x03\x02\x02\x02\u{793}\u{794}\x03\x02\x02\x02\u{794}\
	\u{795}\x07\x04\x02\x02\u{795}\u{7c6}\x03\x02\x02\x02\u{796}\u{797}\x07\
	\x03\x02\x02\u{797}\u{79d}\x07\u{ab}\x02\x02\u{798}\u{799}\x05\u{22e}\u{118}\
	\x02\u{799}\u{79a}\x07\u{ab}\x02\x02\u{79a}\u{79c}\x03\x02\x02\x02\u{79b}\
	\u{798}\x03\x02\x02\x02\u{79c}\u{79f}\x03\x02\x02\x02\u{79d}\u{79b}\x03\
	\x02\x02\x02\u{79d}\u{79e}\x03\x02\x02\x02\u{79e}\u{7a0}\x03\x02\x02\x02\
	\u{79f}\u{79d}\x03\x02\x02\x02\u{7a0}\u{7a1}\x07\x04\x02\x02\u{7a1}\u{7a2}\
	\x05\u{1a4}\u{d3}\x02\u{7a2}\u{7a3}\x07\x03\x02\x02\u{7a3}\u{7a9}\x05\u{ec}\
	\x77\x02\u{7a4}\u{7a5}\x05\u{22e}\u{118}\x02\u{7a5}\u{7a6}\x05\u{ec}\x77\
	\x02\u{7a6}\u{7a8}\x03\x02\x02\x02\u{7a7}\u{7a4}\x03\x02\x02\x02\u{7a8}\
	\u{7ab}\x03\x02\x02\x02\u{7a9}\u{7a7}\x03\x02\x02\x02\u{7a9}\u{7aa}\x03\
	\x02\x02\x02\u{7aa}\u{7ac}\x03\x02\x02\x02\u{7ab}\u{7a9}\x03\x02\x02\x02\
	\u{7ac}\u{7ad}\x07\x04\x02\x02\u{7ad}\u{7c6}\x03\x02\x02\x02\u{7ae}\u{7af}\
	\x07\x03\x02\x02\u{7af}\u{7b5}\x07\u{ab}\x02\x02\u{7b0}\u{7b1}\x05\u{22e}\
	\u{118}\x02\u{7b1}\u{7b2}\x07\u{ab}\x02\x02\u{7b2}\u{7b4}\x03\x02\x02\x02\
	\u{7b3}\u{7b0}\x03\x02\x02\x02\u{7b4}\u{7b7}\x03\x02\x02\x02\u{7b5}\u{7b3}\
	\x03\x02\x02\x02\u{7b5}\u{7b6}\x03\x02\x02\x02\u{7b6}\u{7b8}\x03\x02\x02\
	\x02\u{7b7}\u{7b5}\x03\x02\x02\x02\u{7b8}\u{7b9}\x07\x04\x02\x02\u{7b9}\
	\u{7ba}\x09\x03\x02\x02\u{7ba}\u{7c0}\x05\u{ec}\x77\x02\u{7bb}\u{7bc}\x05\
	\u{22e}\u{118}\x02\u{7bc}\u{7bd}\x05\u{ec}\x77\x02\u{7bd}\u{7bf}\x03\x02\
	\x02\x02\u{7be}\u{7bb}\x03\x02\x02\x02\u{7bf}\u{7c2}\x03\x02\x02\x02\u{7c0}\
	\u{7be}\x03\x02\x02\x02\u{7c0}\u{7c1}\x03\x02\x02\x02\u{7c1}\u{7c6}\x03\
	\x02\x02\x02\u{7c2}\u{7c0}\x03\x02\x02\x02\u{7c3}\u{7c6}\x05\u{122}\u{92}\
	\x02\u{7c4}\u{7c6}\x05\u{120}\u{91}\x02\u{7c5}\u{77e}\x03\x02\x02\x02\u{7c5}\
	\u{781}\x03\x02\x02\x02\u{7c5}\u{786}\x03\x02\x02\x02\u{7c5}\u{78a}\x03\
	\x02\x02\x02\u{7c5}\u{78e}\x03\x02\x02\x02\u{7c5}\u{796}\x03\x02\x02\x02\
	\u{7c5}\u{7ae}\x03\x02\x02\x02\u{7c5}\u{7c3}\x03\x02\x02\x02\u{7c5}\u{7c4}\
	\x03\x02\x02\x02\u{7c6}\u{11f}\x03\x02\x02\x02\u{7c7}\u{7c8}\x07\u{ab}\x02\
	\x02\u{7c8}\u{7c9}\x05\u{17e}\u{c0}\x02\u{7c9}\u{7ca}\x05\u{128}\u{95}\x02\
	\u{7ca}\u{121}\x03\x02\x02\x02\u{7cb}\u{7cc}\x07\u{ab}\x02\x02\u{7cc}\u{7cd}\
	\x05\u{17e}\u{c0}\x02\u{7cd}\u{7ce}\x05\u{1b4}\u{db}\x02\u{7ce}\u{7cf}\x03\
	\x02\x02\x02\u{7cf}\u{7d0}\x05\u{128}\u{95}\x02\u{7d0}\u{123}\x03\x02\x02\
	\x02\u{7d1}\u{7d2}\x07\u{ab}\x02\x02\u{7d2}\u{7d3}\x07\x03\x02\x02\u{7d3}\
	\u{7d4}\x07\x11\x02\x02\u{7d4}\u{7dc}\x07\x04\x02\x02\u{7d5}\u{7d6}\x07\
	\u{ab}\x02\x02\u{7d6}\u{7d8}\x07\x03\x02\x02\u{7d7}\u{7d9}\x05\u{126}\u{94}\
	\x02\u{7d8}\u{7d7}\x03\x02\x02\x02\u{7d8}\u{7d9}\x03\x02\x02\x02\u{7d9}\
	\u{7da}\x03\x02\x02\x02\u{7da}\u{7dc}\x07\x04\x02\x02\u{7db}\u{7d1}\x03\
	\x02\x02\x02\u{7db}\u{7d5}\x03\x02\x02\x02\u{7dc}\u{125}\x03\x02\x02\x02\
	\u{7dd}\u{7e1}\x05\u{128}\u{95}\x02\u{7de}\u{7e1}\x07\u{ab}\x02\x02\u{7df}\
	\u{7e1}\x05\u{124}\u{93}\x02\u{7e0}\u{7dd}\x03\x02\x02\x02\u{7e0}\u{7de}\
	\x03\x02\x02\x02\u{7e0}\u{7df}\x03\x02\x02\x02\u{7e1}\u{7ea}\x03\x02\x02\
	\x02\u{7e2}\u{7e6}\x05\u{22e}\u{118}\x02\u{7e3}\u{7e7}\x05\u{128}\u{95}\
	\x02\u{7e4}\u{7e7}\x07\u{ab}\x02\x02\u{7e5}\u{7e7}\x05\u{124}\u{93}\x02\
	\u{7e6}\u{7e3}\x03\x02\x02\x02\u{7e6}\u{7e4}\x03\x02\x02\x02\u{7e6}\u{7e5}\
	\x03\x02\x02\x02\u{7e7}\u{7e9}\x03\x02\x02\x02\u{7e8}\u{7e2}\x03\x02\x02\
	\x02\u{7e9}\u{7ec}\x03\x02\x02\x02\u{7ea}\u{7e8}\x03\x02\x02\x02\u{7ea}\
	\u{7eb}\x03\x02\x02\x02\u{7eb}\u{127}\x03\x02\x02\x02\u{7ec}\u{7ea}\x03\
	\x02\x02\x02\u{7ed}\u{7f6}\x07\u{ac}\x02\x02\u{7ee}\u{7f6}\x05\u{12e}\u{98}\
	\x02\u{7ef}\u{7f6}\x05\u{12a}\u{96}\x02\u{7f0}\u{7f6}\x05\u{12c}\u{97}\x02\
	\u{7f1}\u{7f6}\x05\u{132}\u{9a}\x02\u{7f2}\u{7f6}\x05\u{130}\u{99}\x02\u{7f3}\
	\u{7f6}\x05\x32\x1a\x02\u{7f4}\u{7f6}\x05\u{1d0}\u{e9}\x02\u{7f5}\u{7ed}\
	\x03\x02\x02\x02\u{7f5}\u{7ee}\x03\x02\x02\x02\u{7f5}\u{7ef}\x03\x02\x02\
	\x02\u{7f5}\u{7f0}\x03\x02\x02\x02\u{7f5}\u{7f1}\x03\x02\x02\x02\u{7f5}\
	\u{7f2}\x03\x02\x02\x02\u{7f5}\u{7f3}\x03\x02\x02\x02\u{7f5}\u{7f4}\x03\
	\x02\x02\x02\u{7f6}\u{129}\x03\x02\x02\x02\u{7f7}\u{7f8}\x07\u{a7}\x02\x02\
	\u{7f8}\u{12b}\x03\x02\x02\x02\u{7f9}\u{7fa}\x09\x04\x02\x02\u{7fa}\u{12d}\
	\x03\x02\x02\x02\u{7fb}\u{7fc}\x07\u{a6}\x02\x02\u{7fc}\u{12f}\x03\x02\x02\
	\x02\u{7fd}\u{7fe}\x09\x05\x02\x02\u{7fe}\u{131}\x03\x02\x02\x02\u{7ff}\
	\u{800}\x07\u{a9}\x02\x02\u{800}\u{133}\x03\x02\x02\x02\u{801}\u{806}\x07\
	\u{ab}\x02\x02\u{802}\u{803}\x07\x17\x02\x02\u{803}\u{804}\x07\u{ab}\x02\
	\x02\u{804}\u{806}\x07\x17\x02\x02\u{805}\u{801}\x03\x02\x02\x02\u{805}\
	\u{802}\x03\x02\x02\x02\u{806}\u{135}\x03\x02\x02\x02\u{807}\u{80c}\x07\
	\u{ab}\x02\x02\u{808}\u{809}\x07\x17\x02\x02\u{809}\u{80a}\x07\u{ab}\x02\
	\x02\u{80a}\u{80c}\x07\x17\x02\x02\u{80b}\u{807}\x03\x02\x02\x02\u{80b}\
	\u{808}\x03\x02\x02\x02\u{80c}\u{137}\x03\x02\x02\x02\u{80d}\u{812}\x07\
	\u{ab}\x02\x02\u{80e}\u{80f}\x07\x17\x02\x02\u{80f}\u{810}\x07\u{ab}\x02\
	\x02\u{810}\u{812}\x07\x17\x02\x02\u{811}\u{80d}\x03\x02\x02\x02\u{811}\
	\u{80e}\x03\x02\x02\x02\u{812}\u{139}\x03\x02\x02\x02\u{813}\u{815}\x05\
	\u{13c}\u{9f}\x02\u{814}\u{816}\x05\u{13e}\u{a0}\x02\u{815}\u{814}\x03\x02\
	\x02\x02\u{815}\u{816}\x03\x02\x02\x02\u{816}\u{13b}\x03\x02\x02\x02\u{817}\
	\u{818}\x09\x06\x02\x02\u{818}\u{13d}\x03\x02\x02\x02\u{819}\u{81a}\x05\
	\u{226}\u{114}\x02\u{81a}\u{820}\x05\u{13c}\u{9f}\x02\u{81b}\u{81c}\x05\
	\u{22e}\u{118}\x02\u{81c}\u{81d}\x05\u{13c}\u{9f}\x02\u{81d}\u{81f}\x03\
	\x02\x02\x02\u{81e}\u{81b}\x03\x02\x02\x02\u{81f}\u{822}\x03\x02\x02\x02\
	\u{820}\u{81e}\x03\x02\x02\x02\u{820}\u{821}\x03\x02\x02\x02\u{821}\u{823}\
	\x03\x02\x02\x02\u{822}\u{820}\x03\x02\x02\x02\u{823}\u{824}\x05\u{228}\
	\u{115}\x02\u{824}\u{13f}\x03\x02\x02\x02\u{825}\u{828}\x05\u{16e}\u{b8}\
	\x02\u{826}\u{828}\x05\u{184}\u{c3}\x02\u{827}\u{825}\x03\x02\x02\x02\u{827}\
	\u{826}\x03\x02\x02\x02\u{828}\u{141}\x03\x02\x02\x02\u{829}\u{82a}\x07\
	\u{ab}\x02\x02\u{82a}\u{143}\x03\x02\x02\x02\u{82b}\u{82c}\x07\u{ab}\x02\
	\x02\u{82c}\u{145}\x03\x02\x02\x02\u{82d}\u{82e}\x05\u{12e}\u{98}\x02\u{82e}\
	\u{147}\x03\x02\x02\x02\u{82f}\u{830}\x07\u{ab}\x02\x02\u{830}\u{149}\x03\
	\x02\x02\x02\u{831}\u{832}\x07\u{ab}\x02\x02\u{832}\u{14b}\x03\x02\x02\x02\
	\u{833}\u{834}\x07\u{ab}\x02\x02\u{834}\u{14d}\x03\x02\x02\x02\u{835}\u{836}\
	\x07\u{ab}\x02\x02\u{836}\u{14f}\x03\x02\x02\x02\u{837}\u{838}\x07\u{ab}\
	\x02\x02\u{838}\u{151}\x03\x02\x02\x02\u{839}\u{83a}\x07\u{ab}\x02\x02\u{83a}\
	\u{153}\x03\x02\x02\x02\u{83b}\u{83c}\x05\u{12e}\u{98}\x02\u{83c}\u{155}\
	\x03\x02\x02\x02\u{83d}\u{83e}\x07\u{ab}\x02\x02\u{83e}\u{157}\x03\x02\x02\
	\x02\u{83f}\u{840}\x05\u{15a}\u{ae}\x02\u{840}\u{841}\x05\u{13a}\u{9e}\x02\
	\u{841}\u{159}\x03\x02\x02\x02\u{842}\u{843}\x07\u{ab}\x02\x02\u{843}\u{15b}\
	\x03\x02\x02\x02\u{844}\u{845}\x07\x19\x02\x02\u{845}\u{15d}\x03\x02\x02\
	\x02\u{846}\u{847}\x07\x1a\x02\x02\u{847}\u{15f}\x03\x02\x02\x02\u{848}\
	\u{849}\x07\x1b\x02\x02\u{849}\u{161}\x03\x02\x02\x02\u{84a}\u{84b}\x07\
	\x1b\x02\x02\u{84b}\u{84c}\x07\x67\x02\x02\u{84c}\u{163}\x03\x02\x02\x02\
	\u{84d}\u{84e}\x07\x1c\x02\x02\u{84e}\u{165}\x03\x02\x02\x02\u{84f}\u{850}\
	\x07\x1d\x02\x02\u{850}\u{167}\x03\x02\x02\x02\u{851}\u{852}\x07\x1e\x02\
	\x02\u{852}\u{169}\x03\x02\x02\x02\u{853}\u{854}\x07\x20\x02\x02\u{854}\
	\u{16b}\x03\x02\x02\x02\u{855}\u{856}\x07\x21\x02\x02\u{856}\u{16d}\x03\
	\x02\x02\x02\u{857}\u{858}\x07\x22\x02\x02\u{858}\u{16f}\x03\x02\x02\x02\
	\u{859}\u{85a}\x07\x23\x02\x02\u{85a}\u{171}\x03\x02\x02\x02\u{85b}\u{85c}\
	\x07\x24\x02\x02\u{85c}\u{173}\x03\x02\x02\x02\u{85d}\u{85e}\x07\x25\x02\
	\x02\u{85e}\u{175}\x03\x02\x02\x02\u{85f}\u{860}\x07\x26\x02\x02\u{860}\
	\u{177}\x03\x02\x02\x02\u{861}\u{862}\x07\x27\x02\x02\u{862}\u{179}\x03\
	\x02\x02\x02\u{863}\u{864}\x07\x28\x02\x02\u{864}\u{17b}\x03\x02\x02\x02\
	\u{865}\u{866}\x07\x2a\x02\x02\u{866}\u{17d}\x03\x02\x02\x02\u{867}\u{868}\
	\x07\x2c\x02\x02\u{868}\u{17f}\x03\x02\x02\x02\u{869}\u{86a}\x07\x2d\x02\
	\x02\u{86a}\u{181}\x03\x02\x02\x02\u{86b}\u{86c}\x07\x2f\x02\x02\u{86c}\
	\u{183}\x03\x02\x02\x02\u{86d}\u{86e}\x07\x30\x02\x02\u{86e}\u{185}\x03\
	\x02\x02\x02\u{86f}\u{870}\x07\x31\x02\x02\u{870}\u{187}\x03\x02\x02\x02\
	\u{871}\u{872}\x07\x32\x02\x02\u{872}\u{189}\x03\x02\x02\x02\u{873}\u{874}\
	\x07\x33\x02\x02\u{874}\u{18b}\x03\x02\x02\x02\u{875}\u{876}\x07\x34\x02\
	\x02\u{876}\u{18d}\x03\x02\x02\x02\u{877}\u{878}\x07\x36\x02\x02\u{878}\
	\u{18f}\x03\x02\x02\x02\u{879}\u{87a}\x07\x37\x02\x02\u{87a}\u{191}\x03\
	\x02\x02\x02\u{87b}\u{87c}\x07\x38\x02\x02\u{87c}\u{193}\x03\x02\x02\x02\
	\u{87d}\u{87e}\x07\x3a\x02\x02\u{87e}\u{195}\x03\x02\x02\x02\u{87f}\u{880}\
	\x07\x3b\x02\x02\u{880}\u{197}\x03\x02\x02\x02\u{881}\u{882}\x07\x3c\x02\
	\x02\u{882}\u{199}\x03\x02\x02\x02\u{883}\u{884}\x07\x3d\x02\x02\u{884}\
	\u{19b}\x03\x02\x02\x02\u{885}\u{886}\x07\x3e\x02\x02\u{886}\u{19d}\x03\
	\x02\x02\x02\u{887}\u{888}\x07\x3f\x02\x02\u{888}\u{19f}\x03\x02\x02\x02\
	\u{889}\u{88a}\x07\x40\x02\x02\u{88a}\u{1a1}\x03\x02\x02\x02\u{88b}\u{88c}\
	\x07\x41\x02\x02\u{88c}\u{1a3}\x03\x02\x02\x02\u{88d}\u{88e}\x07\x42\x02\
	\x02\u{88e}\u{1a5}\x03\x02\x02\x02\u{88f}\u{890}\x07\x43\x02\x02\u{890}\
	\u{1a7}\x03\x02\x02\x02\u{891}\u{892}\x07\x45\x02\x02\u{892}\u{1a9}\x03\
	\x02\x02\x02\u{893}\u{894}\x07\x46\x02\x02\u{894}\u{1ab}\x03\x02\x02\x02\
	\u{895}\u{896}\x07\x47\x02\x02\u{896}\u{1ad}\x03\x02\x02\x02\u{897}\u{898}\
	\x07\x48\x02\x02\u{898}\u{1af}\x03\x02\x02\x02\u{899}\u{89a}\x07\x49\x02\
	\x02\u{89a}\u{1b1}\x03\x02\x02\x02\u{89b}\u{89c}\x07\x4a\x02\x02\u{89c}\
	\u{1b3}\x03\x02\x02\x02\u{89d}\u{89e}\x07\x4b\x02\x02\u{89e}\u{1b5}\x03\
	\x02\x02\x02\u{89f}\u{8a0}\x07\x4c\x02\x02\u{8a0}\u{1b7}\x03\x02\x02\x02\
	\u{8a1}\u{8a2}\x07\x4d\x02\x02\u{8a2}\u{1b9}\x03\x02\x02\x02\u{8a3}\u{8a4}\
	\x07\x4e\x02\x02\u{8a4}\u{1bb}\x03\x02\x02\x02\u{8a5}\u{8a6}\x07\x4f\x02\
	\x02\u{8a6}\u{1bd}\x03\x02\x02\x02\u{8a7}\u{8a8}\x07\x51\x02\x02\u{8a8}\
	\u{1bf}\x03\x02\x02\x02\u{8a9}\u{8aa}\x07\u{9b}\x02\x02\u{8aa}\u{1c1}\x03\
	\x02\x02\x02\u{8ab}\u{8ac}\x07\x54\x02\x02\u{8ac}\u{1c3}\x03\x02\x02\x02\
	\u{8ad}\u{8ae}\x07\x55\x02\x02\u{8ae}\u{1c5}\x03\x02\x02\x02\u{8af}\u{8b0}\
	\x07\x56\x02\x02\u{8b0}\u{1c7}\x03\x02\x02\x02\u{8b1}\u{8b2}\x07\x57\x02\
	\x02\u{8b2}\u{1c9}\x03\x02\x02\x02\u{8b3}\u{8b4}\x07\x5a\x02\x02\u{8b4}\
	\u{1cb}\x03\x02\x02\x02\u{8b5}\u{8b6}\x07\x59\x02\x02\u{8b6}\u{1cd}\x03\
	\x02\x02\x02\u{8b7}\u{8b8}\x07\x5b\x02\x02\u{8b8}\u{1cf}\x03\x02\x02\x02\
	\u{8b9}\u{8ba}\x07\x5c\x02\x02\u{8ba}\u{1d1}\x03\x02\x02\x02\u{8bb}\u{8bc}\
	\x07\x5d\x02\x02\u{8bc}\u{1d3}\x03\x02\x02\x02\u{8bd}\u{8be}\x07\x5e\x02\
	\x02\u{8be}\u{1d5}\x03\x02\x02\x02\u{8bf}\u{8c0}\x07\x60\x02\x02\u{8c0}\
	\u{1d7}\x03\x02\x02\x02\u{8c1}\u{8c2}\x07\x61\x02\x02\u{8c2}\u{1d9}\x03\
	\x02\x02\x02\u{8c3}\u{8c4}\x07\x62\x02\x02\u{8c4}\u{1db}\x03\x02\x02\x02\
	\u{8c5}\u{8c6}\x07\x64\x02\x02\u{8c6}\u{1dd}\x03\x02\x02\x02\u{8c7}\u{8c8}\
	\x07\x68\x02\x02\u{8c8}\u{1df}\x03\x02\x02\x02\u{8c9}\u{8ca}\x07\x6a\x02\
	\x02\u{8ca}\u{1e1}\x03\x02\x02\x02\u{8cb}\u{8cc}\x07\x6b\x02\x02\u{8cc}\
	\u{1e3}\x03\x02\x02\x02\u{8cd}\u{8ce}\x07\x6c\x02\x02\u{8ce}\u{1e5}\x03\
	\x02\x02\x02\u{8cf}\u{8d0}\x07\x6d\x02\x02\u{8d0}\u{1e7}\x03\x02\x02\x02\
	\u{8d1}\u{8d2}\x07\x6f\x02\x02\u{8d2}\u{1e9}\x03\x02\x02\x02\u{8d3}\u{8d4}\
	\x07\x70\x02\x02\u{8d4}\u{1eb}\x03\x02\x02\x02\u{8d5}\u{8d6}\x07\x72\x02\
	\x02\u{8d6}\u{1ed}\x03\x02\x02\x02\u{8d7}\u{8d8}\x07\x73\x02\x02\u{8d8}\
	\u{1ef}\x03\x02\x02\x02\u{8d9}\u{8da}\x07\x74\x02\x02\u{8da}\u{1f1}\x03\
	\x02\x02\x02\u{8db}\u{8dc}\x07\x76\x02\x02\u{8dc}\u{1f3}\x03\x02\x02\x02\
	\u{8dd}\u{8de}\x07\x77\x02\x02\u{8de}\u{1f5}\x03\x02\x02\x02\u{8df}\u{8e0}\
	\x07\x78\x02\x02\u{8e0}\u{1f7}\x03\x02\x02\x02\u{8e1}\u{8e2}\x07\x79\x02\
	\x02\u{8e2}\u{1f9}\x03\x02\x02\x02\u{8e3}\u{8e4}\x07\x7b\x02\x02\u{8e4}\
	\u{1fb}\x03\x02\x02\x02\u{8e5}\u{8e6}\x07\x7c\x02\x02\u{8e6}\u{1fd}\x03\
	\x02\x02\x02\u{8e7}\u{8e8}\x07\x7e\x02\x02\u{8e8}\u{1ff}\x03\x02\x02\x02\
	\u{8e9}\u{8ea}\x07\u{80}\x02\x02\u{8ea}\u{201}\x03\x02\x02\x02\u{8eb}\u{8ec}\
	\x07\u{81}\x02\x02\u{8ec}\u{203}\x03\x02\x02\x02\u{8ed}\u{8ee}\x07\u{83}\
	\x02\x02\u{8ee}\u{205}\x03\x02\x02\x02\u{8ef}\u{8f0}\x07\u{84}\x02\x02\u{8f0}\
	\u{207}\x03\x02\x02\x02\u{8f1}\u{8f2}\x07\u{85}\x02\x02\u{8f2}\u{209}\x03\
	\x02\x02\x02\u{8f3}\u{8f4}\x07\u{86}\x02\x02\u{8f4}\u{20b}\x03\x02\x02\x02\
	\u{8f5}\u{8f6}\x07\u{87}\x02\x02\u{8f6}\u{20d}\x03\x02\x02\x02\u{8f7}\u{8f8}\
	\x07\u{b2}\x02\x02\u{8f8}\u{20f}\x03\x02\x02\x02\u{8f9}\u{8fa}\x07\u{88}\
	\x02\x02\u{8fa}\u{211}\x03\x02\x02\x02\u{8fb}\u{8fc}\x07\u{8a}\x02\x02\u{8fc}\
	\u{213}\x03\x02\x02\x02\u{8fd}\u{8fe}\x07\u{8b}\x02\x02\u{8fe}\u{215}\x03\
	\x02\x02\x02\u{8ff}\u{900}\x07\u{8c}\x02\x02\u{900}\u{217}\x03\x02\x02\x02\
	\u{901}\u{902}\x07\u{8d}\x02\x02\u{902}\u{219}\x03\x02\x02\x02\u{903}\u{904}\
	\x07\x6e\x02\x02\u{904}\u{21b}\x03\x02\x02\x02\u{905}\u{906}\x07\x02\x02\
	\x03\u{906}\u{21d}\x03\x02\x02\x02\u{907}\u{908}\x07\x03\x02\x02\u{908}\
	\u{21f}\x03\x02\x02\x02\u{909}\u{90a}\x07\x04\x02\x02\u{90a}\u{221}\x03\
	\x02\x02\x02\u{90b}\u{90c}\x07\x05\x02\x02\u{90c}\u{223}\x03\x02\x02\x02\
	\u{90d}\u{90e}\x07\x06\x02\x02\u{90e}\u{225}\x03\x02\x02\x02\u{90f}\u{910}\
	\x07\u{ae}\x02\x02\u{910}\u{227}\x03\x02\x02\x02\u{911}\u{912}\x07\u{af}\
	\x02\x02\u{912}\u{229}\x03\x02\x02\x02\u{913}\u{914}\x07\x07\x02\x02\u{914}\
	\u{22b}\x03\x02\x02\x02\u{915}\u{916}\x07\x08\x02\x02\u{916}\u{22d}\x03\
	\x02\x02\x02\u{917}\u{918}\x07\x09\x02\x02\u{918}\u{22f}\x03\x02\x02\x02\
	\u{919}\u{91a}\x07\x0b\x02\x02\u{91a}\u{231}\x03\x02\x02\x02\u{b5}\u{233}\
	\u{236}\u{23c}\u{241}\u{243}\u{248}\u{24b}\u{24e}\u{279}\u{28a}\u{28d}\u{294}\
	\u{299}\u{2a4}\u{2ae}\u{2bd}\u{2c8}\u{2cd}\u{2d6}\u{2db}\u{2e3}\u{2e8}\u{2ec}\
	\u{2f1}\u{2f6}\u{305}\u{30b}\u{310}\u{31a}\u{31f}\u{329}\u{335}\u{33c}\u{344}\
	\u{352}\u{357}\u{363}\u{367}\u{36b}\u{370}\u{375}\u{388}\u{38f}\u{397}\u{39b}\
	\u{3a0}\u{3b3}\u{3bc}\u{3cb}\u{3cd}\u{3d9}\u{3e7}\u{3ee}\u{3f5}\u{3fd}\u{408}\
	\u{418}\u{425}\u{430}\u{447}\u{455}\u{45c}\u{465}\u{478}\u{480}\u{486}\u{48b}\
	\u{492}\u{497}\u{49f}\u{4a4}\u{4ab}\u{4b0}\u{4b7}\u{4bc}\u{4c3}\u{4ca}\u{4d1}\
	\u{4d8}\u{4dd}\u{4e4}\u{4eb}\u{4f0}\u{4f7}\u{4fc}\u{503}\u{507}\u{50a}\u{512}\
	\u{51c}\u{527}\u{52d}\u{536}\u{543}\u{54b}\u{551}\u{556}\u{564}\u{578}\u{581}\
	\u{58d}\u{591}\u{595}\u{5a3}\u{5ab}\u{5b4}\u{5bf}\u{5c4}\u{5cb}\u{5ce}\u{5d4}\
	\u{5dd}\u{5e3}\u{5f5}\u{5f9}\u{5fd}\u{602}\u{60a}\u{612}\u{616}\u{619}\u{61f}\
	\u{623}\u{62a}\u{635}\u{642}\u{64b}\u{67a}\u{683}\u{686}\u{696}\u{6a2}\u{6ae}\
	\u{6b6}\u{6b9}\u{6c1}\u{6c4}\u{6c9}\u{6d0}\u{6d4}\u{6d8}\u{6db}\u{6ed}\u{707}\
	\u{713}\u{71c}\u{724}\u{728}\u{72b}\u{730}\u{733}\u{736}\u{739}\u{748}\u{751}\
	\u{75a}\u{761}\u{76b}\u{771}\u{773}\u{77b}\u{792}\u{79d}\u{7a9}\u{7b5}\u{7c0}\
	\u{7c5}\u{7d8}\u{7db}\u{7e0}\u{7e6}\u{7ea}\u{7f5}\u{805}\u{80b}\u{811}\u{815}\
	\u{820}\u{827}";

